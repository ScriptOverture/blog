<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://scriptoverture.github.io/blog/feed.xml" rel="self" type="application/atom+xml" /><link href="https://scriptoverture.github.io/blog/" rel="alternate" type="text/html" /><updated>2025-09-19T16:56:32+00:00</updated><id>https://scriptoverture.github.io/blog/feed.xml</id><title type="html">overture</title><subtitle>scriptoverture/blog</subtitle><author><name>scriptoverture</name></author><entry><title type="html">实现多窗口同步的副作用归一化实践</title><link href="https://scriptoverture.github.io/blog/2025/09/19/%E5%A4%9A%E7%AA%97%E5%8F%A3%E5%90%8C%E6%AD%A5%E6%80%9D%E8%80%83/" rel="alternate" type="text/html" title="实现多窗口同步的副作用归一化实践" /><published>2025-09-19T00:00:00+00:00</published><updated>2025-09-19T00:00:00+00:00</updated><id>https://scriptoverture.github.io/blog/2025/09/19/%E5%A4%9A%E7%AA%97%E5%8F%A3%E5%90%8C%E6%AD%A5%E6%80%9D%E8%80%83</id><content type="html" xml:base="https://scriptoverture.github.io/blog/2025/09/19/%E5%A4%9A%E7%AA%97%E5%8F%A3%E5%90%8C%E6%AD%A5%E6%80%9D%E8%80%83/"><![CDATA[<h2 id="多窗口同步方案">多窗口同步方案</h2>

<h4 id="概念介绍从纯函数思想到副作用归一化">概念介绍：从纯函数思想到副作用归一化</h4>
<p>将窗口抽象想象为函数调用：<strong>如果能让所有窗口都表现为”纯函数”，就能解决同步问题</strong>。</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 理想状态：窗口 = 纯函数
Window(userActions) =&gt; UIState

// 纯函数特性：相同输入 → 相同输出
Window(actions) === Window(actions) // 总是为 true
</code></pre></div></div>
<p>如果窗口表现为纯函数，用户输入行为对应存函数入参，传入相同<strong>入参</strong>执行后可以得到完全一致的页面输出，从而实现多个窗口效果同步。</p>

<p>然后，事实是<strong>副作用</strong>无处不在：</p>
<ul>
  <li>网络请求：HTTP调用，API调用</li>
  <li>埋点曝光：行为统计，数据上报</li>
  <li>随机数状态：UUID生成，时间戳获取等</li>
  <li>存储操作</li>
</ul>

<p>副作用产生的不确定性，导致相同入参调用还是会产生不同结果。
举例来说🌰：</p>
<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">uuid</span><span class="p">,</span> <span class="nx">setUuid</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">();</span>
<span class="p">&lt;</span><span class="nt">div</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="nx">handleTest</span><span class="si">}</span><span class="p">&gt;</span>button--<span class="si">{</span><span class="nx">uuid</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>

<span class="kd">function</span> <span class="nx">handleTest</span><span class="p">()</span> <span class="p">{</span>
   <span class="kd">const</span> <span class="nx">newUuid</span> <span class="o">=</span> <span class="nx">getUuid</span><span class="p">();</span>
   <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newUuid</span><span class="p">);</span>
   <span class="nx">setUuid</span><span class="p">(</span><span class="nx">newUuid</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>哪怕俩个窗口都触发调用 <code class="language-plaintext highlighter-rouge">handleTest</code> 方法，界面展示会因为 <code class="language-plaintext highlighter-rouge">Uuid</code> 的随机性出现差异化。</p>

<h4 id="副作用归一化">副作用归一化</h4>
<p>什么是副作用归一化？</p>

<p><strong>副作用归一化 = 让”不确定操作”变成”确定操作”</strong>
简单来说：由一个窗口先执行完整流程期间自动收集对应副作用结果，其他窗口执行相同操作副作用计算从记录中获取副作用结果，而不重新计算结果。</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Leader窗口(发起)：用户操作 → （执行副作用 → 收集结果 → 缓存）[劫持] → 同步
Other窗口(同步)：用户操作 → （劫持副作用 → 从记录获取）[劫持] → 使用结果
</code></pre></div></div>

<p>副作用归一化难点：</p>
<ul>
  <li>保障同一个事件在多个窗口调用一致的上下文标识</li>
  <li>怎么保障副作用存储顺序，以及缓存恢复顺序</li>
  <li>异步及异步嵌套场景，怎么保障存储顺序</li>
  <li>异步上下文丢失错误场景，怎么主动恢复</li>
  <li>怎么确保一定有可以消费的副作用缓存记录</li>
  <li>内存管理与清理</li>
</ul>

<h4 id="实现方案">实现方案</h4>
<h5 id="上下文一致性-contextid">上下文一致性 ContextId</h5>

<p><strong>方式一</strong>：利用 <code class="language-plaintext highlighter-rouge">Babel，SWC</code> 这类编译工具，在编译阶段为每个用户交互操作自动注入唯一标识符，这个过程对开发者完全透明（开发人员不可见）</p>

<p>事件劫持 + 上下文标识自动绑定:</p>
<pre><code class="language-typesctipt">// 编写的原始代码
&lt;div onClick={handleClick}&gt;

// 自动转换后的代码（开发者不可见）
&lt;div onClick={syncEvent(handleClick, 'sync-唯一id')} syncKind={'sync-唯一id'}&gt;
通过编译时注入的唯一标识符，确保多个窗口在执行相同用户操作时拥有一致的执行上下文
// 所有窗口中相同的交互元素都拥有相同的syncKind
TabA: &lt;button syncKind="sync-uuid-002" /&gt;
TabB: &lt;button syncKind="sync-uuid-002" /&gt;  
TabC: &lt;button syncKind="sync-uuid-002" /&gt;

// 上下文的一致性标识
</code></pre>
<p><strong>方式二</strong>：动态生成事件上下文标识，将事件与标识捆绑同步给其他窗口， 也能保障事件执行上下文的一致性。
简单对比：
动态生成对应副作用不方便细颗粒管理</p>
<ol>
  <li>没法感知事件执行次数</li>
  <li>没法回放调试</li>
  <li>调用链路不方便扩展</li>
</ol>

<p>根据静态特征，很方便实现插件机制举例🌰：</p>
<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">sendMessageKind</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Component_sync_demo</span><span class="dl">'</span>

<span class="kd">const</span> <span class="nx">Component</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">&lt;</span><span class="nt">div</span> <span class="na">sync-bind</span><span class="p">=</span><span class="si">{</span><span class="nx">sendMessageKind</span><span class="si">}</span><span class="p">&gt;</span>xxxx<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="kd">const</span> <span class="nx">syncPlugins</span> <span class="o">=</span> <span class="p">{</span>
   <span class="p">[</span><span class="nx">sendMessageKind</span><span class="p">]:</span> <span class="p">{</span>
      <span class="c1">// 用户行为执行前 () =&gt; void;</span>
      <span class="c1">// 消息同步前 () =&gt; void;</span>
      <span class="c1">// 消息接受前 () =&gt; void;</span>
      <span class="c1">// 消息接受方执行完毕 () =&gt; void;</span>
      <span class="c1">// ....</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>上例 <code class="language-plaintext highlighter-rouge">sync-bind</code> 可覆盖 <code class="language-plaintext highlighter-rouge">Babel</code> 自动生成的唯一值。
静态方便扩展，方便提供不同阶段钩子，同时有利后续链路回放调试。</p>

<h5 id="用户行为同步">用户行为同步</h5>
<h6 id="发送方">发送方</h6>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">syncEvent</span><span class="p">(</span><span class="nx">eventHandler</span><span class="p">,</span> <span class="nx">syncContextId</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">return</span> <span class="p">(...</span><span class="nx">args</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="c1">// 标识当前操作上下文 -&gt; syncContextId</span>

      <span class="c1">// 事件执行</span>
      <span class="nx">eventHandler</span><span class="p">(...</span><span class="nx">args</span><span class="p">)</span>

      <span class="c1">// 窗口同步</span>
      <span class="nx">syncMesssageInfo</span><span class="p">(</span>
         <span class="nx">syncContextId</span><span class="p">,</span> <span class="c1">// 操作上下文</span>
         <span class="nx">effectRecords</span><span class="p">,</span> <span class="c1">// 事件调用链同步上下文副作用记录</span>
         <span class="nx">eventType</span><span class="p">,</span>     <span class="c1">// 事件类型</span>
         <span class="p">...</span><span class="nx">more</span>
      <span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p><strong>发送方执行流程</strong>：</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
用户操作 → 事件劫持 → 上下文声明 → 原始事件执行 → 副作用收集 → 窗口同步
         ←————————————— 插件钩子覆盖整个生命周期 —————————————→
</code></pre></div></div>
<h6 id="接受方">接受方</h6>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">receiveMessage</span><span class="p">({</span> <span class="nx">payload</span> <span class="p">})</span> <span class="p">{</span>
   <span class="kd">const</span> <span class="p">{</span>
      <span class="nx">syncContextId</span><span class="p">,</span>
      <span class="nx">effectRecords</span><span class="p">,</span>
      <span class="nx">eventType</span>
   <span class="p">}</span> <span class="o">=</span> <span class="nx">payload</span><span class="p">;</span>

   <span class="c1">// 副作用恢复</span>

   <span class="kd">const</span> <span class="nx">eventDom</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s2">`sync-</span><span class="p">${</span><span class="nx">syncContextId</span><span class="p">}</span><span class="s2">`</span><span class="p">)</span>
   <span class="nx">eventDom</span><span class="p">[</span><span class="nx">eventType</span><span class="p">]?.()</span>
<span class="p">}</span>
</code></pre></div></div>
<p><strong>接收方执行流程</strong>：</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>消息接收 → 副作用上下文恢复 → 目标元素定位 → 原生事件模拟 → 事件劫持处理
</code></pre></div></div>

<h4 id="副作用收集-️">副作用收集 ️</h4>
<p><strong>方案思考</strong></p>

<p>以下面函数举例🌰：</p>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">handleTest</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
   <span class="kd">const</span> <span class="nx">u1</span> <span class="o">=</span> <span class="nx">getUuid</span><span class="p">();</span> <span class="c1">// &lt;- 随机性，需要记录</span>
   <span class="kd">const</span> <span class="nx">t1</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">();</span><span class="c1">// &lt;- 瞬态，需要记录</span>
   <span class="kd">const</span> <span class="nx">newU1</span> <span class="o">=</span> <span class="s2">`sync_</span><span class="p">${</span><span class="nx">u1</span><span class="p">}</span><span class="s2">_last`</span><span class="p">;</span> <span class="c1">// u1一致newU1一致，自动计算</span>
   <span class="kd">const</span> <span class="nx">u2</span> <span class="o">=</span> <span class="nx">getUuid</span><span class="p">();</span> <span class="c1">// &lt;- 随机性，需要记录</span>
<span class="p">}</span>
</code></pre></div></div>
<h5 id="按类型分组存储初始方案">按类型分组存储（初始方案）</h5>
<p>最初尝试为不同类型的副作用分配独立队列：</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
   uuid: [u1, u2],
   date: [t1]
}
</code></pre></div></div>

<p>考虑到异步场景，扩展为同步/异步分离结构：</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
   async: {
      uuid: [u1, u2],
      date: [t1]
   },
   sync: {
      uuid: [],
      date: []
   }
}
</code></pre></div></div>
<h6 id="异步顺序问题">异步顺序问题</h6>
<p>然而，异步不同于同步这般简单可控，由事件循环调度上下文切换；无法保障顺序一致性：</p>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
   <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">log1</span><span class="dl">'</span><span class="p">)</span>
<span class="p">},</span> <span class="mi">2</span><span class="p">)</span>
<span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
   <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">log2</span><span class="dl">'</span><span class="p">)</span>
<span class="p">},</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>
<p>这种不确定性在复杂的异步嵌套场景下更加明显，上述的分类存储方案无法解决顺序问题。</p>

<h5 id="插槽机制">插槽机制</h5>
<p>为了解决异步顺序问题，这里引入”插槽”概念，通过“静态分析”确保执行顺序的一致性。</p>

<p><strong>插槽类型定义</strong>：</p>
<ul>
  <li>同步插槽：立即执行并赋值</li>
  <li>异步插槽：等待事件循环调度，但插槽位置预先确定</li>
  <li>上下文继承：异步回调执行时，会继承父级插槽上下文，形成嵌套的插槽序列</li>
</ul>

<p>这样关注面不再是同步/异步的区别，而是调用顺序的确定性。
<strong>示例分析</strong>🌰：</p>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">handleTest</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
   <span class="kd">const</span> <span class="nx">u1</span> <span class="o">=</span> <span class="nx">getUuid</span><span class="p">();</span>   <span class="c1">// 0  &lt;-自增标识</span>
   <span class="kd">const</span> <span class="nx">t1</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">();</span>  <span class="c1">// 1</span>
   <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>      <span class="c1">// 2</span>
      <span class="nx">getUuid</span><span class="p">()</span>            <span class="c1">// 2-0</span>
      <span class="nx">getUuid</span><span class="p">()</span>            <span class="c1">// 2-1</span>
   <span class="p">})</span>
   <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>      <span class="c1">// 3</span>
      <span class="nx">getUuid</span><span class="p">()</span>            <span class="c1">// 3-0</span>
   <span class="p">},</span> <span class="mi">1000</span><span class="p">)</span>
   <span class="kd">const</span> <span class="nx">newU1</span> <span class="o">=</span> <span class="s2">`sync_</span><span class="p">${</span><span class="nx">u1</span><span class="p">}</span><span class="s2">_last`</span><span class="p">;</span>
   <span class="kd">const</span> <span class="nx">u2</span> <span class="o">=</span> <span class="nx">getUuid</span><span class="p">();</span> 	<span class="c1">// 4</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>插槽上下文结构</strong>：</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// eventContext
eventContext = [
   slot(u1 = getUuid()),
   slot(t1 = Date.now()),
   slot(syncContext_2), // 异步上下文
   slot(syncContext_3), // 异步上下文
   slot(u2 = getUuid())
]


// 异步上下文syncContext2
syncContext2 = [
   slot(getUuid())// 2-0, &lt;-自增标识 延续父插槽标识
   slot(getUuid())// 2-1,
]

// 异步上下文syncContext3
syncContext3 = [
   slot(getUuid())// 3-0,
]
</code></pre></div></div>
<p>每个插槽生成自增标识，并延续父插槽标识，形成层次化的标识体系。</p>

<h4 id="副作用同步机制">副作用同步机制</h4>
<h5 id="分阶段同步">分阶段同步</h5>
<ul>
  <li>主上下文完成：事件执行完毕，同步上下文中“同步插槽副作用”。</li>
  <li>异步上下文完成：当每个异步上下文执行完毕，自动同步当前上下文副作用。</li>
</ul>

<p>以上文“异步上下文 <code class="language-plaintext highlighter-rouge">syncContext2</code> ”同步举例🌰：</p>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// syncContext2 的父级插槽为</span>
<span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>      <span class="c1">// slotKind =&gt; 2</span>
   <span class="nx">getUuid</span><span class="p">()</span>            <span class="c1">// slotKind =&gt; 2-0</span>
   <span class="nx">getUuid</span><span class="p">()</span>            <span class="c1">// slotKind =&gt; 2-1</span>
<span class="p">})</span>
</code></pre></div></div>
<p><strong>上下文副作用提取</strong></p>

<p>利用插槽的自增标识特性（延续父插槽标识）。通过简单标识前置位匹配，可以很方便将当前上下文副作用提取出来：</p>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nx">EffectStore</span><span class="p">)</span>
<span class="p">.</span><span class="nx">filter</span><span class="p">(([</span><span class="nx">key</span><span class="p">])</span> <span class="o">=&gt;</span> <span class="nx">key</span><span class="p">.</span><span class="nx">starsWith</span><span class="p">(</span><span class="s2">`slotKind =&gt; 2`</span><span class="p">))</span>
<span class="c1">// [[2-0, xx], [2-1, xx]]</span>
</code></pre></div></div>
<p>存在同步副作用，会自动推送到其他窗口。</p>

<p><strong>接收方副作用恢复</strong></p>

<p>接收方事件调用时，同样会收集插槽，每个插槽的副作用结果从记录中根据相同插槽标识获取恢复：</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">handleTest</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
   <span class="kd">const</span> <span class="nx">u1</span> <span class="o">=</span> <span class="nx">getUuid</span><span class="p">();</span>   <span class="c1">// &lt;劫持  根据 slotKind_0 获取记录</span>
   <span class="kd">const</span> <span class="nx">t1</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">();</span>  <span class="c1">// &lt;劫持  根据 slotKind_1 获取记录</span>
   <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>      <span class="c1">// &lt;劫持  根据 slotKind_2 获取记录</span>
      <span class="nx">getUuid</span><span class="p">()</span>            <span class="c1">// &lt;劫持  根据 slotKind_2_0 获取记录</span>
      <span class="nx">getUuid</span><span class="p">()</span>            <span class="c1">// &lt;劫持  根据 slotKind_2_1 获取记录</span>
   <span class="p">})</span>
   <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>      <span class="c1">// &lt;劫持  根据 slotKind_3 获取记录</span>
      <span class="nx">getUuid</span><span class="p">()</span>            <span class="c1">// &lt;劫持  根据 slotKind_3_0 获取记录</span>
   <span class="p">},</span> <span class="mi">1000</span><span class="p">)</span>
   <span class="kd">const</span> <span class="nx">newU1</span> <span class="o">=</span> <span class="s2">`sync_</span><span class="p">${</span><span class="nx">u1</span><span class="p">}</span><span class="s2">_last`</span><span class="p">;</span>
   <span class="kd">const</span> <span class="nx">u2</span> <span class="o">=</span> <span class="nx">getUuid</span><span class="p">();</span> 	<span class="c1">// &lt;劫持  根据 slotKind_4 获取记录</span>
<span class="p">}</span>
</code></pre></div></div>
<p>这样就可以得到一致的结果</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>发送方handleTest() === 同步方A_handleTest() === 同步方B_handleTest()
</code></pre></div></div>

<h5 id="await-分段推送">await 分段推送</h5>
<p><strong>await 上下文切割问题</strong></p>

<p>根据上文设计，同步代码会在首次执行完毕后立即同步，异步操作会在完成时自动触发同步。但 await 关键字会切割执行链路，导致 await 后续的同步操作无法被正确同步。</p>

<p>举个例子🌰：</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 插槽序列分析
[
   slot(sync_1),    // 同步操作
   slot(await_2),   // 异步等待点
   slot(sync_3),    // await 后的同步操作
   slot(sync_4),    // await 后的同步操作  
   slot(await_5),   // 下一个异步等待点
]
</code></pre></div></div>
<p>在上述序列中，<code class="language-plaintext highlighter-rouge">sync_3</code> 和 <code class="language-plaintext highlighter-rouge">sync_4</code> 由于位于 <code class="language-plaintext highlighter-rouge">await_2</code> 之后，会在异步恢复时执行，但此时同步上下文已经丢失，导致这些操作无法被正确同步到其他窗口。</p>

<p><strong>解决方案：分段推送策略</strong></p>

<p>以 <code class="language-plaintext highlighter-rouge">await</code> 为分割点，将执行链路划分为多个同步段：
<strong>切分时机</strong></p>
<ul>
  <li>首次执行阶段：仅同步 <code class="language-plaintext highlighter-rouge">sync_1</code></li>
  <li>延时同步阶段：每个 <code class="language-plaintext highlighter-rouge">await</code> 操作完成时，不立即同步结果，而是继续执行后续同步操作，直到遇到下一个 <code class="language-plaintext highlighter-rouge">await</code> 或执行结束，然后将整个段的结果一次性同步</li>
</ul>

<p><strong>分段示例：</strong></p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 段1：立即同步
[slot(sync_1)] → 立即推送

// 段2：await_2 完成后同步
[slot(await_2), slot(sync_3), slot(sync_4)] → await_2 完成后推送

// 段3：await_5 完成后同步  
[slot(await_5)] → await_5 完成后推送
</code></pre></div></div>
<p>这种避免了 await 切割导致的上下文丢失问题。</p>

<p><strong>Promise 消费方式识别</strong></p>

<p>在插槽设计中，我们只有 <code class="language-plaintext highlighter-rouge">同步插槽</code> 、<code class="language-plaintext highlighter-rouge">异步插槽</code> 和 <code class="language-plaintext highlighter-rouge">异步Promise插槽</code> 的概念。关键问题是：
如何区分 <code class="language-plaintext highlighter-rouge">Promise</code> 是通过同步的 <code class="language-plaintext highlighter-rouge">.then()</code> 消费，还是通过阻塞的 <code class="language-plaintext highlighter-rouge">await</code> 消费？</p>

<p><strong>识别方案</strong></p>

<p>每个执行上下文完成时，必然能够获取到所有同步操作的结果。利用这个特性来判断 <code class="language-plaintext highlighter-rouge">Promise</code> 的消费方式：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">await Promise</code> 插槽获得结果后，会记录并继续执行后续代码</li>
  <li>如果某个同步插槽在上下文结束时仍无结果，说明它依赖于 <code class="language-plaintext highlighter-rouge">Promise</code> 的 <code class="language-plaintext highlighter-rouge">await</code> 结果（处于 <code class="language-plaintext highlighter-rouge">await</code> 下方）</li>
  <li>将这些未完成的同步插槽与对应的 <code class="language-plaintext highlighter-rouge">Promise</code> 插槽归为一组</li>
</ul>

<p><strong>分段推送逻辑</strong>
当遇到下一个 <code class="language-plaintext highlighter-rouge">Promise</code> 插槽时：</p>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">.then()</code> 场景</strong>：忽略，继续收集后续插槽直到上下文结束。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">await</code> 场景</strong>：识别为当前上下文的最后一个 <code class="language-plaintext highlighter-rouge">Promise</code> 插槽，立即同步当前批次的所有记录</li>
</ul>

<p><strong>副作用绑定理念</strong>
其实插槽绑定理念与经常使用的 <code class="language-plaintext highlighter-rouge">React Hooks</code> 底层绑定非常相似</p>
<ul>
  <li>纯函数不能绑定副作用，<code class="language-plaintext highlighter-rouge">hooks</code> 链挂载组件 <code class="language-plaintext highlighter-rouge">fiber</code> 单元上</li>
  <li>函数组件初次渲染，构建 <code class="language-plaintext highlighter-rouge">hooks</code> 副作用记录 （类似多窗口发送方， 记录副作用）</li>
  <li>函数组件后续渲染，查询 <code class="language-plaintext highlighter-rouge">hooks</code> 副作用记录   (类似多窗口被同步方， 从记录恢复副作用)</li>
</ul>

<p>Demo 版本：https://github.com/ScriptOverture/EffectSync</p>

<p><del>副作用保障上方案：</del>
<del>1. 因为该方案，一个事件执行会有多段同步，首次执行几乎不会因窗口刷新阻断（函数调用非常非常快）
   a. 存在 cpu 密集型阻塞操作另外优化</del>
<del>2. 如果首次同步后，异步计算中窗口关闭了，某一个leader窗口获取主动权，更新剩下异步上下文标识（需要调用/被同步），使其调用记录副作用并推动其他窗口
   因为每个窗口都是独立的FN, 这个特性导致任何窗口任意时间段都可以被选中为主窗口，甚至可以模糊掉传统leader窗口的概念，也可以是当前窗口执行其他窗口记录。</del></p>

<h4 id="内存管理与清理">内存管理与清理</h4>

<p><strong>问题分析</strong></p>

<p>当前方案存在以下内存管理问题：</p>
<ul>
  <li>单次执行假设：方案设计基于不同事件只执行一次的假设</li>
  <li>持久化积累：副作用记录在收集后持续持久化，缺乏释放机制</li>
  <li>存储边界模糊：同一事件多次执行、不同事件调用之间没有明确的副作用存储划分</li>
</ul>

<p>基于上述问题，采用按执行实例分组的存储结构：</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
   contextId: {
   effects: [
      [事件1插槽...],  // 第1次执行的插槽记录
      [事件2插槽...]   // 第2次执行的插槽记录
   ],
   status: 'pending|completed|failed',
   timestamp: Date.now(),
   hasAsync: boolean
   }
}
</code></pre></div></div>
<p>当用户点击2次相同事件时，会创建类似上述结构，每次执行独立记录，便于精确管理和清理。</p>

<h5 id="清理策略">清理策略</h5>
<p><strong>基础清理规则</strong></p>

<ul>
  <li><strong>同步事件</strong>：执行完毕立即销毁上下文和相关记录</li>
  <li><strong>异步事件</strong>：根据异步操作完成情况进行分段销毁，或等待所有异步操作成功后统一销毁</li>
</ul>

<h5 id="异常情况处理">异常情况处理</h5>
<p>考虑到可能存在永不回调的异步操作，在开发阶段需要设置最大生命周期监控：</p>
<ul>
  <li>若副作用记录超过最大周期仍未完成，触发异常监控告警</li>
  <li>强制销毁超时的上下文，防止内存泄漏</li>
</ul>

<h4 id="容错与恢复机制个别极端">容错与恢复机制（个别极端）</h4>
<p><strong>同步失败的自我纠正</strong></p>

<p>在多窗口同步场景中，可能出现极端情况：
<code class="language-plaintext highlighter-rouge">TabA</code> 发送通讯到其他窗口，个别窗口因线程阻塞等极端情况导致同步通知丢失，需要感知异常并主动向最新版本的 <code class="language-plaintext highlighter-rouge">Leader</code> 窗口发送恢复请求。</p>

<p><strong>延迟销毁策略</strong></p>

<p>为支持容错恢复，副作用插槽的销毁需要采用延迟销毁或缓存恢复机制：</p>
<ul>
  <li>延迟销毁：在正常清理时间基础上延长一定周期，为异常恢复预留时间窗口</li>
  <li>缓存恢复：将关键副作用记录转移到持久化缓存中，支持异常情况下的状态恢复</li>
</ul>

<h4 id="闭包引用分析">闭包引用分析</h4>
<p>需要同步的副作用都会被劫持一次，每个劫持函数本质上都是一个上下文闭包</p>
<ul>
  <li><strong>同步场景</strong>：执行完毕后闭包释放，引用自动断开</li>
  <li><strong>异步场景</strong>：闭包持续存在，但所有闭包引用同一个全局实例，内存开销可控</li>
  <li><strong>优化效果</strong>：全局实例共享机制有效减少了内存占用</li>
</ul>

<h4 id="逃生舱">逃生舱</h4>
<p>方案无法全方面兜底覆盖所有场景，并非银弹</p>
<ul>
  <li><strong>第三方库副作用</strong>：不可预知、封装黑盒（如 <code class="language-plaintext highlighter-rouge">Antd</code> 动画、<code class="language-plaintext highlighter-rouge">lodash</code> <code class="language-plaintext highlighter-rouge">random</code>），只能人工接管。</li>
  <li><strong>ref+原生事件</strong>：如 <code class="language-plaintext highlighter-rouge">DOM</code> 原生事件、直接操作 <code class="language-plaintext highlighter-rouge">ref</code>，无法劫持事件与副作用。</li>
  <li><strong>动画</strong>：浏览器/库实现，帧同步、异步、物理引擎，副作用不可控。</li>
  <li><strong>密集型阻塞操作</strong>：长耗时同步、<code class="language-plaintext highlighter-rouge">Web Worker</code>，大概率超出 <code class="language-plaintext highlighter-rouge">DOM/J</code>S 上下文跟踪能力。</li>
  <li><strong>框架层调度渲染</strong>：调度系统（如 <code class="language-plaintext highlighter-rouge">React、Vue</code> 的调度模式、批处理）和组件更新优先级，触发结果和真实用户操作链路未必一一对应。</li>
</ul>

<p>针对上述情况，仍然可以降级为手动同步。插件也支持不同阶段扩展同步参数。
同时<strong>插件机制 + 操作记录</strong>会相对方便链路回放跟踪问题。</p>

<h5 id="举例案例分析--框架层调度渲染">举例案例分析 —— 框架层调度渲染</h5>
<p>以 React 为例，考虑如下代码：</p>
<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Card</span><span class="p">()</span> <span class="p">{</span>
   <span class="kd">const</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="nx">update</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
   <span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">getUuid</span><span class="p">()</span><span class="c1">// &lt;===不确定副作用</span>
   <span class="p">},</span> <span class="p">[</span><span class="nx">x</span><span class="p">])</span>
   <span class="k">return</span> <span class="p">&lt;</span><span class="nt">div</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">update</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span><span class="si">}</span><span class="p">&gt;</span>click<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="p">}</span>
</code></pre></div></div>
<ul>
  <li>点击触发 <code class="language-plaintext highlighter-rouge">setTimeout</code>，延迟更新 <code class="language-plaintext highlighter-rouge">x</code>。</li>
  <li>在 <code class="language-plaintext highlighter-rouge">React</code> 的事件优先级调度、批处理; 状态更新可能被合并、延后。</li>
  <li>如果此时另一个高优先级任务先占用调度队列，导致 <code class="language-plaintext highlighter-rouge">Card</code> 的 <code class="language-plaintext highlighter-rouge">x</code> 更新触发变成“和其他任务合并”。</li>
</ul>

<p>以上无法感知组件 <code class="language-plaintext highlighter-rouge">Card</code> 更新是 <code class="language-plaintext highlighter-rouge">click+setTimeout</code> 造成的，还是其他 <code class="language-plaintext highlighter-rouge">React</code> 内部机制合并的。
<strong>结论</strong>：副作用方案最多能以“组件为单位”追踪和同步，无法做到“事件精确归因”。</p>

<p>框架想兼容，与事件链路不同只能是以组件维度为最小副作用跟踪单元
以 <code class="language-plaintext highlighter-rouge">React 18</code> 的 <code class="language-plaintext highlighter-rouge">useId</code> 为例：它可以保证所有窗口下，组件节点的上下文 <code class="language-plaintext highlighter-rouge">ID</code> 一致，多窗口同步副作用时，只需根据组件 <code class="language-plaintext highlighter-rouge">ID</code> 归位，即使不是同一次事件触发也能达成一致。</p>

<p><strong>副作用同步的“粒度边界”</strong></p>

<p>只要保证组件 <code class="language-plaintext highlighter-rouge">contextId/上下文一致</code>，多窗口副作用同步就可归一到“组件级自动同步”，不关心事件链。</p>

<h4 id="存储">存储</h4>
<ul>
  <li>时效性非常高的项目，考虑 <code class="language-plaintext highlighter-rouge">opfs + wasm</code></li>
  <li>常规项目 <code class="language-plaintext highlighter-rouge">localStorage + indexDB</code> 存储分层即可</li>
</ul>

<p>设想会提供自动恢复的 <code class="language-plaintext highlighter-rouge">api</code>, 类似：</p>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// const [messageList, setMessageList] = useState([])</span>
<span class="c1">// storageKey 为加密随机健</span>
<span class="kd">const</span> <span class="p">{</span> <span class="nx">useSyncState</span><span class="p">,</span> <span class="nx">storageKey</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">createSyncState</span><span class="p">();</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">messageList</span><span class="p">,</span> <span class="nx">setMessageList</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useSyncState</span><span class="p">([])</span>

<span class="c1">// 恢复前的调用，转换函数</span>
<span class="nx">syncRecover</span><span class="p">(</span><span class="nx">storageKey</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{})</span>
</code></pre></div></div>

<h4 id="窗口恢复">窗口恢复</h4>
<p>根据上述插槽设计，事件链路不强依赖固定主窗口，每个操作窗口都可以是事件发送方。
根据副作用记录的同步特性，窗口恢复分为两种场景：</p>
<ol>
  <li>事件执行完毕后窗口关闭
    <ul>
      <li><strong>同步操作</strong>：副作用记录已完整同步到其他窗口，可直接从记录中恢复</li>
      <li><strong>异步操作</strong>：当某个窗口竞选为新的 <code class="language-plaintext highlighter-rouge">Leader</code> 后，接管异步上下文的执行权，将未完成的异步插槽标识为发起方继续执行</li>
    </ul>
  </li>
  <li>事件执行过程中窗口恢复
    <ul>
      <li>非阻塞执行链发送概率非常低。</li>
      <li>一旦发生：新竞选的 <code class="language-plaintext highlighter-rouge">Leader</code> 窗口将重新执行完整的事件链路</li>
    </ul>
  </li>
</ol>

<p><del>操作链路会有类似事务的操作， 如问答系统：
对于多问一答多问多答，整个一个多问轮次可以被统计为一通操作（事务）恢复时会重新执行这一通操作</del></p>

<h4 id="隐式收益测试生态的构建">隐式收益：测试生态的构建</h4>
<p>上述方案，本身会收集用户操作指令，基于改特性。本地环境，当开发者实现某个功能时，会自动捕获该功能链路中的所有用户交互指令。</p>

<p>指令收集：</p>
<ol>
  <li>通过智能降噪和语义提取，可以相对精确获得与特定功能相关的完整指令序列</li>
  <li>类似reactquery 界面工具，手动记录操作开始-&gt;结束</li>
</ol>

<p>指令包括：</p>
<ul>
  <li>用户交互操作（点击、输入、滚动等）</li>
  <li>API请求调用及响应</li>
  <li>页面状态变化</li>
  <li>路由跳转记录</li>
</ul>

<h5 id="e2e自动化测试">E2E自动化测试</h5>
<p>将用户指令集直接转换为端到端测试代码（如 <code class="language-plaintext highlighter-rouge">Playwright、Cypress</code> 等）</p>

<p><strong>基础流程生成</strong>
将收集的指令序列直接转换为测试代码（流程）</p>

<p><strong>断言生成策略</strong>
每个指令对应一个事件链路，通过分析插槽记录生成关键断言（请求），按顺序将该断言插入到对应用例流程代码块中</p>

<h5 id="mcp智能测试平台">MCP智能测试平台</h5>
<p>将指令集转换为 <code class="language-plaintext highlighter-rouge">MCP（Model Context Protocol</code> 所需的标准化输入格式，让AI助手能够：</p>
<ul>
  <li>理解完整的业务操作流程</li>
  <li>自动执行功能验证测试【结合现有测试用例(前端e2e, 测试自动化测用例)的智能推断验证】</li>
  <li>提供智能化的测试建议和优化方案</li>
</ul>]]></content><author><name>scriptoverture</name></author><category term="WebDevelopment" /><category term="JavaScript" /><summary type="html"><![CDATA[一篇关于前端架构的深度文章，介绍了如何通过“副作用归一化”思想解决浏览器多窗口状态同步的技术挑战。内容包括上下文一致性保障、异步插槽设计、分段推送策略以及该方案衍生的测试生态价值。]]></summary></entry><entry><title type="html">如何高效比较类型结构？从 TS 的类型系统到结构 Trie 优化</title><link href="https://scriptoverture.github.io/blog/2025/06/16/%E6%80%9D%E8%80%83%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83-%E4%BB%8E-TypeScript-%E5%88%B0%E7%BB%93%E6%9E%84-Trie-%E7%9A%84%E4%BC%98%E5%8C%96%E8%B7%AF%E5%BE%84/" rel="alternate" type="text/html" title="如何高效比较类型结构？从 TS 的类型系统到结构 Trie 优化" /><published>2025-06-16T00:00:00+00:00</published><updated>2025-06-16T00:00:00+00:00</updated><id>https://scriptoverture.github.io/blog/2025/06/16/%E6%80%9D%E8%80%83%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83%EF%BC%9A%E4%BB%8E%20TypeScript%20%E5%88%B0%E7%BB%93%E6%9E%84%20Trie%20%E7%9A%84%E4%BC%98%E5%8C%96%E8%B7%AF%E5%BE%84</id><content type="html" xml:base="https://scriptoverture.github.io/blog/2025/06/16/%E6%80%9D%E8%80%83%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83-%E4%BB%8E-TypeScript-%E5%88%B0%E7%BB%93%E6%9E%84-Trie-%E7%9A%84%E4%BC%98%E5%8C%96%E8%B7%AF%E5%BE%84/"><![CDATA[<h1 id="如何高效比较类型结构从-ts-的类型系统到结构-trie-优化">如何高效比较类型结构？从 TS 的类型系统到结构 Trie 优化</h1>

<p>先问大家一个问题，给定俩个对象该怎么“快速”比较其是否等价？<br />
转字符串比较吗？如果参数顺序不一致呢
遍历吗？可以
但如果嵌套层级过深呢? 好似俩颗树结构比较
深度优先遍历？可以？
如果项目中仅仅是一处比较，暂时这么写当然没有问题，倘若存在很多很多很多组对象呢，届时就达不到快速的基准了。</p>

<p>可能会纳闷，为什么要问这个问题，这个跟主题 <code class="language-plaintext highlighter-rouge">ts</code> 类型有什么关联<br />
举个很常见的示例，函数不同情况返回不同参数，猜猜他的返回类型会是什么</p>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">demo</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">xxx</span><span class="dl">'</span><span class="p">,</span>
            <span class="na">age</span><span class="p">:</span> <span class="mi">1</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="na">age</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">wwww</span><span class="dl">"</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">DemoReturn</span> <span class="o">=</span> <span class="nx">ReturnType</span><span class="o">&lt;</span><span class="k">typeof</span> <span class="nx">demo</span><span class="o">&gt;</span>
<span class="c1">// 输入：</span>
<span class="c1">// 1 | {</span>
<span class="c1">//     name: string;</span>
<span class="c1">//     age: number;</span>
<span class="c1">// }</span>
</code></pre></div></div>
<p>通过获取函数返回类型，观察其结果类型，你会惊讶的发现，其结果并不是如下所示</p>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">DemoReturn</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> 
    <span class="na">age</span><span class="p">:</span> <span class="kr">number</span>
<span class="p">}</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">|</span> <span class="p">{</span>
    <span class="na">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span>
    <span class="na">name</span><span class="p">:</span> <span class="kr">string</span>
<span class="p">}</span>
</code></pre></div></div>
<p>这正是因为 <code class="language-plaintext highlighter-rouge">ts</code> 内部联合类型进行了比较并删除了相同类型</p>

<blockquote>
  <p>todo:</p>
  <ul>
    <li>显示联合类型不会自动展开计算结果譬如 <code class="language-plaintext highlighter-rouge">TypeA | TypeB</code></li>
    <li>而隐式联合类型会进行联合运算，譬如函数返回类型</li>
  </ul>
</blockquote>

<p>那么回归开头的问题，既然 <code class="language-plaintext highlighter-rouge">ts</code> 内部也有对象类型比较，
他是否解决了上面抛出了一系列问题，又是否用到了什么黑魔法，
一起来揭开他神秘的面纱</p>

<h3 id="ts-类型比较的现状">Ts 类型比较的现状</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">ts</code> 会为所有基础类型维护全局 <code class="language-plaintext highlighter-rouge">map</code> 存储，相同字面量指向同一<code class="language-plaintext highlighter-rouge">Type</code> 引用</li>
  <li><code class="language-plaintext highlighter-rouge">ts</code> 会遍历联合类型节点，为其互相比较</li>
  <li>如果是对象类型比较，还需要额外遍历对象判断类型兼容
    <ul>
      <li>如果遍历对象的某项类型也是对象，还需要额外深度遍历</li>
    </ul>
  </li>
  <li>然后为联合类型缓存比较结果 id</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">removeSubtypes</span><span class="p">(</span><span class="nx">types</span><span class="p">:</span> <span class="nx">Type</span><span class="p">[],</span> <span class="nx">hasObjectTypes</span><span class="p">:</span> <span class="nx">boolean</span><span class="p">):</span> <span class="nx">Type</span><span class="p">[]</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>
        <span class="c1">// [] and [T] immediately reduce to [] and [T] respectively</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">types</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">types</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kd">const</span> <span class="nx">id</span> <span class="o">=</span> <span class="nx">getTypeListId</span><span class="p">(</span><span class="nx">types</span><span class="p">);</span>
        <span class="kd">const</span> <span class="nx">match</span> <span class="o">=</span> <span class="nx">subtypeReductionCache</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">id</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">match</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">match</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kd">const</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">types</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
        <span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">len</span><span class="p">;</span>
        <span class="kd">let</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">i</span><span class="o">--</span><span class="p">;</span>
            <span class="kd">const</span> <span class="nx">source</span> <span class="o">=</span> <span class="nx">types</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">hasEmptyObject</span> <span class="o">||</span> <span class="nx">source</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">TypeFlags</span><span class="p">.</span><span class="nx">StructuredOrInstantiable</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">target</span> <span class="k">of</span> <span class="nx">types</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="nx">source</span> <span class="o">!==</span> <span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
                        <span class="c1">// 判断类型是否相同兼容</span>
                        <span class="k">if</span> <span class="p">(</span>
                            <span class="nx">isTypeRelatedTo</span><span class="p">(</span><span class="nx">source</span><span class="p">,</span> <span class="nx">target</span><span class="p">,</span> <span class="nx">strictSubtypeRelation</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span>
                                <span class="o">!</span><span class="p">(</span><span class="nx">getObjectFlags</span><span class="p">(</span><span class="nx">getTargetType</span><span class="p">(</span><span class="nx">source</span><span class="p">))</span> <span class="o">&amp;</span> <span class="nx">ObjectFlags</span><span class="p">.</span><span class="nx">Class</span><span class="p">)</span> <span class="o">||</span>
                                <span class="o">!</span><span class="p">(</span><span class="nx">getObjectFlags</span><span class="p">(</span><span class="nx">getTargetType</span><span class="p">(</span><span class="nx">target</span><span class="p">))</span> <span class="o">&amp;</span> <span class="nx">ObjectFlags</span><span class="p">.</span><span class="nx">Class</span><span class="p">)</span> <span class="o">||</span>
                                <span class="nx">isTypeDerivedFrom</span><span class="p">(</span><span class="nx">source</span><span class="p">,</span> <span class="nx">target</span><span class="p">)</span>
                            <span class="p">)</span>
                        <span class="p">)</span> <span class="p">{</span>
                            <span class="nx">orderedRemoveItemAt</span><span class="p">(</span><span class="nx">types</span><span class="p">,</span> <span class="nx">i</span><span class="p">);</span>
                            <span class="k">break</span><span class="p">;</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nx">subtypeReductionCache</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">types</span><span class="p">);</span>
        <span class="k">return</span> <span class="nx">types</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">removeSubtypes</code> 会俩俩比较类型，相同类型结构会被删除</p>
<blockquote>
  <p>假如存在多个联合类型，类型比较会存在指数级复杂度</p>

  <p>而 <code class="language-plaintext highlighter-rouge">isTypeRelatedTo</code> 内部调用链 <code class="language-plaintext highlighter-rouge">-&gt; checkTypeRelatedTo -&gt; isRelatedTo</code></p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">isRelatedTo</code> 是 <code class="language-plaintext highlighter-rouge">TypeScript</code> 类型系统的核心函数，用于判断两个类型之间的关系</p>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Compare two types and return
 * * Ternary.True if they are related with no assumptions,
 * * Ternary.Maybe if they are related with assumptions of other relationships, or
 * * Ternary.False if they are not related.
 */</span>
<span class="kd">function</span> <span class="nx">isRelatedTo</span><span class="p">(</span><span class="nx">originalSource</span><span class="p">:</span> <span class="nx">Type</span><span class="p">,</span> <span class="nx">originalTarget</span><span class="p">:</span> <span class="nx">Type</span><span class="p">,</span> <span class="nx">recursionFlags</span><span class="p">:</span> <span class="nx">RecursionFlags</span> <span class="o">=</span> <span class="nx">RecursionFlags</span><span class="p">.</span><span class="nx">Both</span><span class="p">,</span> <span class="nx">reportErrors</span> <span class="o">=</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">headMessage</span><span class="p">?:</span> <span class="nx">DiagnosticMessage</span><span class="p">,</span> <span class="nx">intersectionState</span> <span class="o">=</span> <span class="nx">IntersectionState</span><span class="p">.</span><span class="nx">None</span><span class="p">):</span> <span class="nx">Ternary</span> <span class="p">{</span>
  <span class="c1">// 同一类型引用</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">originalSource</span> <span class="o">===</span> <span class="nx">originalTarget</span><span class="p">)</span> <span class="k">return</span> <span class="nx">Ternary</span><span class="p">.</span><span class="nx">True</span><span class="p">;</span>
  <span class="c1">// origin 对象类型， target 为基础类型</span>
  <span class="c1">// 源类型是对象类型（如 { x: number } 或 Date）</span>
  <span class="c1">// 目标类型是原始类型（如 string, number, boolean）</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">originalSource</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">TypeFlags</span><span class="p">.</span><span class="nb">Object</span> <span class="o">&amp;&amp;</span> <span class="nx">originalTarget</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">TypeFlags</span><span class="p">.</span><span class="nx">Primitive</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">Ternary</span><span class="p">.</span><span class="nx">False</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// target 和 source 都是结构对象</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">source</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">TypeFlags</span><span class="p">.</span><span class="nx">StructuredOrInstantiable</span> <span class="o">||</span> <span class="nx">target</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">TypeFlags</span><span class="p">.</span><span class="nx">StructuredOrInstantiable</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">isPerformingExcessPropertyChecks</span> <span class="o">=</span> <span class="o">!</span><span class="p">(</span><span class="nx">intersectionState</span> <span class="o">&amp;</span> <span class="nx">IntersectionState</span><span class="p">.</span><span class="nx">Target</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">isObjectLiteralType</span><span class="p">(</span><span class="nx">source</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">getObjectFlags</span><span class="p">(</span><span class="nx">source</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nx">ObjectFlags</span><span class="p">.</span><span class="nx">FreshLiteral</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">isPerformingExcessPropertyChecks</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 判断 target 上是否有 source 的多余属性</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">hasExcessProperties</span><span class="p">(</span><span class="nx">source</span> <span class="k">as</span> <span class="nx">FreshObjectLiteralType</span><span class="p">,</span> <span class="nx">target</span><span class="p">,</span> <span class="nx">reportErrors</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">Ternary</span><span class="p">.</span><span class="nx">False</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 是否有公共属性</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">isPerformingCommonPropertyChecks</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">hasCommonProperties</span><span class="p">(</span><span class="nx">source</span><span class="p">,</span> <span class="nx">target</span><span class="p">,</span> <span class="nx">isComparingJsxAttributes</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">Ternary</span><span class="p">.</span><span class="nx">False</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">const</span> <span class="nx">skipCaching</span> <span class="o">=</span> <span class="nx">source</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">TypeFlags</span><span class="p">.</span><span class="nx">Union</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">source</span> <span class="k">as</span> <span class="nx">UnionType</span><span class="p">).</span><span class="nx">types</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="nx">target</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">TypeFlags</span><span class="p">.</span><span class="nx">Union</span><span class="p">)</span> <span class="o">||</span>
            <span class="nx">target</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">TypeFlags</span><span class="p">.</span><span class="nx">Union</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">target</span> <span class="k">as</span> <span class="nx">UnionType</span><span class="p">).</span><span class="nx">types</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="nx">source</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">TypeFlags</span><span class="p">.</span><span class="nx">StructuredOrInstantiable</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">skipCaching</span> <span class="p">?</span>
            <span class="nx">unionOrIntersectionRelatedTo</span><span class="p">(</span><span class="nx">source</span><span class="p">,</span> <span class="nx">target</span><span class="p">,</span> <span class="nx">reportErrors</span><span class="p">,</span> <span class="nx">intersectionState</span><span class="p">)</span> <span class="p">:</span>
            <span class="nx">recursiveTypeRelatedTo</span><span class="p">(</span><span class="nx">source</span><span class="p">,</span> <span class="nx">target</span><span class="p">,</span> <span class="nx">reportErrors</span><span class="p">,</span> <span class="nx">intersectionState</span><span class="p">,</span> <span class="nx">recursionFlags</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">Ternary</span><span class="p">.</span><span class="nx">False</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">recursiveTypeRelatedTo</code> 内部调用链
<code class="language-plaintext highlighter-rouge">-&gt; structuredTypeRelatedTo -&gt; structuredTypeRelatedToWorker -&gt; propertiesRelatedTo</code>
关键代码如下：</p>
<blockquote>
  <p>这段代码是 <code class="language-plaintext highlighter-rouge">TypeScript</code> 类型系统中对象类型属性比较的核心部分，主要处理两个对象类型之间属性级别的兼容性检查：</p>
  <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 遍历源类型的所有属性</span>
<span class="c1">// 检查源属性是否存在于目标类型中</span>
 <span class="k">if</span> <span class="p">(</span><span class="nx">isObjectLiteralType</span><span class="p">(</span><span class="nx">target</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">sourceProp</span> <span class="k">of</span> <span class="nx">excludeProperties</span><span class="p">(</span><span class="nx">getPropertiesOfType</span><span class="p">(</span><span class="nx">source</span><span class="p">),</span> <span class="nx">excludedProperties</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">getPropertyOfObjectType</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">sourceProp</span><span class="p">.</span><span class="nx">escapedName</span><span class="p">))</span> <span class="p">{</span>
                <span class="kd">const</span> <span class="nx">sourceType</span> <span class="o">=</span> <span class="nx">getTypeOfSymbol</span><span class="p">(</span><span class="nx">sourceProp</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="nx">sourceType</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">TypeFlags</span><span class="p">.</span><span class="nx">Undefined</span><span class="p">))</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="nx">Ternary</span><span class="p">.</span><span class="nx">False</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 类型比较兼容检查</span>
    <span class="kd">const</span> <span class="nx">properties</span> <span class="o">=</span> <span class="nx">getPropertiesOfType</span><span class="p">(</span><span class="nx">target</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">numericNamesOnly</span> <span class="o">=</span> <span class="nx">isTupleType</span><span class="p">(</span><span class="nx">source</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">isTupleType</span><span class="p">(</span><span class="nx">target</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">targetProp</span> <span class="k">of</span> <span class="nx">excludeProperties</span><span class="p">(</span><span class="nx">properties</span><span class="p">,</span> <span class="nx">excludedProperties</span><span class="p">))</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">targetProp</span><span class="p">.</span><span class="nx">escapedName</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="nx">targetProp</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">SymbolFlags</span><span class="p">.</span><span class="nx">Prototype</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="nx">numericNamesOnly</span> <span class="o">||</span> <span class="nx">isNumericLiteralName</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="o">||</span> <span class="nx">name</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">length</span><span class="dl">"</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="nx">optionalsOnly</span> <span class="o">||</span> <span class="nx">targetProp</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">SymbolFlags</span><span class="p">.</span><span class="nx">Optional</span><span class="p">))</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">sourceProp</span> <span class="o">=</span> <span class="nx">getPropertyOfType</span><span class="p">(</span><span class="nx">source</span><span class="p">,</span> <span class="nx">name</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">sourceProp</span> <span class="o">&amp;&amp;</span> <span class="nx">sourceProp</span> <span class="o">!==</span> <span class="nx">targetProp</span><span class="p">)</span> <span class="p">{</span>
                <span class="kd">const</span> <span class="nx">related</span> <span class="o">=</span> <span class="nx">propertyRelatedTo</span><span class="p">(</span><span class="nx">source</span><span class="p">,</span> <span class="nx">target</span><span class="p">,</span> <span class="nx">sourceProp</span><span class="p">,</span> <span class="nx">targetProp</span><span class="p">,</span> <span class="nx">getNonMissingTypeOfSymbol</span><span class="p">,</span> <span class="nx">reportErrors</span><span class="p">,</span> <span class="nx">intersectionState</span><span class="p">,</span> <span class="nx">relation</span> <span class="o">===</span> <span class="nx">comparableRelation</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">related</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="nx">Ternary</span><span class="p">.</span><span class="nx">False</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="nx">result</span> <span class="o">&amp;=</span> <span class="nx">related</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>  </div>
  <p>而 <code class="language-plaintext highlighter-rouge">propertyRelatedTo</code> 内部会调用 <code class="language-plaintext highlighter-rouge">isRelatedTo</code>， 形成深度有限遍历</p>
</blockquote>

<p>有些敏锐的小伙伴可能发现了 <code class="language-plaintext highlighter-rouge">ts</code> 这一套比较逻辑的痛点</p>
<ul>
  <li>深度遍历比较，等同遍历整棵树，时间复杂度 O(n²)，尤其在嵌套复杂结构中开销巨大</li>
  <li>斌且没有复用的概念，相似结构仍需重复比较
    <ul>
      <li>无法利用已处理结构进行快速匹配与缓存。
比如下面示例
        <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">O_1</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="na">age</span><span class="p">:</span> <span class="kr">number</span> <span class="p">}</span>
<span class="kd">type</span> <span class="nx">O_2</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="na">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="na">other</span><span class="p">:</span> <span class="kr">any</span> <span class="p">}</span>
</code></pre></div>        </div>
        <p>当 <code class="language-plaintext highlighter-rouge">O_1</code> 解析完成，<code class="language-plaintext highlighter-rouge">O_2</code> 无法复用 <code class="language-plaintext highlighter-rouge">O_1</code> 的结果，重新解析无效开销</p>
      </li>
    </ul>
  </li>
</ul>

<p>最初设想是：位标识快速比较<br />
我希望每个对象类型有一个唯一标识，通过判断标识可以快速比较类型</p>
<ul>
  <li>将对象每个参数拼接 typeKind, 通过hash函数生成一组二进制</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>结构中所有属性hash_id聚会成一个标识位（ flag</td>
          <td>= hash_id）</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>那么当存在联合类型比较，一方遍历对象参数生成 flag 中
    <ul>
      <li>flag_1 &amp; hash_id 就能感知，当前参数是否被比较类型包含</li>
    </ul>
  </li>
</ul>

<p>然鹅问题</p>
<ul>
  <li>位编码只能包含有限参数信息，字段过多易冲突</li>
  <li>哈希映射不可逆，不支持嵌套结构</li>
  <li>无法表达子结构复用与结构相似性</li>
</ul>

<h3 id="我的方案结构字段映射--前缀-trie">我的方案：结构字段映射 + 前缀 Trie</h3>
<p>为了解决上面的问题，我最终采取一种基于前置树的比较机制。通过将对象类型结构抽象，使得对象类型的比较从递归演变为路径匹配，以实现复用以及更好的性能</p>

<p>关键步骤：</p>
<ul>
  <li>字段唯一 ID 映射（<code class="language-plaintext highlighter-rouge">fieldMap</code>）
    <ul>
      <li>所有字段名在全局映射为递增 fieldId：如 name → 1, age → 2，避免了字符串比较</li>
      <li>该映射确保结构中字段排序稳定，利于结构规范化</li>
    </ul>
  </li>
  <li>结构字段规范化 + 排序
    <ul>
      <li>对象结构按 fieldId 排序，形成结构[fieldId, typeKind]签名</li>
      <li>排序后的结构作为 Trie 的路径，用于复用判断</li>
    </ul>
  </li>
  <li>结构 Trie 构建与比较
    <ul>
      <li>每条结构路径构成 Trie 的一条分支，末端节点打上唯一结构标识 flagId</li>
      <li>同结构对象拥有相同 flagId，快速判断是否等价</li>
    </ul>
  </li>
</ul>

<p>展开来说：<br />
示例一：字段顺序不同的相同结构</p>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">O1</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="na">age</span><span class="p">:</span> <span class="kr">number</span> <span class="p">}</span>
<span class="kd">type</span> <span class="nx">O2</span> <span class="o">=</span> <span class="p">{</span> <span class="na">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="na">name</span><span class="p">:</span> <span class="kr">string</span> <span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>初次解析 O1，构建 fieldMap：
    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">fieldMap</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">age</span><span class="p">:</span> <span class="mi">2</span> <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>排序组装结构签名
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[name{ fieldId_1, type_kind }, age{ fieldId_2, type_kind }]
</code></pre></div>    </div>
  </li>
  <li>构建 Trie：
```less
root
└── name:string (1)
 └── age:number (2) → flagId = 2</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>4. 解析 O2 时：  
字段排序后仍为 `[name{ fieldId_1, type_kind }, age{ fieldId_2, type_kind }]`，Trie 路径匹配成功，得到相同 flagId = 2
结构等价

示例二：结构嵌套的复用复识别
```typescript
type O      = { name: string }
type O1     = { name: string, obj: { name: string } }
type O2     = { obj: O, name: string }
type O3     = { age: number, obj: O, name: string }
</code></pre></div></div>
<p>字段映射fieldMap：</p>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">fieldMap</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">obj</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="na">age</span><span class="p">:</span> <span class="mi">3</span> <span class="p">}</span>
</code></pre></div></div>
<p>结构构建与复用如下：</p>

<table>
  <thead>
    <tr>
      <th>类型</th>
      <th>结构签名（fieldId 排序）</th>
      <th>子结构复用</th>
      <th>对应 flagId</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>O</td>
      <td><code class="language-plaintext highlighter-rouge">[name{ fieldId_1, type_kind }]</code></td>
      <td>无</td>
      <td>1</td>
    </tr>
    <tr>
      <td>O1</td>
      <td><code class="language-plaintext highlighter-rouge">[name{ fieldId_1, type_kind }, obj { fieldId_2, obj_flagId }]</code></td>
      <td>obj 复用</td>
      <td>2</td>
    </tr>
    <tr>
      <td>O2</td>
      <td><code class="language-plaintext highlighter-rouge">[name{ fieldId_1, type_kind }, obj { fieldId_2, obj_flagId }]</code></td>
      <td>obj 复用</td>
      <td>2</td>
    </tr>
    <tr>
      <td>O3</td>
      <td><code class="language-plaintext highlighter-rouge">[name{ fieldId_1, type_kind }, obj { fieldId_2, obj_flagId }, age { fieldId_3, type_kind }]</code></td>
      <td>obj 复用</td>
      <td>3</td>
    </tr>
  </tbody>
</table>

<p>最终 Trie 树形如下：</p>
<pre><code class="language-less">root
└── name:string (1)
    └── obj:{flag=1} (2)
        └── age:number (3) → flagId = 3
</code></pre>

<p>其中类型标识是在解析到字面量对象词法分析的阶段生成，因此后续不会有额外遍历开销</p>

<p>这样联合类型判断就可以转换为</p>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Demo</span> <span class="o">=</span> <span class="nx">O1</span> <span class="o">|</span> <span class="nx">O2</span> <span class="o">|</span> <span class="nx">O3</span><span class="p">;</span>
<span class="c1">//  [flag_2, flag_2, flag_3]</span>
<span class="c1">// 简单去重就能就能得到结果 -&gt; O1 | O3</span>
</code></pre></div></div>

<p>交叉类型判断</p>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Test</span> <span class="o">=</span> <span class="nx">O3</span> <span class="o">&amp;</span> <span class="nx">O2</span> <span class="o">&amp;</span> <span class="nx">O1</span><span class="p">;</span>
</code></pre></div></div>
<p>其实有了前置树后的设计也会好操作很多</p>
<ol>
  <li>对于字面量对象结构，交叉类型判断可简化为路径包含关系判断。</li>
  <li>对于复杂类型（泛型，条件类型等），可在类型调用归一化后，匹配前置树，再进行比较。</li>
</ol>

<p>具体步骤：</p>
<ul>
  <li>根据 flagId 去重</li>
  <li>根据 flagId 排序，从大到小， 反向查找路径；</li>
  <li>路径回收，若查询到共享子路径（匹配flagId），表示为结构包含关系
抽象来说就是类型对应路径的覆盖集合</li>
</ul>

<hr />
<p>优势对比：</p>

<table>
  <thead>
    <tr>
      <th>传统递归结构比较（如 TS 实现）</th>
      <th>Trie 结构对比方案</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>深度递归比较，开销高</td>
      <td>路径匹配，时间复杂度近似 <code class="language-plaintext highlighter-rouge">O(n)</code></td>
    </tr>
    <tr>
      <td>无结构复用</td>
      <td>子结构按路径自动复用</td>
    </tr>
    <tr>
      <td>对象等价需逐字段判断</td>
      <td>结构拥有唯一 <code class="language-plaintext highlighter-rouge">flagId</code>，直接对比</td>
    </tr>
    <tr>
      <td>无嵌套优化能力</td>
      <td>嵌套结构自动哈希压缩</td>
    </tr>
    <tr>
      <td>不适合动态结构缓存</td>
      <td>支持缓存、去重、路径剪枝</td>
    </tr>
  </tbody>
</table>

<h3 id="隐藏类">隐藏类</h3>
<p>因为前置树方案与 <code class="language-plaintext highlighter-rouge">V8</code> 引擎中（<code class="language-plaintext highlighter-rouge">Hidden Class</code>）隐藏类机制高度相似，也顺手提上一嘴吧</p>

<p>总所周知哈，<code class="language-plaintext highlighter-rouge">javascript</code> 是动态类型语言因此非常的灵活，与静态类型语言不同，<code class="language-plaintext highlighter-rouge">js</code> 对象可以动态修改比如下面 <code class="language-plaintext highlighter-rouge">age</code> 属性，
这使得无法确认其静态结构，与其相关的内存布局。</p>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">mingrui</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">address</span><span class="p">:</span> <span class="dl">'</span><span class="s1">xxxx</span><span class="dl">'</span>
<span class="p">}</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">25</span><span class="dl">"</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">record</span><span class="p">:</span> <span class="p">{}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>为了更方便理解，想象一下自己经营「物品托管所」，而你作为店铺老板，为了方便管理物品，自然的会准备本小本子
记录有哪些物品以及对应存放位置。<br />
最初的 <code class="language-plaintext highlighter-rouge">obj</code> 看起来是这样的：</p>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">mingrui</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">address</span><span class="p">:</span> <span class="dl">'</span><span class="s1">xxxx</span><span class="dl">'</span>
<span class="p">}</span>
</code></pre></div></div>
<p>此时它的「存储表（store_table）」为</p>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">store_table</span> <span class="p">{</span>
    <span class="nl">name</span><span class="p">:</span> <span class="nx">ptr</span><span class="p">(</span><span class="dl">'</span><span class="s1">存储位置</span><span class="dl">'</span><span class="p">)</span>
    <span class="nx">age</span><span class="p">:</span> <span class="nx">ptr</span><span class="p">(</span><span class="dl">'</span><span class="s1">存储位置</span><span class="dl">'</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>这时有人需要更新存储 age = { xx: ‘xx’ }, 对象结构发生变化，原来的“托管所”存储位置不再适用，
为了不失去这个客户，你打算忽悠身边朋友也来做物品托管，让其店铺代存，此时物品编号映射表为</p>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">store_table</span> <span class="p">{</span>
    <span class="nl">name</span><span class="p">:</span> <span class="nx">ptr</span><span class="p">(</span><span class="dl">'</span><span class="s1">存储位置</span><span class="dl">'</span><span class="p">)</span>
    <span class="nx">age</span><span class="p">:</span> <span class="nx">storeA_table</span>
<span class="p">}</span>

<span class="nx">storeA_table</span> <span class="p">{</span>
  <span class="nl">xx</span><span class="p">:</span> <span class="nx">ptr</span><span class="p">(</span><span class="dl">'</span><span class="s1">存储位置</span><span class="dl">'</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>这时如果客户需要获取存储物品 <code class="language-plaintext highlighter-rouge">age</code> 则需要多一层，联系其他店铺获取。<br />
最开始这种层级式的托管是可以接受的，但随着结构变更越来越频繁，你托管关联的「物品托管所」也越来越多，就会出现问题了：</p>
<blockquote>
  <p><strong>多层查找、多级托管，极大增加了查找开销。</strong></p>
</blockquote>

<p>通过上面你可能敏锐的发现，如果事先就知道需要存储哪些物品，物品直接关联的位置也就没有这些开销了(静态化<br />
那么怎么让动态存储趋于静态化呢？</p>

<p>隐藏类的本质：模拟静态结构
核心作用：</p>
<ul>
  <li>记录属性偏移量：为每个属性分配固定的内存偏移地址</li>
  <li>结构共享复用：相同结果共享同一个隐藏类实例，复用属性偏移地址</li>
</ul>

<p>传统hash表
假设访问 obj.age.xx, 对应流程</p>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">value</span> <span class="o">=</span> <span class="nx">hash_table</span><span class="p">[</span><span class="dl">'</span><span class="s1">age</span><span class="dl">'</span><span class="p">].</span><span class="nx">hash_table</span><span class="p">[</span><span class="dl">'</span><span class="s1">xx</span><span class="dl">'</span><span class="p">]</span>
</code></pre></div></div>
<p>因为不感知属性在 <code class="language-plaintext highlighter-rouge">hash</code> 表中的具体位置，每次获取都需要：</p>
<ul>
  <li>计算hash -&gt; 定位桶 -&gt; 处理冲突</li>
</ul>

<p>隐藏类流程</p>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{}</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">propertieA</span> <span class="o">=</span> <span class="mi">1</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">propertieB</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div></div>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">struct</span> <span class="nx">obj</span> <span class="p">{</span>
    <span class="nx">hiddenClass</span> <span class="o">-&gt;</span> <span class="nx">hiddenClass_A</span> <span class="c1">// 隐藏类指针</span>
    <span class="nx">properties</span>  <span class="o">-&gt;</span> <span class="nx">ptr</span>
<span class="p">}</span>

<span class="nx">hiddenClass_A</span> <span class="p">{</span>
  <span class="nl">propertieA</span><span class="p">:</span> <span class="nx">offect</span> <span class="mi">0</span> <span class="c1">// 偏移量</span>
<span class="p">}</span>
<span class="nx">hiddenClass_A</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">propertieB</span><span class="p">)</span>
<span class="nx">hiddenClass_B</span> <span class="p">{</span>
  <span class="nl">propertieB</span><span class="p">:</span> <span class="nx">offect</span> <span class="mi">1</span> <span class="c1">// 偏移量</span>
<span class="p">}</span>
<span class="c1">// hiddenClass_A -&gt; hiddenClass_B</span>
<span class="c1">// 更新 struct_obj hiddenClass 指针为hiddenClass_B</span>
</code></pre></div></div>
<p><img src="https://v8.dev/_img/fast-properties/adding-properties.png" alt="xx" />
那么其属性访问流程：</p>
<ul>
  <li>通过获取 obj 隐藏类指针地址以及 属性偏移位置 propertieB 为 1</li>
  <li>属性值的地址 = 对象结构指针地址 + 属性值偏移位置</li>
  <li>获取值</li>
</ul>

<p>有三种不同的命名属性类型：对象内、快速和慢速/字典。</p>

<table>
  <thead>
    <tr>
      <th>属性类型</th>
      <th>存储方式</th>
      <th>访问速度</th>
      <th>适用场景</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>对象内属性</td>
      <td>内联在对象内存块中</td>
      <td>极快（单次加法）</td>
      <td>结构稳定时</td>
    </tr>
    <tr>
      <td>快速属性</td>
      <td>属性存储区 + 隐藏类描述符</td>
      <td>快（需查找隐藏类）</td>
      <td>结构轻微变化时</td>
    </tr>
    <tr>
      <td>慢速属性</td>
      <td>独立哈希表</td>
      <td>慢（哈希计算 + 冲突处理）</td>
      <td>结构频繁变化时</td>
    </tr>
  </tbody>
</table>

<p>所以每当对象创建，申请内存上都会预留一些空间，而隐藏类事先计算改好了属性偏移量就可以消费对应内存，
当空间不够用时，就会创建hash表退化为慢速属性</p>

<p>衍生问题</p>
<ol>
  <li>预编译阶段，此法环境创建的VO对象是否有隐藏类的机制？</li>
  <li>闭包对象是否也具备隐藏类优化？
    <h4 id="动机">动机？</h4>
    <p>可能有人会好奇：“写代码写到研究类型结构比较，图啥？你卷你*呢”<br />
其实这一切都源自我在做的一个项目 —— 类型逆向推导。本质是根据字面量的结构与其具体消费值，自动还原其在 TypeScript 中的最精确类型。
（其中联合推断碰到类型比较的问题，当时还好奇ts会不会有什么黑魔法借鉴来着）</p>
  </li>
</ol>

<p>举个栗子<br />
例如下面函数，通过分析字面量以及if判断，既可以推导 props.type 是 number 和 string 的联合类型
同样的可以推导obj, 而props.obj 与obj同一引用，因此可以得到完整的props：</p>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">demo</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">{</span> <span class="kd">type</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">props</span>
    <span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nx">props</span><span class="p">.</span><span class="nx">obj</span>
    <span class="k">if</span> <span class="p">(</span><span class="kd">type</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="p">(</span><span class="kd">type</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">xx</span><span class="dl">"</span><span class="p">)</span> <span class="p">{}</span>
    <span class="nx">obj</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="nx">obj</span>
<span class="p">}</span>

<span class="c1">// 推断结果：</span>
<span class="kd">type</span> <span class="nx">Props</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">type</span><span class="p">:</span> <span class="kr">number</span> <span class="o">|</span> <span class="kr">string</span><span class="p">,</span>
    <span class="na">obj</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">a</span><span class="p">:</span> <span class="kr">number</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>亦或者是这种典型的条件返回函数，根据条件分支，反推出函数的重载类型：</p>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">demo</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="kd">type</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="kd">type</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">x</span><span class="dl">"</span><span class="p">)</span> <span class="k">return</span> <span class="dl">'</span><span class="s1">string</span><span class="dl">'</span>
    <span class="k">return</span> <span class="p">[</span><span class="dl">'</span><span class="s1">xxx</span><span class="dl">'</span><span class="p">]</span>
<span class="p">}</span>

<span class="c1">// 推断结果</span>
<span class="kd">function</span> <span class="nx">demo</span><span class="p">(</span><span class="nx">props</span><span class="p">:</span> <span class="nx">unknown</span><span class="p">):</span> <span class="kr">string</span><span class="p">[];</span>
<span class="kd">function</span> <span class="nx">demo</span><span class="p">(</span><span class="nx">props</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="kr">string</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">demo</span><span class="p">(</span><span class="nx">props</span><span class="p">:</span> <span class="nx">object</span><span class="p">):</span> <span class="kr">number</span><span class="p">;</span>

<span class="nx">demo</span><span class="p">(</span><span class="dl">"</span><span class="s2">x</span><span class="dl">"</span><span class="p">)</span> <span class="c1">// -&gt; string</span>
<span class="nx">demo</span><span class="p">({})</span>  <span class="c1">// -&gt; number</span>
<span class="nx">demo</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>   <span class="c1">// -&gt; string[]</span>
</code></pre></div></div>
<p>当然真实项目远不止这些简单的场景：</p>
<ul>
  <li>跨模块，跨多层作用域</li>
  <li>泛型，条件兼容</li>
  <li>显示标注类型与推断类型兼容</li>
  <li>等等</li>
</ul>

<p>那么为什么想做这玩意？<br />
最开始仅仅是因为为项目修复 <code class="language-plaintext highlighter-rouge">ts</code> 警告时，修复过程过于机械化，便想着为其注入灵魂让其自动推导</p>

<p>仅仅推导函数类型是不够了，其中不乏有一些设想：</p>
<ol>
  <li>我觉得可以让推导配合 <code class="language-plaintext highlighter-rouge">ts</code> 做到绝对的静态，所见即所得
    <ul>
      <li>无法推导的动态数据用 <code class="language-plaintext highlighter-rouge">ts</code> 标注比如（接口，文件获取，JSON转换等</li>
      <li>通过标识类型推导其他类型</li>
    </ul>
  </li>
  <li>有了具体类型，可以搭配自动化生成对应单侧
    <ul>
      <li>然鹅总所周知,<code class="language-plaintext highlighter-rouge">ts</code> 并不存在运行态，无法做到运行时校验，市面上虽然有相关的库, 都有有一些缺点：
        <ul>
          <li>需要入侵项目</li>
          <li>增加额外的运行开销</li>
        </ul>
      </li>
      <li>既然有单侧和 <code class="language-plaintext highlighter-rouge">e2e</code> 何不假想，本地运行态校验，而不影响预发线上环境呢
        <ul>
          <li>类型推导过模块后会生成缓存文件类似.umi</li>
          <li>开发一款插件，代理模块资源，匹配上缓存文件，走代理调用外层包一层类型推断</li>
          <li>类型推断根据缓存文件以及运行数据断言</li>
          <li>类型断言完全不影响开发心智，无需额外增加代码，也不影响其他环境</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>因为推断过程可以获取到足够多的信息，是可以感知，哪些函数不合理
    <ul>
      <li>比如修改源数据</li>
      <li>组件内创建传函数等</li>
      <li>但这一块设想因为 ai吃掉了很大一部分，倒希望利用解析到足够多的信息怎么加入他们</li>
    </ul>
  </li>
</ol>

<p>进度情况</p>

<p>参考文章：</p>

<ul>
  <li><a href="https://zh.wikipedia.org/zh-hans/Trie">前置树Trie</a></li>
  <li><a href="https://v8.dev/docs/hidden-classes">V8 中的隐藏类</a></li>
  <li><a href="https://v8.dev/blog/fast-properties">V8 中的快速属性</a></li>
  <li><a href="https://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html">内联缓存</a></li>
  <li><a href="https://github.com/ScriptOverture/InferType">类型推断</a></li>
</ul>]]></content><author><name>scriptoverture</name></author><category term="JavaScript" /><category term="TypeScript" /><category term="V8" /><summary type="html"><![CDATA[如何高效比较类型结构？从 TS 的类型系统到结构 Trie 优化]]></summary></entry><entry><title type="html">React 性能优化</title><link href="https://scriptoverture.github.io/blog/2024/09/22/React-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="alternate" type="text/html" title="React 性能优化" /><published>2024-09-22T00:00:00+00:00</published><updated>2024-09-22T00:00:00+00:00</updated><id>https://scriptoverture.github.io/blog/2024/09/22/React%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96</id><content type="html" xml:base="https://scriptoverture.github.io/blog/2024/09/22/React-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"><![CDATA[<p>熟悉 <code class="language-plaintext highlighter-rouge">React</code> 的同学们都知道，每次数据更新都会重新渲染 <code class="language-plaintext highlighter-rouge">fiber</code> 树，匹配渲染优先级组件及其所有子组件都会重新渲染，存在心智负担，可能开发中很多同学会掏出 <code class="language-plaintext highlighter-rouge">useMemo</code>，<code class="language-plaintext highlighter-rouge">useCallback</code>, <code class="language-plaintext highlighter-rouge">memo</code>, <code class="language-plaintext highlighter-rouge">pureComponent</code>, <code class="language-plaintext highlighter-rouge">sholdComponentUpdate</code> 组合拳来优化避免组件重复渲染。</p>

<h3 id="组件为什么会被重复渲染">组件为什么会被重复渲染？</h3>

<p>首先来段示例，当 <code class="language-plaintext highlighter-rouge">App</code> 组件触发会影响 <code class="language-plaintext highlighter-rouge">Child</code> 重新渲染。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Child</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Child::render</span><span class="dl">'</span><span class="p">);</span>
  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="nx">child</span><span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span><span class="p">}</span>

<span class="nx">funcction</span> <span class="nx">App</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">data</span><span class="p">,</span> <span class="nx">setData</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;&gt;</span>
      <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">{</span> <span class="nx">data</span> <span class="p">}</span><span class="o">&lt;</span><span class="sr">/p</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">handleClick</span><span class="p">}</span><span class="o">&gt;</span><span class="nx">click</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">Child</span><span class="o">/&gt;</span>
    <span class="o">&lt;</span><span class="sr">/</span><span class="err">&gt;
</span>  <span class="p">);</span>

  <span class="kd">function</span> <span class="nx">handleClick</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">setData</span><span class="p">(</span><span class="nx">data</span> <span class="o">=&gt;</span> <span class="nx">data</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>有哪些方法可以避免Child渲染呢？</strong></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Child1</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Child1::render</span><span class="dl">'</span><span class="p">);</span>
  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="nx">child</span><span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span><span class="p">}</span>

<span class="kd">const</span> <span class="nx">child1</span> <span class="o">=</span> <span class="o">&lt;</span><span class="nx">Child1</span><span class="o">/&gt;</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">Child6</span> <span class="o">=</span> <span class="nx">memo</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Child6::render</span><span class="dl">'</span><span class="p">);</span>
  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="nx">child6</span><span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span><span class="p">})</span>

<span class="nx">funcction</span> <span class="nx">App</span><span class="p">({</span> <span class="nx">children</span><span class="p">,</span> <span class="nx">render</span> <span class="p">})</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">data</span><span class="p">,</span> <span class="nx">setData</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;&gt;</span>
      <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">{</span> <span class="nx">data</span> <span class="p">}</span><span class="o">&lt;</span><span class="sr">/p</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">handleClick</span><span class="p">}</span><span class="o">&gt;</span><span class="nx">click</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>      <span class="p">{</span> <span class="nx">child1</span> <span class="p">}</span>  
      <span class="p">{</span> 
        <span class="nx">useMemo</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Child2::render</span><span class="dl">'</span><span class="p">);</span>
          <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="nx">child2</span><span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>        <span class="p">},</span> <span class="p">[])</span>
      <span class="p">}</span>
      <span class="p">{</span>
        <span class="nx">useState</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Child3::render</span><span class="dl">'</span><span class="p">);</span>
          <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="nx">child3</span><span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>        <span class="p">})[</span><span class="mi">0</span><span class="p">]</span>
      <span class="p">}</span>
      <span class="p">{</span> <span class="nx">children</span> <span class="p">}</span>
      <span class="p">{</span> <span class="nx">render</span> <span class="p">}</span>
      <span class="o">&lt;</span><span class="nx">Child6</span><span class="o">/&gt;</span>
    <span class="o">&lt;</span><span class="sr">/</span><span class="err">&gt;
</span>  <span class="p">);</span>

  <span class="kd">function</span> <span class="nx">handleClick</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">setData</span><span class="p">(</span><span class="nx">data</span> <span class="o">=&gt;</span> <span class="nx">data</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">child5</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Child5::render</span><span class="dl">'</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="nx">child5</span><span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span><span class="p">}</span>

<span class="o">&lt;</span><span class="nx">App</span> <span class="nx">render</span><span class="o">=</span><span class="p">{</span><span class="nx">child5</span><span class="p">}</span><span class="o">&gt;</span>
  <span class="p">{</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Chil4::render</span><span class="dl">'</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="nx">child4</span><span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>  <span class="p">})</span> <span class="p">}</span>
<span class="o">&lt;</span><span class="sr">/App</span><span class="err">&gt;
</span>
<span class="c1">// 首次渲染</span>
<span class="nx">print</span> <span class="o">-&gt;</span> <span class="nx">star</span>
  <span class="nx">Child2</span><span class="p">::</span><span class="nx">render</span>
  <span class="nx">Child3</span><span class="p">::</span><span class="nx">render</span>
  <span class="nx">Child1</span><span class="p">::</span><span class="nx">render</span>
  <span class="nx">Child4</span><span class="p">::</span><span class="nx">render</span>
  <span class="nx">Child6</span><span class="p">::</span><span class="nx">render</span>
<span class="nx">print</span> <span class="o">-&gt;</span> <span class="nx">end</span>
</code></pre></div></div>

<p>通过点击 <code class="language-plaintext highlighter-rouge">button</code> 可以观察到控制台并无 <code class="language-plaintext highlighter-rouge">Child</code> 打印内容输出, 子组件并没有被重复渲染；
也就说除了常规包裹 <code class="language-plaintext highlighter-rouge">useMemo</code> 与 <code class="language-plaintext highlighter-rouge">memo</code> 外，还有很多其他的方式也可以达到类似效果；
可能会有同学疑惑（后面会有解释）</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">children</code> 不是子节点吗，为什么没有重新渲染</li>
  <li><code class="language-plaintext highlighter-rouge">useState</code> 为什么也可以避免 <code class="language-plaintext highlighter-rouge">Child</code> 渲染</li>
  <li>打印顺序是什么鬼？</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">React</code> 组件会根据 state(useState|setState), <code class="language-plaintext highlighter-rouge">props</code>, <code class="language-plaintext highlighter-rouge">context</code> 来判断当前 <code class="language-plaintext highlighter-rouge">fiber</code> 是否可以复用
找到源码中 <code class="language-plaintext highlighter-rouge">beginWork</code> 方法，
<code class="language-plaintext highlighter-rouge">beginWork</code> 主要用于生成子 <code class="language-plaintext highlighter-rouge">filber</code> 以及打上对应 <code class="language-plaintext highlighter-rouge">flags</code></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">beginWork</span><span class="p">(</span>
  <span class="nx">current</span><span class="p">:</span> <span class="nx">Fiber</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
  <span class="nx">workInProgress</span><span class="p">:</span> <span class="nx">Fiber</span><span class="p">,</span>
  <span class="nx">renderLanes</span><span class="p">:</span> <span class="nx">Lanes</span><span class="p">,</span>
<span class="p">):</span> <span class="nx">Fiber</span> <span class="o">|</span> <span class="kc">null</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">updateLanes</span> <span class="o">=</span> <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">lanes</span><span class="p">;</span>
  <span class="c1">// current 存在 update更新</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">current</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">oldProps</span> <span class="o">=</span> <span class="nx">current</span><span class="p">.</span><span class="nx">memoizedProps</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">newProps</span> <span class="o">=</span> <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">pendingProps</span><span class="p">;</span>
    <span class="c1">// 判断新旧props是否全等 或者 上下文是否有变化</span>
    <span class="k">if</span> <span class="p">(</span>
      <span class="nx">oldProps</span> <span class="o">!==</span> <span class="nx">newProps</span> <span class="o">||</span>
      <span class="nx">hasLegacyContextChanged</span><span class="p">()</span>
    <span class="p">)</span> <span class="p">{</span>
      <span class="nx">didReceiveUpdate</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
      <span class="c1">// 当渲染优先级不包含workInProgress的优先级，复用旧fiber</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">includesSomeLane</span><span class="p">(</span><span class="nx">renderLanes</span><span class="p">,</span> <span class="nx">updateLanes</span><span class="p">))</span> <span class="p">{</span>
      <span class="nx">didReceiveUpdate</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
      <span class="p">...</span>
      <span class="c1">// 复用fiber</span>
      <span class="k">return</span> <span class="nx">bailoutOnAlreadyFinishedWork</span><span class="p">(</span><span class="nx">current</span><span class="p">,</span> <span class="nx">workInProgress</span><span class="p">,</span> <span class="nx">renderLanes</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">((</span><span class="nx">current</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">ForceUpdateForLegacySuspense</span><span class="p">)</span> <span class="o">!==</span> <span class="nx">NoFlags</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span>
        <span class="nx">didReceiveUpdate</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
       <span class="p">...</span>
        <span class="nx">didReceiveUpdate</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">didReceiveUpdate</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
  <span class="p">}</span>

</code></pre></div></div>

<p>乍一看不是很合理吗，那么为何App组件更新会导致Child组件刷新呢？</p>

<p><strong>首先我们得知道workInProgress.pendingProps到底是啥？</strong></p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 源码中</span>
<span class="kd">const</span> <span class="nx">pendingProps</span> <span class="o">=</span> <span class="nx">element</span><span class="p">.</span><span class="nx">props</span><span class="p">;</span>

<span class="c1">// 那么这个element又是啥呢？</span>
<span class="c1">// 格式如下</span>
<span class="p">{</span>
  <span class="na">_owner</span><span class="p">:</span><span class="kc">null</span>
  <span class="na">_store</span><span class="p">:{</span><span class="na">validated</span><span class="p">:</span> <span class="kc">true</span><span class="p">}</span>
  <span class="nx">$</span><span class="na">$typeof</span><span class="p">:</span><span class="nb">Symbol</span><span class="p">(</span><span class="nx">react</span><span class="p">.</span><span class="nx">element</span><span class="p">)</span>
  <span class="na">key</span><span class="p">:</span><span class="kc">null</span>
  <span class="na">props</span><span class="p">:{}</span>
  <span class="nl">ref</span><span class="p">:</span><span class="kc">null</span>
  <span class="na">type</span><span class="p">:()</span> <span class="o">=&gt;</span> <span class="p">{</span><span class="err">\</span><span class="nx">n</span>  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Child::RENDER</span><span class="dl">'</span><span class="p">);</span><span class="err">\</span><span class="nx">n</span>  <span class="k">return</span> <span class="cm">/*#__PURE...
}
// 是不是很熟悉，这就是常写得Jsx数据
// 可以打印看看
const Child1 = () =&gt; {
  console.log('Child1::render');
  return &lt;div&gt;child&lt;/div&gt;;
};

const child1 = &lt;Child1 /&gt;;
console.log(child1);

// 换个方式可以证明
let props1 = child1.props;
let props2 = child1.props;
console.log(props1 === props2);
print -&gt; true

// props3 与 props4 生成得Jsx 不是同一引用因此不相等
let props3 = (&lt;Child1 /&gt;).props;
let props4 = (&lt;Child1 /&gt;).props;
console.log(props3 === props4);
print -&gt; false

// 这个概念类似
const a = { "test": 1 };
const b = { "test": 1'};
console.log(a === b);
print -&gt; false
const c = a; // "c" 仅仅是 "a" 的引用
console.log(a === c); 
print -&gt; true
</span></code></pre></div></div>

<p>因此当 <code class="language-plaintext highlighter-rouge">App</code> 组件更新时 重新生成 <code class="language-plaintext highlighter-rouge">JSX</code>，<code class="language-plaintext highlighter-rouge">Child</code> 组件对应得 <code class="language-plaintext highlighter-rouge">props</code> 内存地址也发生了变化，故会重新渲染.</p>

<p>这也就解释了</p>
<ul>
  <li>同一引用得 <code class="language-plaintext highlighter-rouge">Child1</code> 组件不会受到影响。</li>
  <li><code class="language-plaintext highlighter-rouge">children</code> 与 <code class="language-plaintext highlighter-rouge">render</code> 属性也是一样的, 引用未变。
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Child5</code> 与 <code class="language-plaintext highlighter-rouge">Child6</code> 组件是在 <code class="language-plaintext highlighter-rouge">App</code> 外部生成的 <code class="language-plaintext highlighter-rouge">JSX</code> 并赋值给 <code class="language-plaintext highlighter-rouge">App</code> 中的 <code class="language-plaintext highlighter-rouge">children</code> 与 <code class="language-plaintext highlighter-rouge">render</code> 属性。</li>
      <li>所以 <code class="language-plaintext highlighter-rouge">App</code> 组件再次渲染子组件便会重新生成 <code class="language-plaintext highlighter-rouge">JSX</code>（换句话说只会影响内部的子元素）</li>
      <li>因为 <code class="language-plaintext highlighter-rouge">App</code> 外层没有变更，因此 <code class="language-plaintext highlighter-rouge">App</code> 不会重新生成 <code class="language-plaintext highlighter-rouge">JSX</code>，<code class="language-plaintext highlighter-rouge">children</code> 与 <code class="language-plaintext highlighter-rouge">render</code> 内存地址固然不变咯。</li>
    </ul>
  </li>
</ul>

<h3 id="usememo-memo为何可以避免组件重新渲染">useMemo, memo为何可以避免组件重新渲染?</h3>

<p>可能大伙都很熟悉这几个 <code class="language-plaintext highlighter-rouge">API</code>， 对于 <code class="language-plaintext highlighter-rouge">useMemo</code> 缓存变量，<code class="language-plaintext highlighter-rouge">memo</code> 包裹的组件浅比较 <code class="language-plaintext highlighter-rouge">props</code> 来判断组件是否需要重新渲染。</p>

<h4 id="memo">memo</h4>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">// 项目中很多这么使用的(可能有问题，下面会说)</span>
<span class="kd">const</span> <span class="nx">Test</span> <span class="o">=</span> <span class="nx">memo</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;??</span><span class="p">?</span><span class="o">&lt;</span><span class="sr">/div&gt;</span><span class="err">)
</span><span class="c1">// memo还有第二个参数“手动档”进行新旧props比较</span>
<span class="kd">const</span> <span class="nx">Test</span> <span class="o">=</span> <span class="nx">memo</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;??</span><span class="p">?</span><span class="o">&lt;</span><span class="sr">/div&gt;, </span><span class="se">(</span><span class="sr">prev, next</span><span class="se">)</span><span class="sr"> =&gt; prev !== next</span><span class="err">)
</span>
<span class="c1">// 那么 memo 是怎么保障组件渲染的呢</span>
<span class="c1">// 源码 updateMemoComponent 中</span>
<span class="kd">const</span> <span class="nx">prevProps</span> <span class="o">=</span> <span class="nx">currentChild</span><span class="p">.</span><span class="nx">memoizedProps</span><span class="p">;</span>
<span class="c1">// compare 为 “手动档” 回调</span>
<span class="kd">let</span> <span class="nx">compare</span> <span class="o">=</span> <span class="nx">Component</span><span class="p">.</span><span class="nx">compare</span><span class="p">;</span>
<span class="nx">compare</span> <span class="o">=</span> <span class="nx">compare</span> <span class="o">!==</span> <span class="kc">null</span> <span class="p">?</span> <span class="nx">compare</span> <span class="p">:</span> <span class="nx">shallowEqual</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">compare</span><span class="p">(</span><span class="nx">prevProps</span><span class="p">,</span> <span class="nx">nextProps</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">current</span><span class="p">.</span><span class="nx">ref</span> <span class="o">===</span> <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">ref</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 复用 fiber</span>
  <span class="k">return</span> <span class="nx">bailoutOnAlreadyFinishedWork</span><span class="p">(</span><span class="nx">current</span><span class="p">,</span> <span class="nx">workInProgress</span><span class="p">,</span> <span class="nx">renderLanes</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 也就是存在定义的比较函数时使用，否则使用默认比较shallowEqual</span>
<span class="c1">// 命中则复用不会重新渲染</span>
</code></pre></div></div>

<p>所以这也就解释了上面为什么说 <code class="language-plaintext highlighter-rouge">memo</code> 包裹的 <code class="language-plaintext highlighter-rouge">Child6</code> 不会被重新渲染。
再看看默认比较规则 <code class="language-plaintext highlighter-rouge">shallowEqual</code>:</p>
<ul>
  <li>比较内存</li>
  <li>不是对象</li>
  <li>比较参数长度</li>
  <li>遍历参数比较</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">function</span> <span class="nx">shallowEqual</span><span class="p">(</span><span class="nx">objA</span><span class="p">:</span> <span class="nx">mixed</span><span class="p">,</span> <span class="nx">objB</span><span class="p">:</span> <span class="nx">mixed</span><span class="p">):</span> <span class="nx">boolean</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">is</span><span class="p">(</span><span class="nx">objA</span><span class="p">,</span> <span class="nx">objB</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span>
    <span class="k">typeof</span> <span class="nx">objA</span> <span class="o">!==</span> <span class="dl">'</span><span class="s1">object</span><span class="dl">'</span> <span class="o">||</span>
    <span class="nx">objA</span> <span class="o">===</span> <span class="kc">null</span> <span class="o">||</span>
    <span class="k">typeof</span> <span class="nx">objB</span> <span class="o">!==</span> <span class="dl">'</span><span class="s1">object</span><span class="dl">'</span> <span class="o">||</span>
    <span class="nx">objB</span> <span class="o">===</span> <span class="kc">null</span>
  <span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">const</span> <span class="nx">keysA</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">objA</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">keysB</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">objB</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">keysA</span><span class="p">.</span><span class="nx">length</span> <span class="o">!==</span> <span class="nx">keysB</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Test for A's keys different from B.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">keysA</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span>
      <span class="o">!</span><span class="nx">hasOwnProperty</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">objB</span><span class="p">,</span> <span class="nx">keysA</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="o">||</span>
      <span class="o">!</span><span class="nx">is</span><span class="p">(</span><span class="nx">objA</span><span class="p">[</span><span class="nx">keysA</span><span class="p">[</span><span class="nx">i</span><span class="p">]],</span> <span class="nx">objB</span><span class="p">[</span><span class="nx">keysA</span><span class="p">[</span><span class="nx">i</span><span class="p">]])</span>
    <span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="问-给所有组件都包裹memo合适吗">问: 给所有组件都包裹memo合适吗？</h5>
<p>上面大家都可以看到 <code class="language-plaintext highlighter-rouge">memo</code> 的好处，但是凡是都有代价的，对比正常的组件多了一层浅比较逻辑不说。
对于参数比较少的组件来说，使用默认规则可能开销不那么大。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 举个极端的例子，这要走默认比较不得老要命了😉</span>
<span class="c1">// 下次看到建议直接打死</span>
<span class="kd">const</span> <span class="nx">Demo</span> <span class="o">=</span> <span class="nx">memo</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="nx">demo</span><span class="o">&lt;</span><span class="sr">/div&gt;</span><span class="err">)
</span>
<span class="kd">let</span> <span class="nx">records</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">...</span><span class="mi">100</span> <span class="nx">arguments</span>
<span class="p">}</span>
<span class="o">&lt;</span><span class="nx">Demo</span> <span class="p">{...</span><span class="nx">records</span><span class="p">}</span><span class="sr">/</span><span class="err">&gt;
</span></code></pre></div></div>

<h4 id="usememo">useMemo</h4>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// useMemo 用来缓存原始变量</span>
<span class="c1">// 举个栗子</span>
<span class="kd">let</span> <span class="nx">originData</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">test</span><span class="p">:</span> <span class="dl">'</span><span class="s1">???</span><span class="dl">'</span><span class="p">,</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">Test</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">data</span><span class="p">,</span> <span class="nx">setData</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="kd">let</span> <span class="nx">cacheData</span> <span class="o">=</span> <span class="nx">useMemo</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">originData</span><span class="p">,</span> <span class="p">[]);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">cacheData</span> <span class="o">===</span> <span class="nx">originData</span><span class="p">);</span>

  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">setData</span><span class="p">(</span><span class="nx">data</span> <span class="o">=&gt;</span> <span class="nx">data</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">}}</span><span class="o">&gt;</span><span class="nx">click</span><span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span><span class="p">}</span>

<span class="c1">// Test 组件每次渲染 都会打印 true</span>
<span class="c1">// 上面说了&lt;Child/&gt; 就是JSX对象</span>
<span class="c1">// 所以useMemo也能缓存JSX对象引用,  保障新旧props地址相同</span>
</code></pre></div></div>

<h5 id="问为什么usememo可以缓存数据">问：为什么useMemo可以缓存数据？</h5>

<p>其实可以根据上面的示例猜测一下，（执行回调，缓存回调变量？？）
细说的话这个问题其实和 <code class="language-plaintext highlighter-rouge">Hooks</code> 原理是差不多的。</p>

<p><strong>首次渲染时的 <code class="language-plaintext highlighter-rouge">useMemo</code>:</strong></p>

<pre><code class="language-javasccript">export function useMemo&lt;T&gt;(
  create: () =&gt; T,
  deps: Array&lt;mixed&gt; | void | null,
): T {
  const dispatcher = resolveDispatcher();
  return dispatcher.useMemo(create, deps);
}
// dispatcher.useMemo 最终会调用 mountMemo

function mountMemo&lt;T&gt;(
  nextCreate: () =&gt; T,
  deps: Array&lt;mixed&gt; | void | null,
): T {
  const hook = mountWorkInProgressHook();
  const nextDeps = deps === undefined ? null : deps;
  const nextValue = nextCreate();
  hook.memoizedState = [nextValue, nextDeps];
  return nextValue;
}
// 可以看到 nextValue (也就是需要缓存的变量或者JSX对象)被存入hook.memoizedState中



function mountWorkInProgressHook(): Hook {
  const hook: Hook = {
    memoizedState: null,

    baseState: null,
    baseQueue: null,
    queue: null,

    next: null,
  };
  // workInProgressHook 表示组件所创建的hooks链表
  // 为null的话表示当前hook是该组件的第一个hook
  if (workInProgressHook === null) {
    // This is the first hook in the list
    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;
  } else {
    // Append to the end of the list
    workInProgressHook = workInProgressHook.next = hook;
  }
  return workInProgressHook;
}
// mountWorkInProgressHook 
// 创建一个hook
// 是第一个hook, 赋值memoizedState = workInProgressHook = hook
// 不是的话就next连接起来
  // 举个栗子
  useA(); // workInProgressHook = hookA
  useB(); // workInProgressHook = hookA.next -&gt; hookB


//上面的 currentlyRenderingFiber 在 renderWithHooks 中赋值 workInProgress(当前组件fiber)
export function renderWithHooks&lt;Props, SecondArg&gt;(
  current: Fiber | null,
  workInProgress: Fiber,
  Component: (p: Props, arg: SecondArg) =&gt; any,
  props: Props,
  secondArg: SecondArg,
  nextRenderLanes: Lanes,
): any {
  renderLanes = nextRenderLanes;
  currentlyRenderingFiber = workInProgress;
  ...
  let children = Component(props, secondArg);
  ...
  }
</code></pre>

<p><strong>再看看update阶段的useMemo</strong></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// dispatcher.useMemo 最终会调用 updateMemo</span>
<span class="kd">function</span> <span class="nx">updateMemo</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span>
  <span class="nx">nextCreate</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">T</span><span class="p">,</span>
  <span class="nx">deps</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">mixed</span><span class="o">&gt;</span> <span class="o">|</span> <span class="k">void</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
<span class="p">):</span> <span class="nx">T</span> <span class="p">{</span>
  <span class="c1">// 当前hook</span>
  <span class="kd">const</span> <span class="nx">hook</span> <span class="o">=</span> <span class="nx">updateWorkInProgressHook</span><span class="p">();</span>
  <span class="kd">const</span> <span class="nx">nextDeps</span> <span class="o">=</span> <span class="nx">deps</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="p">?</span> <span class="kc">null</span> <span class="p">:</span> <span class="nx">deps</span><span class="p">;</span>
  <span class="c1">// 首次渲染缓存的值</span>
  <span class="kd">const</span> <span class="nx">prevState</span> <span class="o">=</span> <span class="nx">hook</span><span class="p">.</span><span class="nx">memoizedState</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">prevState</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">nextDeps</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">prevDeps</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">mixed</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span> <span class="o">=</span> <span class="nx">prevState</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
      <span class="c1">// 比较依赖</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">areHookInputsEqual</span><span class="p">(</span><span class="nx">nextDeps</span><span class="p">,</span> <span class="nx">prevDeps</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// 复用旧值</span>
        <span class="k">return</span> <span class="nx">prevState</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="c1">// 计算新值</span>
  <span class="kd">const</span> <span class="nx">nextValue</span> <span class="o">=</span> <span class="nx">nextCreate</span><span class="p">();</span>
  <span class="nx">hook</span><span class="p">.</span><span class="nx">memoizedState</span> <span class="o">=</span> <span class="p">[</span><span class="nx">nextValue</span><span class="p">,</span> <span class="nx">nextDeps</span><span class="p">];</span>
  <span class="k">return</span> <span class="nx">nextValue</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// updateMemo 整个逻辑还是很简单的</span>



<span class="c1">// 再看看比较依赖areHookInputsEqual </span>
<span class="kd">function</span> <span class="nx">areHookInputsEqual</span><span class="p">(</span>
  <span class="nx">nextDeps</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">mixed</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="nx">prevDeps</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">mixed</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">prevDeps</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">prevDeps</span><span class="p">.</span><span class="nx">length</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">nextDeps</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">is</span><span class="p">(</span><span class="nx">nextDeps</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">prevDeps</span><span class="p">[</span><span class="nx">i</span><span class="p">]))</span> <span class="p">{</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>大家也可以下面例子验证 <code class="language-plaintext highlighter-rouge">useMemo</code> 存储位置，控制台查看 <code class="language-plaintext highlighter-rouge">memoizedState</code> 中 <code class="language-plaintext highlighter-rouge">memo</code> 缓存的数据。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">App</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;&gt;</span>
      <span class="p">{</span><span class="nx">useMemo</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Child2::render</span><span class="dl">'</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="nx">child2</span><span class="o">&lt;</span><span class="sr">/div&gt;</span><span class="err">;
</span>      <span class="p">},</span> <span class="p">[])}</span>
    <span class="o">&lt;</span><span class="sr">/</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">dom</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">root</span><span class="dl">'</span><span class="p">)</span>
<span class="kd">let</span> <span class="nx">current</span> <span class="o">=</span> <span class="nx">dom</span><span class="p">.</span><span class="nx">__reactContainer$g605vp1tnct</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">current</span><span class="p">.</span><span class="nx">child</span><span class="p">.</span><span class="nx">memoizedState</span><span class="p">.</span><span class="nx">memoizedState</span><span class="p">);</span>
<span class="nx">print</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="nx">JSX对象</span><span class="p">,</span> <span class="nx">依赖</span><span class="p">]</span>
</code></pre></div></div>

<p>所以当 <code class="language-plaintext highlighter-rouge">App</code> 组件再次渲染时，倘若 <code class="language-plaintext highlighter-rouge">useMemo</code> 依赖项没有变更，便会复用(使用上次内存地址，进而新旧 <code class="language-plaintext highlighter-rouge">props</code> 也会全等)。</p>

<p><strong>那么useMemo 相同效果的好兄弟 “pureComponents” &amp; “sholdComponentUpdate”;
他们的作用真的相等吗？</strong></p>

<h5 id="purecomponents">pureComponents</h5>

<p>类组件只需要继承 <code class="language-plaintext highlighter-rouge">pureComponents</code> 便可以避免 <code class="language-plaintext highlighter-rouge">render</code> 渲染，是不是神似 <code class="language-plaintext highlighter-rouge">memo</code> , 那你知道他们的区别吗？</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Test</span> <span class="kd">extends</span> <span class="nx">PureComponent</span> <span class="p">{</span>

    <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Testsssssssssss</span><span class="dl">'</span><span class="p">);</span>
        <span class="k">return</span> <span class="dl">"</span><span class="s2">Test</span><span class="dl">"</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 源码中 PureComponent 实现</span>
<span class="kd">function</span> <span class="nx">PureComponent</span><span class="p">(</span><span class="nx">props</span><span class="p">,</span> <span class="nx">context</span><span class="p">,</span> <span class="nx">updater</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">props</span> <span class="o">=</span> <span class="nx">props</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">context</span> <span class="o">=</span> <span class="nx">context</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">refs</span> <span class="o">=</span> <span class="nx">emptyObject</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">updater</span> <span class="o">=</span> <span class="nx">updater</span> <span class="o">||</span> <span class="nx">ReactNoopUpdateQueue</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">pureComponentPrototype</span> <span class="o">=</span> <span class="p">(</span><span class="nx">PureComponent</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ComponentDummy</span><span class="p">());</span>
<span class="nx">pureComponentPrototype</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">=</span> <span class="nx">PureComponent</span><span class="p">;</span>
<span class="c1">// 继承Component</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">pureComponentPrototype</span><span class="p">,</span> <span class="nx">Component</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
<span class="c1">// 这里留意一下 isPureReactComponent 标识</span>
<span class="nx">pureComponentPrototype</span><span class="p">.</span><span class="nx">isPureReactComponent</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</code></pre></div></div>

<p>可以在 <code class="language-plaintext highlighter-rouge">updateClassInstance</code> 中看到全貌，省略了部分代码
看上去代码量很多，其实每环逻辑很清晰, 主要为 <code class="language-plaintext highlighter-rouge">componentDidUpdate</code> 和 <code class="language-plaintext highlighter-rouge">getSnapshotBeforeUpdate</code> 添加标记
返回是否需要重新渲染布尔标识（true -&gt; 需要渲染 | false -&gt; 复用）</p>

<ol>
  <li>判断新旧 <code class="language-plaintext highlighter-rouge">props</code> 与 <code class="language-plaintext highlighter-rouge">data</code> 内存地址是否一致，上下文是否变化
    <ul>
      <li>没有变化复用放回 <code class="language-plaintext highlighter-rouge">false</code>, 为相关生命周期打添加对应标识</li>
    </ul>
  </li>
  <li>计算 <code class="language-plaintext highlighter-rouge">shouldUpdate</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">shouldUpdate</code> 为 <code class="language-plaintext highlighter-rouge">false</code> 时代表复用，为相关生命周期打添加对应标识（与上面 1-a 一致）</li>
      <li><code class="language-plaintext highlighter-rouge">shouldUpdate</code> 为 <code class="language-plaintext highlighter-rouge">true</code> 代表需要重新 <code class="language-plaintext highlighter-rouge">render</code>，存在 <code class="language-plaintext highlighter-rouge">componentWillUpdate</code> or <code class="language-plaintext highlighter-rouge">UNSAFE_componentWillUpdate</code> 执行。</li>
    </ul>
  </li>
</ol>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">updateClassInstance</span><span class="p">(</span>
  <span class="nx">current</span><span class="p">:</span> <span class="nx">Fiber</span><span class="p">,</span>
  <span class="nx">workInProgress</span><span class="p">:</span> <span class="nx">Fiber</span><span class="p">,</span>
  <span class="nx">ctor</span><span class="p">:</span> <span class="nx">any</span><span class="p">,</span>
  <span class="nx">newProps</span><span class="p">:</span> <span class="nx">any</span><span class="p">,</span>
  <span class="nx">renderLanes</span><span class="p">:</span> <span class="nx">Lanes</span><span class="p">,</span>
<span class="p">):</span> <span class="nx">boolean</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">instance</span> <span class="o">=</span> <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">stateNode</span><span class="p">;</span>

  <span class="kd">const</span> <span class="nx">unresolvedOldProps</span> <span class="o">=</span> <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">memoizedProps</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">oldProps</span> <span class="o">=</span>
    <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">elementType</span>
      <span class="p">?</span> <span class="nx">unresolvedOldProps</span>
      <span class="p">:</span> <span class="nx">resolveDefaultProps</span><span class="p">(</span><span class="nx">workInProgress</span><span class="p">.</span><span class="nx">type</span><span class="p">,</span> <span class="nx">unresolvedOldProps</span><span class="p">);</span>
  <span class="nx">instance</span><span class="p">.</span><span class="nx">props</span> <span class="o">=</span> <span class="nx">oldProps</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">unresolvedNewProps</span> <span class="o">=</span> <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">pendingProps</span><span class="p">;</span>

  <span class="kd">const</span> <span class="nx">oldContext</span> <span class="o">=</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">context</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">contextType</span> <span class="o">=</span> <span class="nx">ctor</span><span class="p">.</span><span class="nx">contextType</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">nextContext</span> <span class="o">=</span> <span class="nx">emptyContextObject</span><span class="p">;</span>
  <span class="p">...</span>

  <span class="kd">const</span> <span class="nx">oldState</span> <span class="o">=</span> <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">memoizedState</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">newState</span> <span class="o">=</span> <span class="p">(</span><span class="nx">instance</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="nx">oldState</span><span class="p">);</span>
  <span class="nx">newState</span> <span class="o">=</span> <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">memoizedState</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span>
    <span class="nx">unresolvedOldProps</span> <span class="o">===</span> <span class="nx">unresolvedNewProps</span> <span class="o">&amp;&amp;</span>
    <span class="nx">oldState</span> <span class="o">===</span> <span class="nx">newState</span> <span class="o">&amp;&amp;</span>
    <span class="o">!</span><span class="nx">hasContextChanged</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
    <span class="o">!</span><span class="nx">checkHasForceUpdateAfterProcessing</span><span class="p">()</span>
  <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">componentDidUpdate</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span>
        <span class="nx">unresolvedOldProps</span> <span class="o">!==</span> <span class="nx">current</span><span class="p">.</span><span class="nx">memoizedProps</span> <span class="o">||</span>
        <span class="nx">oldState</span> <span class="o">!==</span> <span class="nx">current</span><span class="p">.</span><span class="nx">memoizedState</span>
      <span class="p">)</span> <span class="p">{</span>
        <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">flags</span> <span class="o">|=</span> <span class="nx">Update</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">getSnapshotBeforeUpdate</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span>
        <span class="nx">unresolvedOldProps</span> <span class="o">!==</span> <span class="nx">current</span><span class="p">.</span><span class="nx">memoizedProps</span> <span class="o">||</span>
        <span class="nx">oldState</span> <span class="o">!==</span> <span class="nx">current</span><span class="p">.</span><span class="nx">memoizedState</span>
      <span class="p">)</span> <span class="p">{</span>
        <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">flags</span> <span class="o">|=</span> <span class="nx">Snapshot</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="p">...</span>
  <span class="c1">// 重新计算 shouldUpdate</span>
  <span class="c1">// 需要留意 checkShouldComponentUpdate</span>
  <span class="kd">const</span> <span class="nx">shouldUpdate</span> <span class="o">=</span>
    <span class="nx">checkHasForceUpdateAfterProcessing</span><span class="p">()</span> <span class="o">||</span>
    <span class="nx">checkShouldComponentUpdate</span><span class="p">(</span>
      <span class="nx">workInProgress</span><span class="p">,</span>
      <span class="nx">ctor</span><span class="p">,</span>
      <span class="nx">oldProps</span><span class="p">,</span>
      <span class="nx">newProps</span><span class="p">,</span>
      <span class="nx">oldState</span><span class="p">,</span>
      <span class="nx">newState</span><span class="p">,</span>
      <span class="nx">nextContext</span><span class="p">,</span>
    <span class="p">);</span>
  <span class="c1">// 重新渲染 render </span>
  <span class="c1">// 存在 componentWillUpdate or UNSAFE_componentWillUpdate 执行</span>
  <span class="c1">// 为 componentDidUpdate and getSnapshotBeforeUpdate 添加标记</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">shouldUpdate</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span>
      <span class="o">!</span><span class="nx">hasNewLifecycles</span> <span class="o">&amp;&amp;</span>
      <span class="p">(</span><span class="k">typeof</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">UNSAFE_componentWillUpdate</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span> <span class="o">||</span>
        <span class="k">typeof</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">componentWillUpdate</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span><span class="p">)</span>
    <span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">componentWillUpdate</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">instance</span><span class="p">.</span><span class="nx">componentWillUpdate</span><span class="p">(</span><span class="nx">newProps</span><span class="p">,</span> <span class="nx">newState</span><span class="p">,</span> <span class="nx">nextContext</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">UNSAFE_componentWillUpdate</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">instance</span><span class="p">.</span><span class="nx">UNSAFE_componentWillUpdate</span><span class="p">(</span><span class="nx">newProps</span><span class="p">,</span> <span class="nx">newState</span><span class="p">,</span> <span class="nx">nextContext</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">componentDidUpdate</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">flags</span> <span class="o">|=</span> <span class="nx">Update</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">getSnapshotBeforeUpdate</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">flags</span> <span class="o">|=</span> <span class="nx">Snapshot</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// 复用</span>
    <span class="c1">// 为 componentDidUpdate and getSnapshotBeforeUpdate 添加标记</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">componentDidUpdate</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span>
        <span class="nx">unresolvedOldProps</span> <span class="o">!==</span> <span class="nx">current</span><span class="p">.</span><span class="nx">memoizedProps</span> <span class="o">||</span>
        <span class="nx">oldState</span> <span class="o">!==</span> <span class="nx">current</span><span class="p">.</span><span class="nx">memoizedState</span>
      <span class="p">)</span> <span class="p">{</span>
        <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">flags</span> <span class="o">|=</span> <span class="nx">Update</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">getSnapshotBeforeUpdate</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span>
        <span class="nx">unresolvedOldProps</span> <span class="o">!==</span> <span class="nx">current</span><span class="p">.</span><span class="nx">memoizedProps</span> <span class="o">||</span>
        <span class="nx">oldState</span> <span class="o">!==</span> <span class="nx">current</span><span class="p">.</span><span class="nx">memoizedState</span>
      <span class="p">)</span> <span class="p">{</span>
        <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">flags</span> <span class="o">|=</span> <span class="nx">Snapshot</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">memoizedProps</span> <span class="o">=</span> <span class="nx">newProps</span><span class="p">;</span>
    <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">memoizedState</span> <span class="o">=</span> <span class="nx">newState</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">instance</span><span class="p">.</span><span class="nx">props</span> <span class="o">=</span> <span class="nx">newProps</span><span class="p">;</span>
  <span class="nx">instance</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="nx">newState</span><span class="p">;</span>
  <span class="nx">instance</span><span class="p">.</span><span class="nx">context</span> <span class="o">=</span> <span class="nx">nextContext</span><span class="p">;</span>

  <span class="k">return</span> <span class="nx">shouldUpdate</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">checkShouldComponentUpdate</code> 中逻辑非常简单：</p>
<ol>
  <li>存在 <code class="language-plaintext highlighter-rouge">shouldComponentUpdate</code> 调用（<code class="language-plaintext highlighter-rouge">shouldComponentUpdate</code> 优先级高于 <code class="language-plaintext highlighter-rouge">pureComponents</code>）</li>
  <li>否则判断是否带有 <code class="language-plaintext highlighter-rouge">isPureReactComponent</code> 标识
    <ul>
      <li>使用默认比较 <code class="language-plaintext highlighter-rouge">shallowEqual</code> (老演员了与上面 <code class="language-plaintext highlighter-rouge">memo</code> 一致)</li>
      <li>除了比较 <code class="language-plaintext highlighter-rouge">props</code> 外还会比较 <code class="language-plaintext highlighter-rouge">state</code> 满足一个条件即可</li>
    </ul>
  </li>
  <li>返回是否渲染状态标识。</li>
</ol>

<pre><code class="language-javasccript">function checkShouldComponentUpdate(
  workInProgress,
  ctor,
  oldProps,
  newProps,
  oldState,
  newState,
  nextContext,
) {
  const instance = workInProgress.stateNode;
  if (typeof instance.shouldComponentUpdate === 'function') {
    const shouldUpdate = instance.shouldComponentUpdate(
      newProps,
      newState,
      nextContext,
    );

    return shouldUpdate;
  }

  if (ctor.prototype &amp;&amp; ctor.prototype.isPureReactComponent) {
    return (
      !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)
    );
  }

  return true;
}
</code></pre>

<p>上面也验证了 <code class="language-plaintext highlighter-rouge">PureComponents</code> 与 <code class="language-plaintext highlighter-rouge">memo</code> 的差异性:</p>
<ul>
  <li>比较规则的差异性
    <ul>
      <li>除了比较 <code class="language-plaintext highlighter-rouge">props</code> 还会比较 <code class="language-plaintext highlighter-rouge">state</code></li>
      <li><code class="language-plaintext highlighter-rouge">shouldComponentUpdate</code> 传参与 <code class="language-plaintext highlighter-rouge">memo</code> 回调也不相同</li>
    </ul>
  </li>
  <li>而 <code class="language-plaintext highlighter-rouge">shouldComponentUpdate</code> 更像是 <code class="language-plaintext highlighter-rouge">memo</code> 的第二个回调
    <ul>
      <li>优先级高于默认 <code class="language-plaintext highlighter-rouge">shallowEqual</code> 比较</li>
    </ul>
  </li>
</ul>

<p>所以这么一看 <code class="language-plaintext highlighter-rouge">memo</code> 像是 <code class="language-plaintext highlighter-rouge">PureComponents</code> + <code class="language-plaintext highlighter-rouge">shouldComponentUpdate</code> 的浓缩版😄。</p>

<h5 id="shouldupdate-渲染标识是怎么影响渲染的">shouldUpdate 渲染标识是怎么影响渲染的？</h5>

<p>在 <code class="language-plaintext highlighter-rouge">finishClassComponent</code> 中会根据 <code class="language-plaintext highlighter-rouge">shouldUpdate</code> 标识来判断复用
这个 <code class="language-plaintext highlighter-rouge">bailoutOnAlreadyFinishedWord</code> （也是老演员了，上面复用都有出现,，大家感兴趣可以自行了解，此处不展开）复用 <code class="language-plaintext highlighter-rouge">Filber</code>。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 异常</span>
<span class="kd">const</span> <span class="nx">didCaptureError</span> <span class="o">=</span> <span class="p">(</span><span class="nx">workInProgress</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">DidCapture</span><span class="p">)</span> <span class="o">!==</span> <span class="nx">NoFlags</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">shouldUpdate</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">didCaptureError</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">hasContext</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">invalidateContextProvider</span><span class="p">(</span><span class="nx">workInProgress</span><span class="p">,</span> <span class="nx">Component</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">// 复用</span>
  <span class="k">return</span> <span class="nx">bailoutOnAlreadyFinishedWork</span><span class="p">(</span><span class="nx">current</span><span class="p">,</span> <span class="nx">workInProgress</span><span class="p">,</span> <span class="nx">renderLanes</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 存在异常</span>
<span class="k">if</span> <span class="p">(</span>
    <span class="nx">didCaptureError</span> <span class="o">&amp;&amp;</span>
    <span class="k">typeof</span> <span class="nx">Component</span><span class="p">.</span><span class="nx">getDerivedStateFromError</span> <span class="o">!==</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span>
  <span class="p">)</span> <span class="p">{</span>
    <span class="nx">nextChildren</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">enableProfilerTimer</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">stopProfilerTimerIfRunning</span><span class="p">(</span><span class="nx">workInProgress</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// 重新 render</span>
      <span class="nx">nextChildren</span> <span class="o">=</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">render</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="p">...</span>
</code></pre></div></div>

<p>好现在在回溯之前的问题:
给所有的  <code class="language-plaintext highlighter-rouge">Class</code> 组件包裹 <code class="language-plaintext highlighter-rouge">PureComponents</code> 合适吗？</p>
<blockquote>
  <p>其实与 上面给所有组件包裹 <code class="language-plaintext highlighter-rouge">memo</code> 的问题是一样的，甚至 <code class="language-plaintext highlighter-rouge">PureComponents</code> 默认比较某些情况性能还是比 <code class="language-plaintext highlighter-rouge">memo</code> 默认比较更差，比如100+的新旧 <code class="language-plaintext highlighter-rouge">props</code> 都相等时, <code class="language-plaintext highlighter-rouge">会遍历比较一次后又会遍历比较新旧state</code>, 倘若 <code class="language-plaintext highlighter-rouge">state</code> 也是100+ 呢？🤪</p>
</blockquote>

<h4 id="其他优化">其他优化</h4>

<p>项目中经常可以看到组件里写组件的方式，这里举例并不是说这样写不行，对于某些场景会有性能差异。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Item2</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Item2 is Mount</span><span class="dl">'</span><span class="p">)</span>
    <span class="p">},</span> <span class="p">[]);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Item2 is Render</span><span class="dl">'</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nx">Item</span><span class="o">------&lt;</span><span class="sr">/p</span><span class="err">&gt;
</span>    <span class="p">);</span>
  <span class="p">}</span>

<span class="kd">function</span> <span class="nx">App</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">data</span><span class="p">,</span> <span class="nx">setData</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">Item</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Item is Mount</span><span class="dl">'</span><span class="p">)</span>
    <span class="p">},</span> <span class="p">[]);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Item is Render</span><span class="dl">'</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nx">Item</span><span class="o">------&lt;</span><span class="sr">/p</span><span class="err">&gt;
</span>    <span class="p">);</span>
  <span class="p">}</span>
  
  <span class="k">return</span> <span class="p">(</span>
      <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
        <span class="p">{</span>
            <span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">({</span><span class="na">length</span><span class="p">:</span> <span class="mi">10</span><span class="p">}).</span><span class="nx">map</span><span class="p">((</span><span class="nx">_</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="o">&lt;</span><span class="nx">Item</span> <span class="nx">key</span><span class="o">=</span><span class="p">{</span><span class="nx">index</span><span class="p">}</span><span class="sr">/&gt;</span><span class="err">)
</span>        <span class="p">}</span>
        <span class="p">{</span>
            <span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">({</span><span class="na">length</span><span class="p">:</span> <span class="mi">10</span><span class="p">}).</span><span class="nx">map</span><span class="p">((</span><span class="nx">_</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="o">&lt;</span><span class="nx">Item2</span> <span class="nx">key</span><span class="o">=</span><span class="p">{</span><span class="nx">index</span><span class="p">}</span><span class="sr">/&gt;</span><span class="err">)
</span>        <span class="p">}</span>
        <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">hanldeClick</span><span class="p">}</span><span class="o">&gt;</span><span class="nx">莫碍老子</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>

<span class="o">--------------------</span>
<span class="nx">每当点击触发App更新时</span><span class="p">,</span> <span class="nx">打印输出如下</span>
<span class="nx">click</span> <span class="mi">1</span><span class="nx">次</span>
<span class="nx">print</span> <span class="o">-&gt;</span>
  <span class="nx">Item</span> <span class="nx">is</span> <span class="nx">Render</span>
  <span class="nx">Item2</span> <span class="nx">is</span> <span class="nx">Render</span>
  <span class="nx">Item2</span> <span class="nx">is</span> <span class="nx">Mount</span>
<span class="nx">click</span> <span class="mi">2</span><span class="nx">次</span>
<span class="nx">print</span> <span class="o">-&gt;</span>
  <span class="nx">Item</span> <span class="nx">is</span> <span class="nx">Render</span>
  <span class="nx">Item2</span> <span class="nx">is</span> <span class="nx">Render</span>
  <span class="nx">Item2</span> <span class="nx">is</span> <span class="nx">Mount</span>
  <span class="nx">Item</span> <span class="nx">is</span> <span class="nx">Render</span>
  <span class="nx">Item2</span> <span class="nx">is</span> <span class="nx">Render</span>
  <span class="nx">Item2</span> <span class="nx">is</span> <span class="nx">Mount</span>
</code></pre></div></div>

<p>每当点击时。你会发现每次 <code class="language-plaintext highlighter-rouge">Item</code> 组件内的 <code class="language-plaintext highlighter-rouge">useEffect</code> 都会重新执行， 而 <code class="language-plaintext highlighter-rouge">Item2</code> 组件不会这是为何？</p>
<ul>
  <li>唉最开始不是说，<code class="language-plaintext highlighter-rouge">App</code> 组件更新，子组件的 <code class="language-plaintext highlighter-rouge">JSX</code> 都会重新创建，导致内存地址不同，进而渲染子组件
    <ul>
      <li>按照这个逻辑来说，<code class="language-plaintext highlighter-rouge">Item</code> 与 <code class="language-plaintext highlighter-rouge">Item2</code> 组件不应该会有差异才对呀</li>
    </ul>
  </li>
  <li>看上去 <code class="language-plaintext highlighter-rouge">Item</code> 组件每次都初始化了一般，这是为何？</li>
</ul>

<p>这个解释起来有点麻烦，需要了解 <code class="language-plaintext highlighter-rouge">Diff</code> ， <code class="language-plaintext highlighter-rouge">Hooks 原理</code>以及 <code class="language-plaintext highlighter-rouge">commit渲染流</code>。</p>

<p>在 <code class="language-plaintext highlighter-rouge">reconcileChildrenArray</code> （也叫 <code class="language-plaintext highlighter-rouge">Array Diff</code>）-&gt; <code class="language-plaintext highlighter-rouge">updateSlot</code> -&gt; <code class="language-plaintext highlighter-rouge">updateElement</code>中 可以找到想要的答案。</p>

<pre><code class="language-javasript">function updateElement(
    returnFiber: Fiber,
    current: Fiber | null,
    element: ReactElement,
    lanes: Lanes,
  ): Fiber {
    if (current !== null) {
      if (
        current.elementType === element.type
      ) {
        // 克隆复用 Fiber
        const existing = useFiber(current, element.props);
        existing.ref = coerceRef(returnFiber, current, element);
        existing.return = returnFiber;
        return existing;
      } else if (enableBlocksAPI &amp;&amp; current.tag === Block) {
        ...
      }
    }
    // 重新创建 Fiber
    const created = createFiberFromElement(element, returnFiber.mode, lanes);
    created.ref = coerceRef(returnFiber, current, element);
    created.return = returnFiber;
    return created;
  }
</code></pre>

<p>上面只需要留意 <code class="language-plaintext highlighter-rouge">current.elementType === element.type</code></p>
<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">current</code> 表示旧的 <code class="language-plaintext highlighter-rouge">Fiber</code> 单元， <code class="language-plaintext highlighter-rouge">element</code> 也就是最开始介绍过的 <code class="language-plaintext highlighter-rouge">JSX</code> 对象，那么这个逻辑就表示判断 Item 组件引用地址，如果相同克隆复用 <code class="language-plaintext highlighter-rouge">Fiber</code>, 不同便会新增 <code class="language-plaintext highlighter-rouge">Fiber</code>;</p>
  </li>
  <li>
    <p>而对于 <code class="language-plaintext highlighter-rouge">hooks</code> 分为俩个阶段，首次渲染初始化创建 <code class="language-plaintext highlighter-rouge">hooks</code> 链表，以及 <code class="language-plaintext highlighter-rouge">update</code> 阶段移动链表获取当前每个对应的 <code class="language-plaintext highlighter-rouge">hook</code> 计算结果。而 <code class="language-plaintext highlighter-rouge">hooks</code> 链表被挂载在组件的 <code class="language-plaintext highlighter-rouge">Fiber</code> 上。
因此当重新创建 <code class="language-plaintext highlighter-rouge">Fiber</code> 时，上次初始化的 <code class="language-plaintext highlighter-rouge">hooks</code> 链表并没有得到保留，进而 <code class="language-plaintext highlighter-rouge">renderWithHooks</code> 再次进入执行 <code class="language-plaintext highlighter-rouge">Item</code> 组件时，任然是创建 <code class="language-plaintext highlighter-rouge">Hooks链表</code>，<code class="language-plaintext highlighter-rouge">commit</code> 阶段调度 （这里后续文章会说明）。</p>
  </li>
  <li>
    <p>这也就解释了为什么 <code class="language-plaintext highlighter-rouge">Item</code> 组件会每次都会执行 <code class="language-plaintext highlighter-rouge">useEffect</code> 回调，这里差异化除了创建 <code class="language-plaintext highlighter-rouge">Fiber</code> 的开销外，如果存在 <code class="language-plaintext highlighter-rouge">Hooks</code> 还有 <code class="language-plaintext highlighter-rouge">Hooks</code> 链表每次创建的开销。</p>
  </li>
</ul>

<h5 id="把逻辑全套在setdata会有什么问题">把逻辑全套在setData会有什么问题？</h5>

<p>可能会觉得不会有影响，因为执行点击回调时
从点击到视图改变时间维度不会因为你将逻辑抽离而改变，不过是逻辑执行时机的改变：</p>
<ul>
  <li>一个是点击回调执行逻辑后设置值。</li>
  <li>一个是传入回调后到 <code class="language-plaintext highlighter-rouge">renderWithHooks</code>， 调用 <code class="language-plaintext highlighter-rouge">App component</code>, <code class="language-plaintext highlighter-rouge">hooks update</code> 计算值的差别。 
emmm, 你这说确实没错，倘若你开启了并发模式，那便会有差异了（可以想想）</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 举个栗子</span>
<span class="c1">// 如果一个hooks 有多个update 单元</span>
<span class="c1">// 这里的lang 表示优先级, action 表示对应需要计算的值</span>
<span class="nx">hooks</span> <span class="o">-&gt;</span> <span class="nx">queue</span> <span class="o">-&gt;</span> 
              <span class="nx">update1</span> <span class="o">-&gt;</span> <span class="nx">update2</span> <span class="o">-&gt;</span>             <span class="nx">update3</span>
              <span class="nx">lang</span><span class="o">=</span><span class="mi">3</span>     <span class="nx">lang</span><span class="o">=</span><span class="mi">1</span>                 <span class="nx">lang</span><span class="o">=</span><span class="mi">3</span>
              <span class="nx">action</span><span class="o">=</span><span class="mi">1</span>   <span class="nx">action</span><span class="o">=</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">d</span> <span class="o">+</span> <span class="mi">1</span>    <span class="nx">action</span><span class="o">=</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="mi">100</span><span class="o">+</span><span class="nx">more</span>

<span class="c1">// 可以看到 update3 为逻辑回调 </span>
<span class="c1">// 假设当前渲染优先级为3, 那么本次满足条件应该执行的是 update1 + update3</span>

<span class="nx">遍历update链表</span>
<span class="nx">update1</span> <span class="o">-&gt;</span> <span class="nx">update2</span> <span class="o">-&gt;</span> <span class="nx">update3</span>
  <span class="mi">1</span>
  <span class="o">^</span>
<span class="nx">update1满足渲染条件</span>
<span class="nx">newState</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nx">newBaseState</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="nx">update1</span> <span class="o">-&gt;</span> <span class="nx">update2</span> <span class="o">-&gt;</span> <span class="nx">update3</span>
            <span class="nx">d</span> <span class="o">=&gt;</span> <span class="nx">d</span> <span class="o">+</span> <span class="mi">1</span>
              <span class="o">^</span>
<span class="nx">update2不满足渲染条件</span>
<span class="nx">baseFirst</span> <span class="o">=</span> <span class="nx">update2</span>
<span class="nx">newState</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nx">newBaseState</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>


<span class="nx">update1</span> <span class="o">-&gt;</span> <span class="nx">update2</span> <span class="o">-&gt;</span> <span class="nx">update3</span>
                      <span class="nx">d</span> <span class="o">=&gt;</span> <span class="mi">100</span><span class="nx">more</span>
                        <span class="o">^</span>
<span class="nx">update3满足渲染条件</span>
<span class="nx">baseFirst</span> <span class="o">=</span> <span class="nx">update2</span> <span class="o">-&gt;</span> <span class="nx">update3</span>
<span class="nx">newState</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="mi">100</span><span class="nx">more</span> <span class="nx">的结果</span><span class="p">;</span>
<span class="nx">newBaseState</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="nx">那么页面上data会暂时展示</span> <span class="nx">newState的结果</span><span class="err">。</span>
<span class="nx">下次更新会执行上次跳过的链表以newBaseState为基准</span><span class="p">,</span> <span class="nx">baseFirst</span><span class="err">（</span><span class="nx">update2</span> <span class="o">-&gt;</span> <span class="nx">update3</span><span class="err">）</span>
<span class="nx">因此你会发现</span><span class="err">，</span><span class="nx">update3</span> <span class="nx">这个逻辑回调单元被执行计算了俩次</span>
</code></pre></div></div>

<p>至于hooks链表计算详细流程有机会后续文章补充😎</p>

<h4 id="usecontent-不正当使用">useContent 不正当使用</h4>

<p>这里给个结论，具体参考 <code class="language-plaintext highlighter-rouge">useContent</code> 章节;
当上下文更新时会额外深度优先遍历 <code class="language-plaintext highlighter-rouge">Fiber</code> 匹配消费者的 <code class="language-plaintext highlighter-rouge">Context</code>, 因此当 <code class="language-plaintext highlighter-rouge">Provider</code> 嵌套的内容越多（比如根元素上），遍历的成本就越高；组件内耦合使用更为合适。</p>

<p><strong>那么有什么合适的方式大范围传值呢?</strong></p>

<p>用过 <code class="language-plaintext highlighter-rouge">Vue</code> 的同学都知道 <code class="language-plaintext highlighter-rouge">MVVM</code> 的原理，对属性进行劫持，在 <code class="language-plaintext highlighter-rouge">VNode</code> 创建阶段获取属性，为其添加对应组件的 <code class="language-plaintext highlighter-rouge">updateComponent</code>，属性更新 <code class="language-plaintext highlighter-rouge">setter</code> 调度任务执行 <code class="language-plaintext highlighter-rouge">updateComponent</code> 创建 <code class="language-plaintext highlighter-rouge">VNode Tree</code> 比较更新视图。</p>

<p>通过结合 <code class="language-plaintext highlighter-rouge">Proxy</code>， 就可以再状态变更时收集所有的消费者，批量更新 （市面上也有相关的库自行了解）。</p>

<p><strong>小demo</strong></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Store</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">data</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">promise</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">();</span>
    <span class="kd">let</span> <span class="nx">lineComponent</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">forceUpdate</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">updateMap</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="p">{</span>
      <span class="kd">get</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">prop</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">componentMap</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">componentMap</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">lineComponent</span><span class="p">))</span> <span class="p">{</span>
                <span class="kd">let</span> <span class="nx">list</span> <span class="o">=</span> <span class="nx">componentMap</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">lineComponent</span><span class="p">);</span>
                <span class="nx">list</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">prop</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nx">componentMap</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">lineComponent</span><span class="p">,</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">([</span><span class="nx">prop</span><span class="p">]));</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">prop</span><span class="p">];</span>
      <span class="p">},</span>
      <span class="na">set</span><span class="p">:</span> <span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">target</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">value</span> <span class="o">&amp;&amp;</span> <span class="nx">updateMap</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">updateMap</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="p">[</span><span class="nx">target</span><span class="p">[</span><span class="nx">key</span><span class="p">],</span> <span class="nx">value</span><span class="p">])</span>
            <span class="nx">target</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">});</span>
    <span class="kd">let</span> <span class="nx">componentMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">useUpdate</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">useUpdate</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="p">[</span><span class="nx">_</span><span class="p">,</span> <span class="kd">set</span><span class="p">]</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">forceUpdate</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="kd">set</span><span class="p">(</span><span class="nx">a</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">return</span> <span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="nx">updateMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>
            <span class="nx">proxy</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">val</span><span class="p">;</span>
            <span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">forceUpdate</span><span class="p">);</span>
        <span class="p">};</span>
    <span class="p">}</span>
  
    <span class="k">this</span><span class="p">.</span><span class="nx">useStore</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">cb</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">cb</span><span class="p">(</span><span class="nx">proxy</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">Provider</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">Provider</span><span class="p">({</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">children</span> <span class="p">})</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">(</span>
        <span class="o">&lt;&gt;</span>
          <span class="p">{</span> <span class="nx">children</span> <span class="p">}</span>
        <span class="o">&lt;</span><span class="sr">/</span><span class="err">&gt;
</span>      <span class="p">);</span>
    <span class="p">}</span>
    
    <span class="kd">let</span> <span class="nx">defaultEqual</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">equal</span><span class="p">,</span> <span class="nx">prev</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">list</span> <span class="o">=</span> <span class="nx">componentMap</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">lineComponent</span><span class="p">)</span> <span class="o">||</span> <span class="p">[];</span>
        
        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="k">of</span> <span class="nx">list</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">updateMap</span> <span class="o">&amp;&amp;</span> <span class="nx">updateMap</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">equal</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">equal</span><span class="p">(</span><span class="nx">prev</span><span class="p">,</span> <span class="nx">next</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="k">in</span> <span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">is</span><span class="p">(</span><span class="nx">next</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">prev</span><span class="p">[</span><span class="nx">i</span><span class="p">]))</span> <span class="p">{</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">Component</span> <span class="o">=</span> <span class="p">(</span><span class="nx">callback</span><span class="p">,</span> <span class="nx">equal</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">id</span><span class="o">+=</span><span class="mi">1</span><span class="p">;</span>
      <span class="nx">lineComponent</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
      <span class="kd">let</span> <span class="nx">JSX</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">memo</span><span class="p">(</span><span class="nx">callback</span><span class="p">,</span> <span class="nx">defaultEqual</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">equal</span><span class="p">));</span>
      <span class="nx">lineComponent</span> <span class="o">=</span> <span class="nx">JSX</span><span class="p">.</span><span class="nx">type</span><span class="p">;</span>
      <span class="k">return</span> <span class="nx">JSX</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>使用</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">store</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Store</span><span class="p">({</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">wujie</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">age</span><span class="p">:</span> <span class="dl">'</span><span class="s1">2-</span><span class="dl">'</span>
<span class="p">})</span>

<span class="kd">const</span> <span class="nx">Demo</span> <span class="o">=</span> <span class="nx">store</span><span class="p">.</span><span class="nx">Component</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="p">{</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">age</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">store</span><span class="p">.</span><span class="nx">useStore</span><span class="p">((</span><span class="nx">data</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span>
        <span class="na">name</span><span class="p">:</span> <span class="nx">data</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span>
        <span class="na">age</span><span class="p">:</span> <span class="nx">data</span><span class="p">.</span><span class="nx">age</span>
    <span class="p">}));</span>
    <span class="kd">let</span> <span class="kd">set</span> <span class="o">=</span> <span class="nx">store</span><span class="p">.</span><span class="nx">useUpdate</span><span class="p">();</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="kd">set</span><span class="p">(</span><span class="dl">'</span><span class="s1">name</span><span class="dl">'</span><span class="p">,</span><span class="mi">11</span><span class="p">)</span>
            <span class="kd">set</span><span class="p">(</span><span class="dl">'</span><span class="s1">name</span><span class="dl">'</span><span class="p">,</span><span class="mi">33</span><span class="p">)</span>
            <span class="kd">set</span><span class="p">(</span><span class="dl">'</span><span class="s1">age</span><span class="dl">'</span><span class="p">,</span><span class="mi">50</span><span class="p">)</span>
        <span class="p">}}</span><span class="o">&gt;</span><span class="nx">data</span> <span class="o">---</span> <span class="p">{</span> <span class="nx">name</span> <span class="p">}</span><span class="o">--</span><span class="p">{</span><span class="nx">age</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>    <span class="p">);</span>
<span class="p">})</span>

<span class="kd">const</span> <span class="nx">root</span> <span class="o">=</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">store</span><span class="p">.</span><span class="nx">Provider</span><span class="o">&gt;</span>
        <span class="p">{</span>
            <span class="nx">React</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
                <span class="kd">let</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">]</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
                <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">render.....</span><span class="dl">'</span><span class="p">)</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
                        <span class="o">&lt;</span><span class="nx">p</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="nx">b</span><span class="p">(</span><span class="nx">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)}</span><span class="o">&gt;</span><span class="nx">a</span><span class="o">---</span><span class="p">{</span><span class="nx">a</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/p</span><span class="err">&gt;
</span>                        <span class="o">&lt;</span><span class="nx">Demo</span><span class="o">/&gt;</span>
                    <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>                <span class="p">);</span>
            <span class="p">})</span>
        <span class="p">}</span>
    <span class="o">&lt;</span><span class="sr">/store.Provider</span><span class="err">&gt;
</span><span class="p">)</span>
</code></pre></div></div>]]></content><author><name>scriptoverture</name></author><category term="React" /><summary type="html"><![CDATA[React 性能优化]]></summary></entry><entry><title type="html">原型与原型链</title><link href="https://scriptoverture.github.io/blog/2024/09/12/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/" rel="alternate" type="text/html" title="原型与原型链" /><published>2024-09-12T00:00:00+00:00</published><updated>2024-09-12T00:00:00+00:00</updated><id>https://scriptoverture.github.io/blog/2024/09/12/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE</id><content type="html" xml:base="https://scriptoverture.github.io/blog/2024/09/12/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"><![CDATA[<h3 id="什么是原型">什么是原型</h3>

<p>原型在开发中无处不在，在深入介绍原型之前，我们先了解一下对象的基本概念。
这里先将对象理解为数据和行为的集合。开发中，很多时候会希望对象能够“共享”“复用”某些行为，这就引入了“原型”的概念。</p>

<p>为了更直观地理解原型和原型链，我们暂时抛开 <code class="language-plaintext highlighter-rouge">JavaScript</code> 的具体语法，使用伪代码来描述对象的定义、继承和复用的过程。</p>

<h4 id="定义结构与行为">定义结构与行为</h4>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Element</span> <span class="nx">结构</span><span class="p">:</span>
    <span class="o">-</span> <span class="nx">child</span><span class="p">:</span> <span class="kc">null</span>
    <span class="o">-</span> <span class="nx">parent</span><span class="p">:</span> <span class="kc">null</span>


<span class="nx">ElementFunctions</span> <span class="nx">方法结构</span><span class="p">:</span>
    <span class="o">-</span> <span class="nx">append</span><span class="p">(</span><span class="nx">方法</span><span class="p">)</span>


<span class="nx">Text</span> <span class="nx">结构</span><span class="p">:</span>
    <span class="o">-</span> <span class="nx">child</span><span class="p">:</span> <span class="kc">null</span>
    <span class="o">-</span> <span class="nx">parent</span><span class="p">:</span> <span class="kc">null</span>
    <span class="o">-</span> <span class="nx">classList</span><span class="p">:</span> <span class="p">[]</span>
    <span class="o">-</span> <span class="nx">更多属性</span><span class="p">...</span>
</code></pre></div></div>

<p>上面伪代码定义了三个个结构对象</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Element</code> 结构 包含子元素和父元素</li>
  <li><code class="language-plaintext highlighter-rouge">ElementFunctions</code> 方法结构（描述 <code class="language-plaintext highlighter-rouge">Element</code> 结构 可以产生的行为）
    <ul>
      <li>比如 “追加元素”，“修改属性” 等方法。</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Text</code> 结构，在 <code class="language-plaintext highlighter-rouge">Element</code> 结构上又增加了一些属性。</li>
</ul>

<h4 id="关联对象与方法">关联对象与方法</h4>

<p>为了让 <code class="language-plaintext highlighter-rouge">Element</code> 能够调用 <code class="language-plaintext highlighter-rouge">ElementFunctions</code> 中的方法。
这里把 <code class="language-plaintext highlighter-rouge">ElementFunctions</code> 与 <code class="language-plaintext highlighter-rouge">Element</code> 对象建立关联，使其能够访问这些方法：
<strong>JavaScript 中通过（<code class="language-plaintext highlighter-rouge">__proto__</code>）属性用来实现这一目的的。</strong></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Element</span> <span class="nx">关联</span> <span class="nx">ElementFunctions</span>

<span class="nx">element</span> <span class="o">=</span> <span class="nx">Element</span> <span class="p">{</span> <span class="nl">child</span><span class="p">:</span> <span class="p">...,</span> <span class="nx">parent</span><span class="p">:</span> <span class="p">...</span> <span class="p">};</span>
<span class="nx">element</span><span class="p">.</span><span class="nx">append</span><span class="p">(...);</span>
</code></pre></div></div>

<h4 id="继承扩展">“继承扩展”</h4>

<p>为了让 <code class="language-plaintext highlighter-rouge">Test</code> 可以访问 <code class="language-plaintext highlighter-rouge">Element</code> 的方法, 我们需要实现一种继承机制。
可以将 <code class="language-plaintext highlighter-rouge">ElementFunctions</code> 关联到 <code class="language-plaintext highlighter-rouge">Text</code> 对象 如示例1。</p>

<p>示例 1：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Text</span> <span class="nx">内联</span> <span class="nx">ElementFunctions</span>
<span class="nx">text</span> <span class="o">=</span> <span class="nx">Text</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
<span class="nx">text</span><span class="p">.</span><span class="nx">append</span><span class="p">(...);</span>
</code></pre></div></div>

<p>同样的也可以将 <code class="language-plaintext highlighter-rouge">ElementFunctions</code> 关联到 <code class="language-plaintext highlighter-rouge">Element</code> 结构。
<code class="language-plaintext highlighter-rouge">Element</code> 结构再关联 <code class="language-plaintext highlighter-rouge">Text</code>结构，从而访问方法。</p>

<p>示例 2：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Element</span> <span class="nx">内联</span> <span class="nx">ElementFunctions</span>

<span class="nx">Text</span> <span class="nx">内联</span> <span class="nx">Element</span>
<span class="nx">text</span> <span class="o">=</span> <span class="nx">Text</span> <span class="p">{</span> <span class="nx">classList</span> <span class="p">};</span>
<span class="nx">text</span><span class="p">.</span><span class="nx">append</span><span class="p">(...);</span>
</code></pre></div></div>

<p>这些结构之间的关系可以用树状图来表示：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    <span class="nx">示例</span> <span class="mi">1</span><span class="err">：</span>
       <span class="nx">ElementFunctions</span> <span class="nx">结构</span>
        <span class="o">|</span>         <span class="o">|</span>
       <span class="nx">Text</span>     <span class="nx">Element</span> 

    <span class="nx">示例</span> <span class="mi">2</span><span class="p">:</span>
        <span class="nx">ElementFunctions</span> <span class="nx">结构</span>
                <span class="o">|</span>
              <span class="nx">Element</span>
                <span class="o">|</span>
               <span class="nx">Text</span> 
</code></pre></div></div>

<p>你有看出示例1和示例2的差异吗？</p>

<p>回看上面的伪代码示例:</p>
<ul>
  <li>上面 <code class="language-plaintext highlighter-rouge">结构</code> 都可以理解为 <code class="language-plaintext highlighter-rouge">js</code> 中的对象。</li>
  <li>关联操作对应 <code class="language-plaintext highlighter-rouge">js</code> 原型对象指向。
    <ul>
      <li>示例2 来讲：<code class="language-plaintext highlighter-rouge">Text</code> 的原型对象 就是 <code class="language-plaintext highlighter-rouge">Element</code> 对象。</li>
      <li>关联等价 <code class="language-plaintext highlighter-rouge">“继承”</code></li>
    </ul>
  </li>
  <li>每个结构都能被当做一个 “基类”，可以被其他结构继承， 或者继承其他结构。</li>
</ul>

<p>下面会进行验证。</p>

<h4 id="对象原型">对象原型</h4>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object_prototypes">MDN 解释</a></p>
<ul>
  <li>原型是 <code class="language-plaintext highlighter-rouge">JavaScript</code> 对象相互继承特性的一种机制</li>
  <li><code class="language-plaintext highlighter-rouge">JavaScript</code> 中所有的对象都有一个内置属性，称为它的原型（原型）。</li>
  <li>原型对象也有它自己的原型，逐渐构成了原型链路。原型链终止于拥有 <code class="language-plaintext highlighter-rouge">null</code> 作为其原型的对象上。</li>
</ul>

<p>再回头看看伪代码的示例2</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Text</code> 对象， 通过内置属性指向 <code class="language-plaintext highlighter-rouge">Element</code> 对象。
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Text</code> 对象的原型是 <code class="language-plaintext highlighter-rouge">Element</code> 对象。</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Element</code> 对象， 通过内置属性指向 <code class="language-plaintext highlighter-rouge">ElementFunctions</code> 对象。
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Element</code> 对象的原型是 <code class="language-plaintext highlighter-rouge">ElementFunctions</code> 对象。</li>
    </ul>
  </li>
  <li>他们通过 <code class="language-plaintext highlighter-rouge">__proto__</code>（原型）链接成了一条链表。</li>
  <li><code class="language-plaintext highlighter-rouge">Text</code> 对象调用 <code class="language-plaintext highlighter-rouge">ElementFunctions</code> 对象方法就是链表查找过程。</li>
</ul>

<p>举例说明：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    <span class="kd">let</span> <span class="nx">ElementFunctions</span> <span class="o">=</span> <span class="p">{</span>
        <span class="na">append</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">print!!</span><span class="dl">"</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="kd">let</span> <span class="nx">Element</span> <span class="o">=</span> <span class="p">{</span> <span class="na">child</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span> <span class="na">parent</span><span class="p">:</span> <span class="kc">null</span> <span class="p">};</span>

    <span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">Element</span><span class="p">,</span> <span class="nx">ElementFunctions</span><span class="p">);</span>

    <span class="kd">let</span> <span class="nx">Text</span> <span class="o">=</span> <span class="p">{};</span>

    <span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">Text</span><span class="p">,</span> <span class="nx">Element</span><span class="p">);</span>

    <span class="nx">Text</span><span class="p">.</span><span class="nx">append</span><span class="p">();</span> <span class="c1">// print!!</span>

    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">Text</span><span class="p">)</span> <span class="o">===</span> <span class="nx">Element</span><span class="p">);</span>             <span class="c1">// true</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">Element</span><span class="p">)</span> <span class="o">===</span> <span class="nx">ElementFunctions</span><span class="p">);</span> <span class="c1">// true</span>
</code></pre></div></div>

<p><em>注意</em><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf">Object.setPrototypeOf</a> 官方并不建议项目中使用动态修改原型链性能很差， 后面会说明。
<code class="language-plaintext highlighter-rouge">Object.getPrototypeOf</code>: 获取原型 等价于 <code class="language-plaintext highlighter-rouge">target.__proto__</code></p>

<h4 id="函数原型">函数原型</h4>

<ol>
  <li>
    <p><strong>原型对象 (prototype)</strong>
函数 <code class="language-plaintext highlighter-rouge">prototype</code> 属性通常是一个对象，它被用作该函数创建的实例的原型。
使用 <code class="language-plaintext highlighter-rouge">new</code> 运算符调用一个函数新的对象时，该对象的原型被设置为该函数的 <code class="language-plaintext highlighter-rouge">prototype</code> 属性。</p>
  </li>
  <li>
    <p><strong>构造函数</strong>
<code class="language-plaintext highlighter-rouge">prototype</code> 对象上通常会有一个 <code class="language-plaintext highlighter-rouge">constructor</code> 属性，这个属性指向函数对象本身。
例如：<code class="language-plaintext highlighter-rouge">Test.prototype.constructor</code> 会指向 <code class="language-plaintext highlighter-rouge">Test</code> 函数本身。</p>
  </li>
  <li>
    <p><strong>特殊情况</strong>
大部分函数都拥有 <code class="language-plaintext highlighter-rouge">prototype</code> 属性，下面函数不拥有 <code class="language-plaintext highlighter-rouge">prototype</code> 属性。</p>
    <ul>
      <li>箭头函数, 不能被 <code class="language-plaintext highlighter-rouge">new</code> 实例化 (执行上下文中展开)</li>
      <li><code class="language-plaintext highlighter-rouge">bind</code> 函数, 但是可能是可构造的。当它被构造的时候，目标函数将会被构造，如果目标函数是可构造的，将会返回一个普通的实例。</li>
    </ul>
  </li>
</ol>

<p>举个例子</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Test</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">data</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 为 Test 构造函数的原型对象添加一个方法</span>
<span class="nx">Test</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">fn</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Hello, world!</span><span class="dl">"</span><span class="p">);</span> <span class="p">}</span>

<span class="c1">// 创建一个 Test 实例</span>
<span class="kd">let</span> <span class="nx">test</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Test</span><span class="p">();</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">test</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nx">Test</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>   <span class="c1">// true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Test</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">===</span> <span class="nx">Test</span><span class="p">);</span>           <span class="c1">// true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Test</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">===</span> <span class="nx">Test</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="kd">constructor</span><span class="p">);</span><span class="c1">// true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">test</span> <span class="k">instanceof</span> <span class="nx">Test</span><span class="p">);</span>                <span class="c1">// true</span>

<span class="nx">test</span><span class="p">.</span><span class="nx">fn</span><span class="p">();</span> <span class="c1">// 输出: "Hello, world!"</span>
</code></pre></div></div>
<p>在上面的例子中：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Test.prototype</code> 的原型上挂载 <code class="language-plaintext highlighter-rouge">fn</code> 方法。</li>
  <li><code class="language-plaintext highlighter-rouge">test</code> 实例原型指向 <code class="language-plaintext highlighter-rouge">Test.prototype</code>
    <ul>
      <li>因此 <code class="language-plaintext highlighter-rouge">test</code> 实例可以调用 <code class="language-plaintext highlighter-rouge">fn</code></li>
      <li>自然 <code class="language-plaintext highlighter-rouge">Test.constructor</code> 等于 <code class="language-plaintext highlighter-rouge">Test.prototype.constructor</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Test</code> 等价 <code class="language-plaintext highlighter-rouge">Class Test{ fn }</code> 的语法糖
    <ul>
      <li><code class="language-plaintext highlighter-rouge">class</code> 只是一个语法糖，本质上仍然是使用原型机制</li>
    </ul>
  </li>
</ul>

<p>再观察下面的示例：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="kd">constructor</span><span class="p">);</span> <span class="c1">// Object</span>

<span class="kd">const</span> <span class="nx">o2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">o2</span><span class="p">.</span><span class="kd">constructor</span><span class="p">);</span>  <span class="c1">// Object</span>
</code></pre></div></div>

<p>之前说过 <strong>prototype 对象上通常会有一个 constructor 属性</strong></p>
<blockquote>
  <p>除了null原型对象之外，任何对象都会在其[[Prototype]]上有一个constructor属性。</p>
</blockquote>

<ul>
  <li>而 <code class="language-plaintext highlighter-rouge">obj字面量</code> 也存在 <code class="language-plaintext highlighter-rouge">constructor</code>，并且 <code class="language-plaintext highlighter-rouge">constructor</code> 指向 <code class="language-plaintext highlighter-rouge">Object</code>方法;</li>
  <li>换句话说，<code class="language-plaintext highlighter-rouge">obj字面量</code> 是<code class="language-plaintext highlighter-rouge">new Object</code> 构造函数的实例</li>
  <li>字面量对象等价于 <code class="language-plaintext highlighter-rouge">new Object</code> 的语法糖</li>
</ul>

<p><strong>函数原型的继承</strong></p>

<p>因为 函数prototype 大多数也是对象，对象可以依靠__proto__继承。
实例指向 函数prototype， 变相实现构造函数的继承。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">function</span> <span class="nx">Test</span><span class="p">()</span> <span class="p">{}</span>
<span class="kd">let</span> <span class="nx">data</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">ElementFunctions</span><span class="p">);</span>
<span class="nx">data</span><span class="p">.</span><span class="nx">fn</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Hello, world!</span><span class="dl">"</span><span class="p">);</span> <span class="p">}</span>
<span class="nx">Test</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>

<span class="kd">let</span> <span class="nx">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Test</span><span class="p">();</span>
<span class="nx">t</span><span class="p">.</span><span class="nx">append</span><span class="p">();</span> 

<span class="c1">// 或者</span>
<span class="kd">function</span> <span class="nx">testfn</span><span class="p">()</span> <span class="p">{}</span>
<span class="nx">testfn</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">ElementFunctions</span><span class="p">);</span>
<span class="kd">class</span> <span class="nx">Test</span> <span class="kd">extends</span> <span class="nx">testfn</span> <span class="p">{</span>
    <span class="nx">fn</span><span class="p">()</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Hello, world!</span><span class="dl">"</span><span class="p">);</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Test</span><span class="p">();</span>
<span class="nx">t</span><span class="p">.</span><span class="nx">append</span><span class="p">();</span>
</code></pre></div></div>

<h3 id="原型链">原型链</h3>

<p>原型链是 <code class="language-plaintext highlighter-rouge">JavaScript</code> 中对象属性查找的机制。当访问一个对象的属性时，如果该属性不存在于当前对象上，<code class="language-plaintext highlighter-rouge">JavaScript</code> 会沿着该对象的原型链向上查找，直到找到该属性或者到达 <code class="language-plaintext highlighter-rouge">null</code>。</p>

<p>下面的示例演示了如何查看 <code class="language-plaintext highlighter-rouge">Text</code> 对象的原型链：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">// 查看 Text 的原型链</span>
<span class="kd">let</span> <span class="nx">next</span> <span class="o">=</span> <span class="nx">Text</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">next</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">next</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">next</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>打印：</p>
<ul>
  <li>{child: null, parent: null}</li>
  <li>{append: ƒ}</li>
  <li>{<strong>defineGetter</strong>: ƒ, <strong>defineSetter</strong>: ƒ, hasOwnProperty: ƒ, <strong>lookupGetter</strong>: ƒ, <strong>lookupSetter</strong>: ƒ, …}</li>
  <li>null</li>
</ul>

<blockquote>
  <p>注意：原型链的终点是 null，表示达到了 JavaScript 的根对象。</p>
</blockquote>

<h3 id="性能问题">性能问题</h3>

<p>再了解原型链的查找过程后，可能意识到某些场景下查找对象属性可能会带来性能开销。</p>

<h4 id="使用typescript-辅助开发">使用Typescript 辅助开发</h4>

<p>对于原型链过长导致性能问题。来看一个示例：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">o100</span> <span class="o">=</span> <span class="p">{}</span>
<span class="p">...</span><span class="mi">98</span>
<span class="kd">let</span> <span class="nx">o1</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">o1</span><span class="p">,</span> <span class="nx">o100</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">o1</span><span class="p">.</span><span class="nx">test</span><span class="p">);</span> <span class="c1">// null</span>
</code></pre></div></div>

<p>在上述代码中，<code class="language-plaintext highlighter-rouge">o1</code> 的原型链长度为 100。当我们访问 <code class="language-plaintext highlighter-rouge">o1.test</code> 时，由于 <code class="language-plaintext highlighter-rouge">o1</code> 本身没有 <code class="language-plaintext highlighter-rouge">test</code> 属性，<code class="language-plaintext highlighter-rouge">JavaScript</code> 会沿着它的原型链向上查找直到终点 <code class="language-plaintext highlighter-rouge">null</code>。</p>

<p>因而使用类型机制，可以在编译时规避无效属性，进而抹去无效属性查找开销。</p>

<h4 id="减少不必要的原型链层级">减少不必要的原型链层级</h4>
<p>尽可能减少原型链的层级，可以提高查找性能。
以下示例通过优化 <code class="language-plaintext highlighter-rouge">Element</code> 和 <code class="language-plaintext highlighter-rouge">Text</code> 对象的原型关系来减少层级：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">let</span> <span class="nx">Text</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">ClasssList</span><span class="p">,</span> <span class="p">...</span> <span class="p">};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span>
    <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">ElementFunctions</span><span class="p">),</span>
    <span class="nx">Text</span>
<span class="p">);</span>

<span class="nx">Text</span><span class="p">.</span><span class="nx">append</span><span class="p">(...);</span>
</code></pre></div></div>

<p>在上面的代码中，<code class="language-plaintext highlighter-rouge">Text</code> 继承 <code class="language-plaintext highlighter-rouge">ElementFunctions</code>，而非 <code class="language-plaintext highlighter-rouge">Element</code> 对象，减少了原型链的层级数。</p>

<p><strong>注意：</strong></p>
<ul>
  <li>这种操作需要确保 <code class="language-plaintext highlighter-rouge">Text</code> 对象的属性能够满足 <code class="language-plaintext highlighter-rouge">ElementFunctions</code> 中方法的依赖。例如，<code class="language-plaintext highlighter-rouge">append</code> 方法可能需要 <code class="language-plaintext highlighter-rouge">parent</code> 属性。</li>
  <li>如果你希望通过原型链调用 <code class="language-plaintext highlighter-rouge">append</code> 方法，确保对象本身或原型链上的某个对象存在 <code class="language-plaintext highlighter-rouge">parent</code> 属性（如继承自 <code class="language-plaintext highlighter-rouge">Element</code>）。</li>
</ul>

<h4 id="规避动态更改原型">规避动态更改原型</h4>

<p>动态更改对象的原型（如使用 <code class="language-plaintext highlighter-rouge">Object.setPrototypeOf</code>）会导致性能问题，详细可了解 <a href="https://mathiasbynens.be/notes/prototypes">v8对于prototype优化</a></p>

<p>为了加快后续原型加载的速度，<code class="language-plaintext highlighter-rouge">V8</code> 引擎使用了内联缓存（<code class="language-plaintext highlighter-rouge">Inline Cache</code>）。该缓存有四个字段：</p>
<ul>
  <li>属性在原型中找到的偏移量。</li>
  <li>找到该属性的原型。</li>
  <li>实例的形状。</li>
  <li>从实例形状链接到的直接原型的 <code class="language-plaintext highlighter-rouge">ValidityCell</code>。</li>
</ul>

<p>当内联缓存首次命中时，<code class="language-plaintext highlighter-rouge">V8</code> 会记住这些信息。下次访问时，如果形状和 <code class="language-plaintext highlighter-rouge">ValidityCell</code> 仍然有效，<code class="language-plaintext highlighter-rouge">V8</code> 可以直接访问缓存中的属性，跳过额外的查找。</p>

<p>但如果动态更改了原型（如 <code class="language-plaintext highlighter-rouge">Object.setPrototypeOf</code>），会分配一个新的形状，这样旧的 <code class="language-plaintext highlighter-rouge">ValidityCell</code> 失效，内联缓存也会失效，导致性能下降。因此，避免动态更改原型可以显著提升性能。</p>

<h3 id="结语">结语</h3>

<p>不知道你有没有察觉，前面说过的原型意味着“继承”对象属性，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是：</p>

<blockquote>
  <p>继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。</p>
</blockquote>

<h3 id="参考">参考</h3>

<ul>
  <li><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object_prototypes">MDN 对象原型</a></li>
  <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf">MDN setPrototypeOf</a></li>
  <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/prototype">Function prototype</a></li>
  <li><a href="https://mathiasbynens.be/notes/prototypes">V8 prototypes 优化</a></li>
</ul>

<!-- setPrototypeOf -->

<!-- Function prototype -->

<!-- v8 prototypes -->

<!-- new -->]]></content><author><name>scriptoverture</name></author><category term="JavaScript" /><summary type="html"><![CDATA[原型与原型链深入理解]]></summary></entry><entry><title type="html">什么是闭包?</title><link href="https://scriptoverture.github.io/blog/2024/09/02/%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85/" rel="alternate" type="text/html" title="什么是闭包?" /><published>2024-09-02T00:00:00+00:00</published><updated>2024-09-02T00:00:00+00:00</updated><id>https://scriptoverture.github.io/blog/2024/09/02/%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85</id><content type="html" xml:base="https://scriptoverture.github.io/blog/2024/09/02/%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85/"><![CDATA[<h3 id="什么是闭包-closures">什么是闭包 (Closures)</h3>

<p><em>在讨论闭包之前，首先看看<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures">官方介绍</a></em></p>
<blockquote>
  <p><strong>闭包（closure）是一个函数以及其捆绑的周边环境状态（lexical environment，词法环境）的引用的组合</strong>。换而言之，闭包让开发者可以从内部函数访问外部函数的作用域。在 JavaScript 中，闭包会随着函数的创建而被同时创建。</p>
</blockquote>

<p>从定义中可以看到，闭包和词法环境（ <code class="language-plaintext highlighter-rouge">lexical environment</code> ）有很大的关系。 
那么什么是词法环境呢？ 这里先卖个关子后面介绍, 我们先从另一个角度——内存模型来切入。</p>

<h4 id="内存模型与闭包">内存模型与闭包</h4>

<p><em>在程序运行时，变量的声明、使用和销毁都有一个生命周期。一般来说，当一个变量所在的作用域执行完毕后，内存就会被回收，这个变量也不再可访问。但是，如果存在某种机制可以让变量的生命周期延长，即使超出了它所在作用域的执行，也仍然能存活下来。闭包正是这样的一种机制。</em></p>

<p>在 <code class="language-plaintext highlighter-rouge">JavaScript</code> 中，全局变量、闭包和异步操作都能延长变量的生命周期。你可能已经注意到，这些操作类似某种形式的内部函数对外部函数的访问。</p>

<h4 id="词法环境lexical-environment">词法环境（Lexical Environment）</h4>

<p>先查看 <a href="https://262.ecma-international.org/11.0/#sec-executable-code-and-execution-contexts">ECMA规范</a> 了解 <code class="language-plaintext highlighter-rouge">词法环境</code> 是什么</p>
<blockquote>
  <p>词法环境是一种规范类型，用于定义标识符s 到基于词法嵌套的特定变量和函数 ECMAScript 代码的结构。<strong>词法环境由环境记录和对外部词法环境的可能 null 引用组成</strong>。通常，词法环境与 ECMAScript 代码的一些特定语法结构，例如函数声明一个Block语句或抓住子句的TryStatement 语句并且每次评估此类代码时都会创建一个新的词法环境。</p>
</blockquote>

<p>简单来说：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">词法环境</code> = <code class="language-plaintext highlighter-rouge">环境记录</code> + <code class="language-plaintext highlighter-rouge">外部环境引用</code></li>
  <li><code class="language-plaintext highlighter-rouge">环境记录</code> 可以暂时理解为当前作用域环境下的变量和方法（详细内容将在执行上下文中展开）</li>
  <li><code class="language-plaintext highlighter-rouge">外部环境引用</code> 指向上级词法环境（如果存在）(详细将在作用域链文中展开)</li>
  <li>在代码执行期间，每当 <code class="language-plaintext highlighter-rouge">JavaScript</code> 引擎遇到一个新的代码块、函数或 <code class="language-plaintext highlighter-rouge">catch</code> 子句时，就会创建一个新的词法环境。</li>
</ul>

<p>举个栗子:</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">data</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">test</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">name</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>在上面的代码中，存在两个作用域：全局作用域和函数 <code class="language-plaintext highlighter-rouge">test</code> 的作用域。</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">全局作用域</code>：由于没有上层作用域，所以它的外部词法环境为 null。</li>
  <li><code class="language-plaintext highlighter-rouge">test 函数的词法环境</code>：包含当前作用域下的变量（如 name），以及对上层全局环境的引用</li>
</ul>

<p>因此，<code class="language-plaintext highlighter-rouge">test</code> 函数的词法环境由它自己的变量（name）和外部的全局环境（data 等）组成。</p>

<h4 id="闭包定义解释">闭包定义解释</h4>
<blockquote>
  <p><strong>闭包（closure）是一个函数以及其捆绑的周边环境状态（lexical environment，词法环境）的引用的组合;</strong></p>
</blockquote>

<p><em>闭包绑定了它定义时的词法环境，这就是为什么子函数在离开父函数的作用域后仍然可以访问父函数的变量。</em></p>

<p>举个栗子说明：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">t1</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">data</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
  <span class="kd">function</span> <span class="nx">t2</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">t2</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">t_fn1</span> <span class="o">=</span> <span class="nx">t1</span><span class="p">();</span>
<span class="nx">t_fn1</span><span class="p">();</span>
</code></pre></div></div>

<p>我们可以通过模拟函数调用栈观察这一行为:</p>
<ol>
  <li>
    <p>首先全局环境入栈</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="p">[</span> <span class="nx">全局词法环境</span> <span class="p">(</span><span class="nx">环境记录</span><span class="p">:</span> <span class="p">{</span> <span class="nx">t1</span><span class="p">,</span> <span class="nx">t_fn1</span> <span class="p">}</span> <span class="o">+</span> <span class="nx">外部词法环境</span><span class="p">:</span> <span class="kc">null</span><span class="p">)</span> <span class="p">]</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>调用 <code class="language-plaintext highlighter-rouge">t1()</code>, <code class="language-plaintext highlighter-rouge">t1</code> 环境入栈</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="p">[</span>
   <span class="nx">t1</span> <span class="nx">词法环境</span> <span class="p">(</span><span class="nx">环境记录</span><span class="p">:</span> <span class="p">{</span> <span class="nx">data</span><span class="p">,</span> <span class="nx">fn</span> <span class="p">}</span> <span class="o">+</span> <span class="nx">外部词法环境</span><span class="p">:</span> <span class="nx">全局词法环境</span><span class="p">),</span>
   <span class="nx">全局词法环境</span> <span class="p">(</span><span class="nx">环境记录</span><span class="p">:</span> <span class="p">{</span> <span class="nx">t1</span><span class="p">,</span> <span class="nx">t_fn1</span> <span class="p">}</span> <span class="o">+</span> <span class="nx">外部词法环境</span><span class="p">:</span> <span class="kc">null</span><span class="p">)</span>
 <span class="p">]</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>调用 <code class="language-plaintext highlighter-rouge">t_fn1()</code>, <code class="language-plaintext highlighter-rouge">t2</code> 环境入栈</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="p">[</span>
   <span class="nx">t2</span> <span class="nx">词法环境</span> <span class="p">(</span><span class="nx">环境记录</span><span class="p">:</span> <span class="p">{}</span> <span class="o">+</span> <span class="nx">外部词法环境</span><span class="p">:</span> <span class="nx">t1</span> <span class="nx">词法环境</span><span class="p">),</span>
   <span class="nx">t1</span> <span class="nx">词法环境</span> <span class="p">(</span><span class="nx">环境记录</span><span class="p">:</span> <span class="p">{</span> <span class="nx">data</span><span class="p">,</span> <span class="nx">fn</span> <span class="p">}</span> <span class="o">+</span> <span class="nx">外部词法环境</span><span class="p">:</span> <span class="nx">全局词法环境</span><span class="p">),</span>
   <span class="nx">全局词法环境</span> <span class="p">(</span><span class="nx">环境记录</span><span class="p">:</span> <span class="p">{</span> <span class="nx">t1</span><span class="p">,</span> <span class="nx">t_fn1</span> <span class="p">}</span> <span class="o">+</span> <span class="nx">外部词法环境</span><span class="p">:</span> <span class="kc">null</span><span class="p">)</span>
 <span class="p">]</span>
</code></pre></div>    </div>
  </li>
</ol>

<p>可以打开浏览器验证这一行为，如下图</p>

<p><img src="/images/posts/Snipaste_2024-09-04_19-57-02.png" alt="" /></p>

<p>从这个示例中，我们可以得出一些结论：</p>
<ul>
  <li>变量是由环境记录中获取。</li>
  <li>如果某个词法环境被引用，它不会被销毁。
    <ul>
      <li>那么这一行为就延长了 <code class="language-plaintext highlighter-rouge">t1 词法环境</code> 的生命周期。</li>
    </ul>
  </li>
</ul>

<h4 id="疑问">疑问</h4>
<p>好现在我再抛出几个疑问</p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">t1</code> 函数会形成闭包吗?</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">function</span> <span class="nx">t1</span><span class="p">()</span> <span class="p">{</span>
   <span class="kd">let</span> <span class="nx">data</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
   <span class="kd">function</span> <span class="nx">t2</span><span class="p">()</span> <span class="p">{}</span>
   <span class="k">return</span> <span class="nx">t2</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>如果通过全局变量引用 <code class="language-plaintext highlighter-rouge">t1</code> 的活动对象，<code class="language-plaintext highlighter-rouge">t1</code> 执行完毕后，该对象仍然存活，这会形成闭包吗？</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">let</span> <span class="nx">data</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
 <span class="kd">function</span> <span class="nx">t1</span><span class="p">()</span> <span class="p">{</span>
   <span class="kd">let</span> <span class="nx">record</span> <span class="o">=</span> <span class="p">{};</span>
   <span class="nx">data</span> <span class="o">=</span> <span class="nx">record</span><span class="p">;</span>
 <span class="p">}</span>

 <span class="kd">function</span> <span class="nx">t2</span><span class="p">()</span> <span class="p">{</span>
   <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
 <span class="p">}</span>

 <span class="nx">t1</span><span class="p">();</span>
 <span class="nx">t2</span><span class="p">();</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>上述两种方式延长变量生命周期的方式存在区别吗？</p>
  </li>
</ol>

<h3 id="闭包的优缺点">闭包的优缺点</h3>

<p>根据上面的分析，你可能会惊讶的发现: 所有的函数都会包含周边<code class="language-plaintext highlighter-rouge">词法环境</code>。 某种程度上来讲全局作用域下所有函数都是闭包。</p>

<p>为了方便后续理解这里做一个区分 (<strong>非官方定义</strong>)：</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">隐式闭包</code> 函数在其内部不使用外部环境中的变量</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">test</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">???</span><span class="dl">"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">幽灵隐式闭包</code> 函数在其内部不使用外部环境中的变量</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">t1</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">data</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
  <span class="kd">function</span> <span class="nx">t2</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">return</span> <span class="nx">t2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">显示闭包</code> 函数在其内部使用了外部环境中的变量</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">t1</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">data</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
  <span class="kd">function</span> <span class="nx">t2</span><span class="p">()</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">)}</span>
  <span class="k">return</span> <span class="nx">t2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>需注意虽然 <code class="language-plaintext highlighter-rouge">隐式闭包</code> 和 <code class="language-plaintext highlighter-rouge">幽灵隐式闭包</code> 看上去没有使用外部词法环境人畜无害；
 但他们的情况完全不一样。</p>

<ul>
  <li>对于 <code class="language-plaintext highlighter-rouge">test</code> 函数执行完即可被销毁。</li>
  <li>对于 <code class="language-plaintext highlighter-rouge">幽灵隐式闭包 t1</code> 函数执行完并不会销毁，因为 <code class="language-plaintext highlighter-rouge">t2</code> 存在对其 <code class="language-plaintext highlighter-rouge">外部词法环境</code> 引用。
    <ul>
      <li><code class="language-plaintext highlighter-rouge">t1</code> 只会在 <code class="language-plaintext highlighter-rouge">t2</code> 所有引用它的闭包被销毁之后才会被回收。</li>
    </ul>
  </li>
</ul>

<p>（回收这块详细见垃圾回收文）</p>

<h4 id="闭包的优缺点总结">闭包的优缺点总结</h4>

<ul>
  <li><strong>缺点</strong> 内存不能及时释放，可能导致内存泄漏</li>
  <li><strong>缺点</strong> 性能开销高，多层嵌套会保留每层词法环境</li>
  <li><strong>优点</strong> 提供数据封装私有化</li>
  <li>…more</li>
</ul>

<h4 id="如何使用">如何使用</h4>

<p>根据上面对闭包原理及其优缺点了解之后, 日常编码中该如果使用闭包，以规避内存泄漏和性能问题</p>

<ol>
  <li>
    <p>消除不必要的 <code class="language-plaintext highlighter-rouge">幽灵隐式闭包</code>。</p>

    <blockquote>
      <p>在这种情况下，闭包的存在并没有任何意义，反而会导致不必要的内存占用和性能开销。</p>
    </blockquote>

    <p>官方就已经提供了很好的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures#%E6%80%A7%E8%83%BD%E8%80%83%E9%87%8F">示例</a></p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">function</span> <span class="nx">MyObject</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">.</span><span class="nx">toString</span><span class="p">();</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">message</span> <span class="o">=</span> <span class="nx">message</span><span class="p">.</span><span class="nx">toString</span><span class="p">();</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">getName</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
     <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
   <span class="p">};</span>

   <span class="k">this</span><span class="p">.</span><span class="nx">getMessage</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
     <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">message</span><span class="p">;</span>
   <span class="p">};</span>
 <span class="p">}</span>
</code></pre></div>    </div>

    <p>优化调整:</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">function</span> <span class="nx">MyObject</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">.</span><span class="nx">toString</span><span class="p">();</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">message</span> <span class="o">=</span> <span class="nx">message</span><span class="p">.</span><span class="nx">toString</span><span class="p">();</span>
 <span class="p">}</span>
 <span class="nx">MyObject</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">({</span>
   <span class="nx">getName</span><span class="p">()</span> <span class="p">{</span>
     <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
   <span class="p">},</span>
   <span class="nx">getMessage</span><span class="p">()</span> <span class="p">{</span>
     <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">message</span><span class="p">;</span>
   <span class="p">},</span>
 <span class="p">});</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>谨慎使用闭包多层嵌套。</p>

    <blockquote>
      <p>深层次的嵌套闭包会导致每层的词法环境被保留在内存中，尤其在复杂的应用中，容易造成性能开销。避免使用多层嵌套闭包可以减少内存占用并提高性能。</p>
    </blockquote>

    <p><em>如果需要嵌套闭包，确保每一层闭包的存在都是必要的。</em></p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">// 非必要的多层嵌套闭包</span>
 <span class="kd">function</span> <span class="nx">outer</span><span class="p">()</span> <span class="p">{</span>
   <span class="kd">let</span> <span class="nx">outerVar</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">outer</span><span class="dl">"</span><span class="p">;</span>
   <span class="kd">function</span> <span class="nx">middle</span><span class="p">()</span> <span class="p">{</span>
     <span class="kd">let</span> <span class="nx">middleVar</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">middle</span><span class="dl">"</span><span class="p">;</span>
     <span class="kd">function</span> <span class="nx">inner</span><span class="p">()</span> <span class="p">{</span>
       <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">outerVar</span><span class="p">,</span> <span class="nx">middleVar</span><span class="p">);</span>
     <span class="p">}</span>
     <span class="k">return</span> <span class="nx">inner</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="nx">middle</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div>    </div>
    <p>优化调整:</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">function</span> <span class="nx">outer</span><span class="p">()</span> <span class="p">{</span>
   <span class="kd">let</span> <span class="nx">outerVar</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">outer</span><span class="dl">"</span><span class="p">;</span>
   <span class="kd">let</span> <span class="nx">middleVar</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">middle</span><span class="dl">"</span><span class="p">;</span>
      
   <span class="k">return</span> <span class="p">[</span><span class="nx">outerVar</span><span class="p">,</span> <span class="nx">middleVar</span><span class="p">];</span>
 <span class="p">}</span>

 <span class="kd">function</span> <span class="nx">inner</span><span class="p">(</span><span class="nx">outerVar</span><span class="p">,</span> <span class="nx">middleVar</span><span class="p">)</span> <span class="p">{</span>
   <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">outerVar</span><span class="p">,</span> <span class="nx">middleVar</span><span class="p">);</span>
 <span class="p">}</span>

 <span class="nx">inner</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">outer</span><span class="p">())</span>  
</code></pre></div>    </div>
  </li>
  <li>
    <p>及时释放不再需要的闭包</p>
  </li>
  <li>
    <p>小心 <code class="language-plaintext highlighter-rouge">this指向</code>， 避免内存泄漏。</p>
  </li>
</ol>

<h3 id="总结">总结</h3>

<p>通过本文，我们了解了：</p>
<ol>
  <li>
    <p><strong>闭包的定义和工作原理：</strong> 闭包（ <code class="language-plaintext highlighter-rouge">closure</code> ）是一个函数以及其捆绑的周边环境状态（ <code class="language-plaintext highlighter-rouge">lexical environment</code> ，词法环境）的引用的组合; 词法环境是由当前作用域中的变量和对外部环境的引用组成。</p>
  </li>
  <li>
    <p><strong>词法环境的结构和生命周期：</strong> 词法环境由环境记录和对外部词法环境的引用组成。当 <code class="language-plaintext highlighter-rouge">JavaScript</code> 代码块、函数或其他作用域被执行时，会创建新的词法环境。
如果词法环境被引用，他的生命周期会被延长。</p>
  </li>
  <li>
    <p><strong>闭包的缺点：</strong> 由于闭包保留了其词法环境的引用，会导致内存不能及时释放，可能造成内存泄漏和性能问题，特别是在深层嵌套闭包的情况下。</p>
  </li>
  <li>
    <p><strong>如何合理使用闭包：</strong></p>

    <ul>
      <li>避免不必要的闭包。</li>
      <li>谨慎使用多层嵌套的闭包。</li>
      <li>及时释放不再需要的闭包。</li>
      <li>小心 this 的指向，避免内存泄漏。</li>
    </ul>
  </li>
</ol>

<p>参考文章：</p>

<ul>
  <li><a href="https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">维基百科 闭包</a></li>
  <li><a href="https://262.ecma-international.org/11.0/#sec-executable-code-and-execution-contexts">ECMA 词法环境</a></li>
  <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures">MDN Closures</a></li>
  <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures#%E6%80%A7%E8%83%BD%E8%80%83%E9%87%8F">MDN 性能考量</a></li>
</ul>

<!-- 词法环境 -->

<!-- 闭包性能问题 MDN -->]]></content><author><name>scriptoverture</name></author><category term="JavaScript" /><summary type="html"><![CDATA[什么是闭包？它包裹的是什么东西？又为什么会导致内存泄露？你真的理解闭包吗？]]></summary></entry></feed>