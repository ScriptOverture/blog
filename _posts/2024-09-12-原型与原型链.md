---
layout: post
title: 原型与原型链
categories: [JavaScript]
description: 原型与原型链深入理解
keywords: 原型, 原型链
---



### 什么是原型

原型在开发中无处不在，在深入介绍原型之前，我们先了解一下对象的基本概念。
这里先将对象理解为数据和行为的集合。开发中，很多时候会希望对象能够“共享”“复用”某些行为，这就引入了“原型”的概念。

为了更直观地理解原型和原型链，我们暂时抛开 `JavaScript` 的具体语法，使用伪代码来描述对象的定义、继承和复用的过程。

#### 定义结构与行为
首先，我们定义一个基本的 `元素` 结构。一个元素可以包含子元素和父元素：

```javascript
Element 结构:
    - child: null
    - parent: null
```

仅仅定义一个结构是不够的，我们还需要为这个结构添加一些行为，比如“追加元素”，“修改属性”等方法。
这些方法可以定义在一个单独的“元素方法”结构中

```javascript
ElementFunctions 方法结构:
    - append(方法)
```

#### 关联对象与方法

为了让 `Element` 能够调用 `ElementFunctions` 中的方法。
我们可以把 `ElementFunctions` 关联到 `Element` 对象，使其能够访问这些方法：
**JavaScript 中通过（`__proto__`）属性用来实现这一目的的。**

```javascript
Element 关联 ElementFunctions

element = Element { child: ..., parent: ... };
element.append(...);
```


#### “继承扩展”

在实际应用中，我们可能需要一种更具体的元素，比如“文本”元素（`Text`）。`Text` 继承了 `Element` 的所有属性，但它可能有一些自己的特性。我们可以像下面这样定义一个 `Text` 结构：

```javascript
Text 结构:
    - child: null
    - parent: null
    - classList: []
    - 更多属性...
```
为了让 `Test` 可以访问 `Element` 的方法, 我们可以将 `ElementFunctions` 关联到 `Text` 对象。
这样一来，`Text` 对象就能够复用 `Element` 的所有行为：

示例 1：
```javascript
Text 内联 ElementFunctions
text = Text { ... };
text.append(...);
```

同样的你也可以关联 `Element` 结构调用 `ElementFunctions` 中方法

示例 2：
```javascript
Element 内联 ElementFunctions

Text 内联 Element
text = Text { classList };
text.append(...);
```

对于上面例子来说， 每个结构以及方法结构都可以当作一个“基类”（被其他结构内联调用）
这些结构之间的关系可以用树状图来表示：

```javascript

    示例 1：
       ElementFunctions 结构
        |         |
       Text     Element 

    示例 2:
        ElementFunctions 结构
                |
              Element
                |
               Text 
```

#### 对象原型
[MDN 解释][1]
- 原型是 `JavaScript` 对象相互继承特性的机制
- `JavaScript` 中所有的对象都有一个内置属性，称为它的原型（原型）。
- 原型对象也有它自己的原型，逐渐构成了原型。原型链终止于拥有 `null` 作为其原型的对象上。

再回头看看示例2
- `Text` 对象， 通过内置属性指向 `Element` 对象
    - `Text` 对象的原型是 `Element` 对象
- `Element` 对象， 通过内置属性指向 `ElementFunctions` 对象
    - `Element` 对象的原型是 `ElementFunctions` 对象
- 他们通过 `__proto__`（原型）链接成了一条链表
- `Text` 对象调用 `ElementFunctions` 对象方法就是链表查找过程



可以通过示例证明

```javascript

    let ElementFunctions = {
        append: function() {
            console.log("print!!")
        }
    };

    let Element = { child: null, parent: null };

    Object.setPrototypeOf(Element, ElementFunctions);

    let Text = {};

    Object.setPrototypeOf(Text, Element);

    Text.append(); // print!!
```

上面通过[Object.setPrototypeOf][2]修改原型，不过官方并不建议项目中使用动态修改原型链性能很差。
`Object.getPrototypeOf` 获取原型 等价于 `target.__proto__`


#### 函数原型

1. **原型对象 (prototype)**
函数 `prototype` 属性通常是一个对象，它被用作该函数创建的实例的原型。
使用 `new` 运算符调用一个函数新的对象时，该对象的原型被设置为该函数的 `prototype` 属性。

1. **构造函数**
`prototype` 对象上通常会有一个 `constructor` 属性，这个属性指向函数对象本身。
例如：`Test.prototype.constructor` 会指向 `Test` 函数本身。

1. **特殊情况**
大部分函数都拥有 `prototype` 属性，下面函数不拥有 `prototype` 属性, 因此他们不能被 `new` 实例化
    - 箭头函数 (执行上下文中展开)
    - `bind` 函数


举个例子
```javascript
function Test() {
    this.data = null;
}

// 为 Test 构造函数的原型对象添加一个方法
Test.prototype.fn = function() { console.log("Hello, world!"); }

// 创建一个 Test 实例
let test = new Test();

// 访问实例的原型对象
console.log(test.__proto__ === Test.prototype);   // true
console.log(Test.prototype.constructor === Test); // true
console.log(test instanceof Test);                // true

// 调用原型上的方法
test.fn(); // 输出: "Hello, world!"
```
在上面的例子中：

- `Test` 是一个构造函数。
- `Test.prototype` 是一个对象，这个对象有一个 fn 方法。
- 当使用 `new Test()` 创建 `test` 实例时
    - `test.__proto__` 指向 `Test.prototype`。
    - 因此 test 实例可以访问 `Test.prototype` 上的方法和属性。



上面说过 **prototype 对象上通常会有一个 constructor 属性**

```javascript
let obj = {};
console.log(obj.constructor); // Object

const o2 = new Object();
console.log(o2.constructor);  // Object
```

> 除了null原型对象之外，任何对象都会在其[[Prototype]]上有一个constructor属性。

字面量对象等价于 `new Object` 的语法糖


### 原型链

原型链是 `JavaScript` 中对象属性查找的机制。当访问一个对象的属性时，如果该属性不存在于当前对象上，`JavaScript` 会沿着该对象的原型链向上查找，直到找到该属性或者到达 `null`。

在 `JavaScript` 中，每个对象都有一个隐藏的属性 [[Prototype]]，指向它的原型对象（可以通过 `Object.getPrototypeOf()` 获取）。通过这个属性，可以构成一个对象链，这就是原型链。

下面的示例演示了如何查看 `Text` 对象的原型链：

```javascript

// 查看 Text 的原型链
let next = Text;
while (next) {
    next = Object.getPrototypeOf(next);
    console.log(next);
}
```
打印：
- {child: null, parent: null}
- {append: ƒ}
- {__defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, __lookupSetter__: ƒ, …}
- null


> 注意：原型链的终点是 null，表示达到了 JavaScript 的根对象。

### 性能问题

理解原型链的查找过程，有助于认识到在 `JavaScript` 中查找对象属性可能会带来性能开销。尤其是在 `JavaScript` 这种弱类型语言中，如果原型链层级过深，属性查找过程会变得更加繁琐和耗时。

#### 使用Typescripit 辅助开发

在使用 `JavaScript` 时，我们可能会面临原型链过长的情况，导致性能问题。来看一个示例：
```javascript
let o100 = {}
...98
let o1 = {};
Object.setPrototypeOf(o1, o100);

console.log(o1.test); // null
```

在上述代码中，o1 的原型链长度为 100。当我们访问 o1.test 时，由于 o1 本身没有 test `属性，JavaScript` 会沿着它的原型链向上查找，直到找到属性或达到链的终点 `null`。
实际开发中不会有这么逆天的继承链层级，但这仍然展示了长原型链带来的查找成本。


#### 减少不必要的原型链层级
尽可能减少原型链的层级，可以提高查找性能。
以下示例通过优化 `Element` 和 `Text` 对象的原型关系来减少层级：


```javascript

let Text = { ClasssList, ... };
Object.assign(
    Object.create(ElementFunctions),
    Text
);

Text.append(...);
```

在上面的代码中，`Text` 直接与 `ElementFunctions` 建立关联，跳过了 `Element` 对象，减少了原型链的层级数。

**注意：**
- 这种操作需要确保 Text 对象的属性能够满足 `ElementFunctions` 中方法的依赖。例如，`append` 方法可能需要 `parent` 属性。
- 如果你希望通过原型链调用 `append` 方法，确保对象本身或原型链上的某个对象存在 `parent` 属性（如继承自 `Element`）。


#### 规避动态更改原型

动态更改对象的原型（如使用 `Object.setPrototypeOf`）会导致性能问题，详细可了解 [v8对于prototype优化][4]

为了加快后续原型加载的速度，`V8` 引擎使用了内联缓存（`Inline Cache`）。该缓存有四个字段：
- 属性在原型中找到的偏移量。
- 找到该属性的原型。
- 实例的形状（例如 `foo` 的形状）。
- 从实例形状链接到的直接原型的 `ValidityCell`。

当内联缓存首次命中时，`V8` 会记住这些信息。下次访问时，如果形状和 `ValidityCell` 仍然有效，`V8` 可以直接访问缓存中的属性，跳过额外的查找。

但如果动态更改了原型（如 `Object.setPrototypeOf`），会分配一个新的形状，这样旧的 `ValidityCell` 失效，内联缓存也会失效，导致性能下降。因此，避免动态更改原型可以显著提升性能。


### 总结



### 参考

- [MDN 对象原型][1]
- [MDN setPrototypeOf][2]
- [Function prototype][3]
- [V8 prototypes 优化][4]



[1]: https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object_prototypes

<!-- setPrototypeOf -->
[2]: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf


<!-- Function prototype -->
[3]: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/prototype


<!-- v8 prototypes -->
[4]: https://mathiasbynens.be/notes/prototypes