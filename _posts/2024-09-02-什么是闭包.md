---
layout: post
title: 什么是闭包?
categories: [闭包]
description: 什么是闭包？它包裹的是什么东西？又为什么会导致内存泄露？你真的理解闭包吗？
keywords: 闭包, 作用域, 词法环境
--- 

<!-- ### 前言

这篇文章将讲解 `JavaScript` 中的闭包, 说明闭包的定义理解日常使用优缺点, 以及博主各阶段对其误解。 -->


### 什么是闭包

*首先看看官方介绍*
> **闭包（closure）是一个函数以及其捆绑的周边环境状态（lexical environment，词法环境）的引用的组合**。换而言之，闭包让开发者可以从内部函数访问外部函数的作用域。在 JavaScript 中，闭包会随着函数的创建而被同时创建。

那么什么是词法环境, 这里先卖个关子后面介绍, 先了解一下内存模型(切换一下视角)

*在一个新作用域中, 声明一个新变量, 变量在声明内存到销毁有一段存活的生命周期, 而一般当变量所在作用域执行完毕时就会执行内存销毁, 也就是不能使用该变量; 那么如果存在某种操作可以将变量的生命周期延长, 也就是当所在的作用域执行完毕，该变量任然存活。*

JS 中全局变量, 闭包， 异步都以延长生命周期, 有没有发现这个操作很像内部函数访问外部函数的行为;


通过查看 [ECMA规范][3] 了解 `词法环境` 是什么
> 词法环境是一种规范类型，用于定义标识符s 到基于词法嵌套的特定变量和函数 ECMAScript 代码的结构。**词法环境由环境记录和对外部词法环境的可能 null 引用组成**。通常，词法环境与 ECMAScript 代码的一些特定语法结构，例如函数声明一个Block语句或抓住子句的TryStatement 语句并且每次评估此类代码时都会创建一个新的词法环境。

简单来说：
- `词法环境` = `环境记录` + `外部环境引用`
- `环境记录` 可以暂时理解为当前作用域环境下的变量和方法（详细内容将在执行上下文中展开）
- `外部环境引用` 指向上级词法环境（如果存在）(详细将在作用域链文中展开)
- 在代码执行期间，每当 `JavaScript` 引擎遇到一个新的代码块、函数或 `catch` 子句时，就会创建一个新的词法环境。

举个栗子:
```javascript
let data = null;
function test() {
  let name = null;
  console.log(data);
}
```
在上面的代码中，存在两个作用域：全局作用域和函数 `test` 的作用域。
- `全局作用域`：由于没有上层作用域，所以它的外部词法环境为 null。
- `test` 函数的词法环境：包含当前作用域下的变量（如 name），以及对上层全局环境的引用

因此，`test` 函数的词法环境由它自己的变量（name）和外部的全局环境（data 等）组成。

再次强调闭包定义: 
> **闭包（closure）是一个函数以及其捆绑的周边环境状态（lexical environment，词法环境）的引用的组合;**

*闭包绑定了它定义时的词法环境，这就是为什么子函数在离开父函数的作用域后仍然可以访问父函数的变量。*

就像下面栗子一样：
```javascript
function t1() {
  let data = null;
  function t2() {
    console.log(data);
  }
  return t2;
}

let t_fn1 = t1();
t_fn1();

// 我们可以通过模拟函数调用栈观察这一行为
1. 首先全局环境入栈
[
  全局词法环境 (环境记录:{ t1, t_fn1 } + 外部词法环境: null)
]

2. t1() t1 入栈
[
  t1 词法环境 (环境记录:{ data, fn } + 外部词法环境: 全局词法环境)
  全局词法环境 (环境记录:{ t1, t_fn1 } + 外部词法环境: null)
]

3. t_fn1() t2 入栈
因为 t2 词法环境存在对 t1 词法环境的引用
因此执行完 t1 其词法环境并没有销毁
[
  t2 词法环境 (环境记录:{} + 外部词法环境: t1 词法环境)
  t1 词法环境 (环境记录:{ data, fn } + 外部词法环境: 全局词法环境)
  全局词法环境 (环境记录:{ t1, t_fn1 } + 外部词法环境: null)
]
```

可以打开浏览器验证这一行为，如下图

![](/images/posts/Snipaste_2024-09-04_19-57-02.png)


因此我们可以得出一些结论：
- 变量是由环境记录中获取
- 而 `某个词法环境被引用不会被销毁`
- 那么这一行为就延长了 `t1 词法环境` 的生命周期

这也就类比内存模型中的异常操作行为.


好现在我抛出几个疑问
- t1 函数会形成闭包吗? 
```javascript
function t1() {
  let data = null;
  function t2() {}
  return t2;
}
```

- 通过全局变量引用, t1 活动对象值record, t1 执行完毕record值仍然存活
这会形成闭包吗？
```javascript
let data = null;
function t1() {
  let record = {};
  data = record;
}

function t2() {
  console.log(data);
}

t1();
t2();
```

- 上面俩种方式延长变量生命周期区别是什么？

### 闭包优缺点

根据上面闭包函数模拟调用栈分析，你会惊讶的发现所有的函数都会包含周边`词法环境`, 也就可以说全局作用域下所有函数都是闭包，为了方便后续理解这里做一个区分
- `隐式闭包` 函数在其内部不使用外部环境中的变量
```javascript
function test() {
  console.log("???")
}
function t1() {
  let data = null;
  function t2() {}
  return t2;
}
```
- `显示闭包` 函数在其内部使用了外部环境中的变量
```javascript
function t1() {
  let data = null;
  function t2() {console.log(data)}
  return t2;
}
```

需注意虽然 `隐式闭包` 栗子中包含 `t1` 和 `test` 函数, 他们的情况完全不一样 
- 对于 `test` 函数执行完即可被销毁
- 对于 `t1` 函数执行完并不会销毁，因为 `t2` 存在对其 `外部词法环境` 引用
- `t1` 只会在 `t2` 所有引用它的闭包被销毁之后才会被回收

（回收这块详细见垃圾回收文）

根据上文闭包特性很容易知道其优缺点
- **缺点** 内存不能及时释放，可能导致内存泄漏
- **缺点** 性能开销高，多层嵌套会保留每层词法环境
- **优点** 提供数据封装私有化
- ...more

### 如果使用

### 总结



[1]: https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)

[2]: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures

<!-- 词法环境 -->
[3]: https://262.ecma-international.org/11.0/#sec-executable-code-and-execution-contexts

<!-- 闭包性能问题 MDN -->
[4]: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures#%E6%80%A7%E8%83%BD%E8%80%83%E9%87%8F