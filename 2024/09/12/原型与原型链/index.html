<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>原型与原型链 &mdash; overture</title><link rel="stylesheet" href="https://scriptoverture.github.io/blog/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://scriptoverture.github.io/blog/assets/css/components/collection.css"><link rel="stylesheet" href="https://scriptoverture.github.io/blog/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://scriptoverture.github.io/blog/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://scriptoverture.github.io/blog/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://scriptoverture.github.io/blog/assets/css/globals/common.css"><link rel="stylesheet" href="https://scriptoverture.github.io/blog/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://scriptoverture.github.io/blog/assets/css/posts/index.css"><link rel="stylesheet" href="https://scriptoverture.github.io/blog/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://mazhuang.org/rouge-themes/dist/github.css"><link rel="canonical" href="https://scriptoverture.github.io/blog/2024/09/12/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"><link rel="alternate" type="application/atom+xml" title="overture" href="https://scriptoverture.github.io/blog/feed.xml"><link rel="shortcut icon" href="https://scriptoverture.github.io/blog/favicon.ico"><meta property="og:title" content="原型与原型链"><meta name="keywords" content="原型, 原型链"><meta name="og:keywords" content="原型, 原型链"><meta name="description" content="什么是原型"><meta name="og:description" content="什么是原型"><meta property="og:url" content="https://scriptoverture.github.io/blog/2024/09/12/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"><meta property="og:site_name" content="overture"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2024-09-12"> <script src="https://scriptoverture.github.io/blog/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://scriptoverture.github.io/blog/assets/js/main.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-Z6VKGSE98P"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-Z6VKGSE98P'); </script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://scriptoverture.github.io/blog/" title="overture"><span class="octicon octicon-mark-github"></span> overture</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://scriptoverture.github.io/blog/" class="site-header-nav-item" target="" title="首页">首页</a> <a href="https://scriptoverture.github.io/blog/categories/" class="site-header-nav-item" target="" title="分类">分类</a> <a href="https://scriptoverture.github.io/blog/archives/" class="mobile-hidden site-header-nav-item" target="" title="归档">归档</a> <a href="https://scriptoverture.github.io/blog/open-source/" class="mobile-hidden site-header-nav-item" target="" title="开源">开源</a> <a href="https://scriptoverture.github.io/blog/fragments/" class="site-header-nav-item" target="" title="片段">片段</a> <a href="https://scriptoverture.github.io/blog/wiki/" class="site-header-nav-item" target="" title="维基">维基</a> <a href="https://scriptoverture.github.io/blog/links/" class="mobile-hidden site-header-nav-item" target="" title="链接">链接</a> <a href="https://scriptoverture.github.io/blog/about/" class="site-header-nav-item" target="" title="关于">关于</a> <a class="mobile-hidden" href="https://scriptoverture.github.io/blog/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="原型与原型链"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">原型与原型链</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2024/09/12 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://scriptoverture.github.io/blog/categories/#JavaScript" title="JavaScript">JavaScript</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 4966 字，约 15 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h3 id="什么是原型">什么是原型</h3><p>原型在开发中无处不在，在深入介绍原型之前，我们先了解一下对象的基本概念。 这里先将对象理解为数据和行为的集合。开发中，很多时候会希望对象能够“共享”“复用”某些行为，这就引入了“原型”的概念。</p><p>为了更直观地理解原型和原型链，我们暂时抛开 <code class="language-plaintext highlighter-rouge">JavaScript</code> 的具体语法，使用伪代码来描述对象的定义、继承和复用的过程。</p><h4 id="定义结构与行为">定义结构与行为</h4><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Element</span> <span class="nx">结构</span><span class="p">:</span>
    <span class="o">-</span> <span class="nx">child</span><span class="p">:</span> <span class="kc">null</span>
    <span class="o">-</span> <span class="nx">parent</span><span class="p">:</span> <span class="kc">null</span>


<span class="nx">ElementFunctions</span> <span class="nx">方法结构</span><span class="p">:</span>
    <span class="o">-</span> <span class="nx">append</span><span class="p">(</span><span class="nx">方法</span><span class="p">)</span>


<span class="nx">Text</span> <span class="nx">结构</span><span class="p">:</span>
    <span class="o">-</span> <span class="nx">child</span><span class="p">:</span> <span class="kc">null</span>
    <span class="o">-</span> <span class="nx">parent</span><span class="p">:</span> <span class="kc">null</span>
    <span class="o">-</span> <span class="nx">classList</span><span class="p">:</span> <span class="p">[]</span>
    <span class="o">-</span> <span class="nx">更多属性</span><span class="p">...</span>
</code></pre></div></div><p>上面伪代码定义了三个个结构对象</p><ul><li><code class="language-plaintext highlighter-rouge">Element</code> 结构 包含子元素和父元素</li><li><code class="language-plaintext highlighter-rouge">ElementFunctions</code> 方法结构（描述 <code class="language-plaintext highlighter-rouge">Element</code> 结构 可以产生的行为）<ul><li>比如 “追加元素”，“修改属性” 等方法。</li></ul></li><li><code class="language-plaintext highlighter-rouge">Text</code> 结构，在 <code class="language-plaintext highlighter-rouge">Element</code> 结构上又增加了一些属性。</li></ul><h4 id="关联对象与方法">关联对象与方法</h4><p>为了让 <code class="language-plaintext highlighter-rouge">Element</code> 能够调用 <code class="language-plaintext highlighter-rouge">ElementFunctions</code> 中的方法。 这里把 <code class="language-plaintext highlighter-rouge">ElementFunctions</code> 与 <code class="language-plaintext highlighter-rouge">Element</code> 对象建立关联，使其能够访问这些方法： <strong>JavaScript 中通过（<code class="language-plaintext highlighter-rouge">__proto__</code>）属性用来实现这一目的的。</strong></p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Element</span> <span class="nx">关联</span> <span class="nx">ElementFunctions</span>

<span class="nx">element</span> <span class="o">=</span> <span class="nx">Element</span> <span class="p">{</span> <span class="nl">child</span><span class="p">:</span> <span class="p">...,</span> <span class="nx">parent</span><span class="p">:</span> <span class="p">...</span> <span class="p">};</span>
<span class="nx">element</span><span class="p">.</span><span class="nx">append</span><span class="p">(...);</span>
</code></pre></div></div><h4 id="继承扩展">“继承扩展”</h4><p>为了让 <code class="language-plaintext highlighter-rouge">Test</code> 可以访问 <code class="language-plaintext highlighter-rouge">Element</code> 的方法, 我们需要实现一种继承机制。 可以将 <code class="language-plaintext highlighter-rouge">ElementFunctions</code> 关联到 <code class="language-plaintext highlighter-rouge">Text</code> 对象 如示例1。</p><p>示例 1：</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Text</span> <span class="nx">内联</span> <span class="nx">ElementFunctions</span>
<span class="nx">text</span> <span class="o">=</span> <span class="nx">Text</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
<span class="nx">text</span><span class="p">.</span><span class="nx">append</span><span class="p">(...);</span>
</code></pre></div></div><p>同样的也可以将 <code class="language-plaintext highlighter-rouge">ElementFunctions</code> 关联到 <code class="language-plaintext highlighter-rouge">Element</code> 结构。 <code class="language-plaintext highlighter-rouge">Element</code> 结构再关联 <code class="language-plaintext highlighter-rouge">Text</code>结构，从而访问方法。</p><p>示例 2：</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Element</span> <span class="nx">内联</span> <span class="nx">ElementFunctions</span>

<span class="nx">Text</span> <span class="nx">内联</span> <span class="nx">Element</span>
<span class="nx">text</span> <span class="o">=</span> <span class="nx">Text</span> <span class="p">{</span> <span class="nx">classList</span> <span class="p">};</span>
<span class="nx">text</span><span class="p">.</span><span class="nx">append</span><span class="p">(...);</span>
</code></pre></div></div><p>这些结构之间的关系可以用树状图来表示：</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    <span class="nx">示例</span> <span class="mi">1</span><span class="err">：</span>
       <span class="nx">ElementFunctions</span> <span class="nx">结构</span>
        <span class="o">|</span>         <span class="o">|</span>
       <span class="nx">Text</span>     <span class="nx">Element</span> 

    <span class="nx">示例</span> <span class="mi">2</span><span class="p">:</span>
        <span class="nx">ElementFunctions</span> <span class="nx">结构</span>
                <span class="o">|</span>
              <span class="nx">Element</span>
                <span class="o">|</span>
               <span class="nx">Text</span> 
</code></pre></div></div><p>你有看出示例1和示例2的差异吗？</p><p>回看上面的伪代码示例:</p><ul><li>上面 <code class="language-plaintext highlighter-rouge">结构</code> 都可以理解为 <code class="language-plaintext highlighter-rouge">js</code> 中的对象。</li><li>关联操作对应 <code class="language-plaintext highlighter-rouge">js</code> 原型对象指向。<ul><li>示例2 来讲：<code class="language-plaintext highlighter-rouge">Text</code> 的原型对象 就是 <code class="language-plaintext highlighter-rouge">Element</code> 对象。</li><li>关联等价 <code class="language-plaintext highlighter-rouge">“继承”</code></li></ul></li><li>每个结构都能被当做一个 “基类”，可以被其他结构继承， 或者继承其他结构。</li></ul><p>下面会进行验证。</p><h4 id="对象原型">对象原型</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object_prototypes">MDN 解释</a></p><ul><li>原型是 <code class="language-plaintext highlighter-rouge">JavaScript</code> 对象相互继承特性的一种机制</li><li><code class="language-plaintext highlighter-rouge">JavaScript</code> 中所有的对象都有一个内置属性，称为它的原型（原型）。</li><li>原型对象也有它自己的原型，逐渐构成了原型链路。原型链终止于拥有 <code class="language-plaintext highlighter-rouge">null</code> 作为其原型的对象上。</li></ul><p>再回头看看伪代码的示例2</p><ul><li><code class="language-plaintext highlighter-rouge">Text</code> 对象， 通过内置属性指向 <code class="language-plaintext highlighter-rouge">Element</code> 对象。<ul><li><code class="language-plaintext highlighter-rouge">Text</code> 对象的原型是 <code class="language-plaintext highlighter-rouge">Element</code> 对象。</li></ul></li><li><code class="language-plaintext highlighter-rouge">Element</code> 对象， 通过内置属性指向 <code class="language-plaintext highlighter-rouge">ElementFunctions</code> 对象。<ul><li><code class="language-plaintext highlighter-rouge">Element</code> 对象的原型是 <code class="language-plaintext highlighter-rouge">ElementFunctions</code> 对象。</li></ul></li><li>他们通过 <code class="language-plaintext highlighter-rouge">__proto__</code>（原型）链接成了一条链表。</li><li><code class="language-plaintext highlighter-rouge">Text</code> 对象调用 <code class="language-plaintext highlighter-rouge">ElementFunctions</code> 对象方法就是链表查找过程。</li></ul><p>举例说明：</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    <span class="kd">let</span> <span class="nx">ElementFunctions</span> <span class="o">=</span> <span class="p">{</span>
        <span class="na">append</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">print!!</span><span class="dl">"</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="kd">let</span> <span class="nx">Element</span> <span class="o">=</span> <span class="p">{</span> <span class="na">child</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span> <span class="na">parent</span><span class="p">:</span> <span class="kc">null</span> <span class="p">};</span>

    <span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">Element</span><span class="p">,</span> <span class="nx">ElementFunctions</span><span class="p">);</span>

    <span class="kd">let</span> <span class="nx">Text</span> <span class="o">=</span> <span class="p">{};</span>

    <span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">Text</span><span class="p">,</span> <span class="nx">Element</span><span class="p">);</span>

    <span class="nx">Text</span><span class="p">.</span><span class="nx">append</span><span class="p">();</span> <span class="c1">// print!!</span>

    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">Text</span><span class="p">)</span> <span class="o">===</span> <span class="nx">Element</span><span class="p">);</span>             <span class="c1">// true</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">Element</span><span class="p">)</span> <span class="o">===</span> <span class="nx">ElementFunctions</span><span class="p">);</span> <span class="c1">// true</span>
</code></pre></div></div><p><em>注意</em><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf">Object.setPrototypeOf</a> 官方并不建议项目中使用动态修改原型链性能很差， 后面会说明。 <code class="language-plaintext highlighter-rouge">Object.getPrototypeOf</code>: 获取原型 等价于 <code class="language-plaintext highlighter-rouge">target.__proto__</code></p><h4 id="函数原型">函数原型</h4><ol><li><p><strong>原型对象 (prototype)</strong> 函数 <code class="language-plaintext highlighter-rouge">prototype</code> 属性通常是一个对象，它被用作该函数创建的实例的原型。 使用 <code class="language-plaintext highlighter-rouge">new</code> 运算符调用一个函数新的对象时，该对象的原型被设置为该函数的 <code class="language-plaintext highlighter-rouge">prototype</code> 属性。</p></li><li><p><strong>构造函数</strong> <code class="language-plaintext highlighter-rouge">prototype</code> 对象上通常会有一个 <code class="language-plaintext highlighter-rouge">constructor</code> 属性，这个属性指向函数对象本身。 例如：<code class="language-plaintext highlighter-rouge">Test.prototype.constructor</code> 会指向 <code class="language-plaintext highlighter-rouge">Test</code> 函数本身。</p></li><li><p><strong>特殊情况</strong> 大部分函数都拥有 <code class="language-plaintext highlighter-rouge">prototype</code> 属性，下面函数不拥有 <code class="language-plaintext highlighter-rouge">prototype</code> 属性。</p><ul><li>箭头函数, 不能被 <code class="language-plaintext highlighter-rouge">new</code> 实例化 (执行上下文中展开)</li><li><code class="language-plaintext highlighter-rouge">bind</code> 函数, 但是可能是可构造的。当它被构造的时候，目标函数将会被构造，如果目标函数是可构造的，将会返回一个普通的实例。</li></ul></li></ol><p>举个例子</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Test</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">data</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 为 Test 构造函数的原型对象添加一个方法</span>
<span class="nx">Test</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">fn</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Hello, world!</span><span class="dl">"</span><span class="p">);</span> <span class="p">}</span>

<span class="c1">// 创建一个 Test 实例</span>
<span class="kd">let</span> <span class="nx">test</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Test</span><span class="p">();</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">test</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nx">Test</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>   <span class="c1">// true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Test</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">===</span> <span class="nx">Test</span><span class="p">);</span>           <span class="c1">// true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Test</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">===</span> <span class="nx">Test</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="kd">constructor</span><span class="p">);</span><span class="c1">// true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">test</span> <span class="k">instanceof</span> <span class="nx">Test</span><span class="p">);</span>                <span class="c1">// true</span>

<span class="nx">test</span><span class="p">.</span><span class="nx">fn</span><span class="p">();</span> <span class="c1">// 输出: "Hello, world!"</span>
</code></pre></div></div><p>在上面的例子中：</p><ul><li><code class="language-plaintext highlighter-rouge">Test.prototype</code> 的原型上挂载 <code class="language-plaintext highlighter-rouge">fn</code> 方法。</li><li><code class="language-plaintext highlighter-rouge">test</code> 实例原型指向 <code class="language-plaintext highlighter-rouge">Test.prototype</code><ul><li>因此 <code class="language-plaintext highlighter-rouge">test</code> 实例可以调用 <code class="language-plaintext highlighter-rouge">fn</code></li><li>自然 <code class="language-plaintext highlighter-rouge">Test.constructor</code> 等于 <code class="language-plaintext highlighter-rouge">Test.prototype.constructor</code></li></ul></li><li><code class="language-plaintext highlighter-rouge">Test</code> 等价 <code class="language-plaintext highlighter-rouge">Class Test{ fn }</code> 的语法糖<ul><li><code class="language-plaintext highlighter-rouge">class</code> 只是一个语法糖，本质上仍然是使用原型机制</li></ul></li></ul><p>再观察下面的示例：</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="kd">constructor</span><span class="p">);</span> <span class="c1">// Object</span>

<span class="kd">const</span> <span class="nx">o2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">o2</span><span class="p">.</span><span class="kd">constructor</span><span class="p">);</span>  <span class="c1">// Object</span>
</code></pre></div></div><p>之前说过 <strong>prototype 对象上通常会有一个 constructor 属性</strong></p><blockquote><p>除了null原型对象之外，任何对象都会在其[[Prototype]]上有一个constructor属性。</p></blockquote><ul><li>而 <code class="language-plaintext highlighter-rouge">obj字面量</code> 也存在 <code class="language-plaintext highlighter-rouge">constructor</code>，并且 <code class="language-plaintext highlighter-rouge">constructor</code> 指向 <code class="language-plaintext highlighter-rouge">Object</code>方法;</li><li>换句话说，<code class="language-plaintext highlighter-rouge">obj字面量</code> 是<code class="language-plaintext highlighter-rouge">new Object</code> 构造函数的实例</li><li>字面量对象等价于 <code class="language-plaintext highlighter-rouge">new Object</code> 的语法糖</li></ul><p><strong>函数原型的继承</strong></p><p>因为 函数prototype 大多数也是对象，对象可以依靠__proto__继承。 实例指向 函数prototype， 变相实现构造函数的继承。</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">function</span> <span class="nx">Test</span><span class="p">()</span> <span class="p">{}</span>
<span class="kd">let</span> <span class="nx">data</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">ElementFunctions</span><span class="p">);</span>
<span class="nx">data</span><span class="p">.</span><span class="nx">fn</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Hello, world!</span><span class="dl">"</span><span class="p">);</span> <span class="p">}</span>
<span class="nx">Test</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>

<span class="kd">let</span> <span class="nx">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Test</span><span class="p">();</span>
<span class="nx">t</span><span class="p">.</span><span class="nx">append</span><span class="p">();</span> 

<span class="c1">// 或者</span>
<span class="kd">function</span> <span class="nx">testfn</span><span class="p">()</span> <span class="p">{}</span>
<span class="nx">testfn</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">ElementFunctions</span><span class="p">);</span>
<span class="kd">class</span> <span class="nx">Test</span> <span class="kd">extends</span> <span class="nx">testfn</span> <span class="p">{</span>
    <span class="nx">fn</span><span class="p">()</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Hello, world!</span><span class="dl">"</span><span class="p">);</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Test</span><span class="p">();</span>
<span class="nx">t</span><span class="p">.</span><span class="nx">append</span><span class="p">();</span>
</code></pre></div></div><h3 id="原型链">原型链</h3><p>原型链是 <code class="language-plaintext highlighter-rouge">JavaScript</code> 中对象属性查找的机制。当访问一个对象的属性时，如果该属性不存在于当前对象上，<code class="language-plaintext highlighter-rouge">JavaScript</code> 会沿着该对象的原型链向上查找，直到找到该属性或者到达 <code class="language-plaintext highlighter-rouge">null</code>。</p><p>下面的示例演示了如何查看 <code class="language-plaintext highlighter-rouge">Text</code> 对象的原型链：</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">// 查看 Text 的原型链</span>
<span class="kd">let</span> <span class="nx">next</span> <span class="o">=</span> <span class="nx">Text</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">next</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">next</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">next</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><p>打印：</p><ul><li>{child: null, parent: null}</li><li>{append: ƒ}</li><li>{<strong>defineGetter</strong>: ƒ, <strong>defineSetter</strong>: ƒ, hasOwnProperty: ƒ, <strong>lookupGetter</strong>: ƒ, <strong>lookupSetter</strong>: ƒ, …}</li><li>null</li></ul><blockquote><p>注意：原型链的终点是 null，表示达到了 JavaScript 的根对象。</p></blockquote><h3 id="性能问题">性能问题</h3><p>再了解原型链的查找过程后，可能意识到某些场景下查找对象属性可能会带来性能开销。</p><h4 id="使用typescript-辅助开发">使用Typescript 辅助开发</h4><p>对于原型链过长导致性能问题。来看一个示例：</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">o100</span> <span class="o">=</span> <span class="p">{}</span>
<span class="p">...</span><span class="mi">98</span>
<span class="kd">let</span> <span class="nx">o1</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">o1</span><span class="p">,</span> <span class="nx">o100</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">o1</span><span class="p">.</span><span class="nx">test</span><span class="p">);</span> <span class="c1">// null</span>
</code></pre></div></div><p>在上述代码中，<code class="language-plaintext highlighter-rouge">o1</code> 的原型链长度为 100。当我们访问 <code class="language-plaintext highlighter-rouge">o1.test</code> 时，由于 <code class="language-plaintext highlighter-rouge">o1</code> 本身没有 <code class="language-plaintext highlighter-rouge">test</code> 属性，<code class="language-plaintext highlighter-rouge">JavaScript</code> 会沿着它的原型链向上查找直到终点 <code class="language-plaintext highlighter-rouge">null</code>。</p><p>因而使用类型机制，可以在编译时规避无效属性，进而抹去无效属性查找开销。</p><h4 id="减少不必要的原型链层级">减少不必要的原型链层级</h4><p>尽可能减少原型链的层级，可以提高查找性能。 以下示例通过优化 <code class="language-plaintext highlighter-rouge">Element</code> 和 <code class="language-plaintext highlighter-rouge">Text</code> 对象的原型关系来减少层级：</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">let</span> <span class="nx">Text</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">ClasssList</span><span class="p">,</span> <span class="p">...</span> <span class="p">};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span>
    <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">ElementFunctions</span><span class="p">),</span>
    <span class="nx">Text</span>
<span class="p">);</span>

<span class="nx">Text</span><span class="p">.</span><span class="nx">append</span><span class="p">(...);</span>
</code></pre></div></div><p>在上面的代码中，<code class="language-plaintext highlighter-rouge">Text</code> 继承 <code class="language-plaintext highlighter-rouge">ElementFunctions</code>，而非 <code class="language-plaintext highlighter-rouge">Element</code> 对象，减少了原型链的层级数。</p><p><strong>注意：</strong></p><ul><li>这种操作需要确保 <code class="language-plaintext highlighter-rouge">Text</code> 对象的属性能够满足 <code class="language-plaintext highlighter-rouge">ElementFunctions</code> 中方法的依赖。例如，<code class="language-plaintext highlighter-rouge">append</code> 方法可能需要 <code class="language-plaintext highlighter-rouge">parent</code> 属性。</li><li>如果你希望通过原型链调用 <code class="language-plaintext highlighter-rouge">append</code> 方法，确保对象本身或原型链上的某个对象存在 <code class="language-plaintext highlighter-rouge">parent</code> 属性（如继承自 <code class="language-plaintext highlighter-rouge">Element</code>）。</li></ul><h4 id="规避动态更改原型">规避动态更改原型</h4><p>动态更改对象的原型（如使用 <code class="language-plaintext highlighter-rouge">Object.setPrototypeOf</code>）会导致性能问题，详细可了解 <a href="https://mathiasbynens.be/notes/prototypes">v8对于prototype优化</a></p><p>为了加快后续原型加载的速度，<code class="language-plaintext highlighter-rouge">V8</code> 引擎使用了内联缓存（<code class="language-plaintext highlighter-rouge">Inline Cache</code>）。该缓存有四个字段：</p><ul><li>属性在原型中找到的偏移量。</li><li>找到该属性的原型。</li><li>实例的形状。</li><li>从实例形状链接到的直接原型的 <code class="language-plaintext highlighter-rouge">ValidityCell</code>。</li></ul><p>当内联缓存首次命中时，<code class="language-plaintext highlighter-rouge">V8</code> 会记住这些信息。下次访问时，如果形状和 <code class="language-plaintext highlighter-rouge">ValidityCell</code> 仍然有效，<code class="language-plaintext highlighter-rouge">V8</code> 可以直接访问缓存中的属性，跳过额外的查找。</p><p>但如果动态更改了原型（如 <code class="language-plaintext highlighter-rouge">Object.setPrototypeOf</code>），会分配一个新的形状，这样旧的 <code class="language-plaintext highlighter-rouge">ValidityCell</code> 失效，内联缓存也会失效，导致性能下降。因此，避免动态更改原型可以显著提升性能。</p><h3 id="结语">结语</h3><p>不知道你有没有察觉，前面说过的原型意味着“继承”对象属性，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是：</p><blockquote><p>继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。</p></blockquote><h3 id="参考">参考</h3><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object_prototypes">MDN 对象原型</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf">MDN setPrototypeOf</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/prototype">Function prototype</a></li><li><a href="https://mathiasbynens.be/notes/prototypes">V8 prototypes 优化</a></li></ul><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="https://scriptoverture.github.io/blog" target="_blank">scriptoverture</a></li><li>本文链接：<a href="https://scriptoverture.github.io/blog/2024/09/12/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/" target="_blank">https://scriptoverture.github.io/blog/2024/09/12/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"> <script src="https://giscus.app/client.js" data-repo="scriptoverture/blog" data-repo-id="R_kgDOMq9zeA" data-category="Announcements" data-category-id="DIC_kwDOMq9zeM4CiHLc" data-mapping="title" data-strict="1" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous" async> </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://scriptoverture.github.io/blog/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://scriptoverture.github.io/blog/assets/search_data.json?v=1758293945', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://scriptoverture.github.io/blog/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2024 <span title="scriptoverture">scriptoverture</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/https:/blog" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://scriptoverture.github.io/blog/" title="首页" target="">首页</a></li><li> <a href="https://scriptoverture.github.io/blog/categories/" title="分类" target="">分类</a></li><li> <a href="https://scriptoverture.github.io/blog/archives/" title="归档" target="">归档</a></li><li> <a href="https://scriptoverture.github.io/blog/open-source/" title="开源" target="">开源</a></li><li> <a href="https://scriptoverture.github.io/blog/fragments/" title="片段" target="">片段</a></li><li> <a href="https://scriptoverture.github.io/blog/wiki/" title="维基" target="">维基</a></li><li> <a href="https://scriptoverture.github.io/blog/links/" title="链接" target="">链接</a></li><li> <a href="https://scriptoverture.github.io/blog/about/" title="关于" target="">关于</a></li><li><a href="https://scriptoverture.github.io/blog/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://scriptoverture.github.io/blog/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script></body></html>
