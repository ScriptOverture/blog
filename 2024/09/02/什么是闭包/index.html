<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>什么是闭包? &mdash; overture</title><link rel="stylesheet" href="https://scriptoverture.github.io/blog/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://scriptoverture.github.io/blog/assets/css/components/collection.css"><link rel="stylesheet" href="https://scriptoverture.github.io/blog/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://scriptoverture.github.io/blog/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://scriptoverture.github.io/blog/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://scriptoverture.github.io/blog/assets/css/globals/common.css"><link rel="stylesheet" href="https://scriptoverture.github.io/blog/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://scriptoverture.github.io/blog/assets/css/posts/index.css"><link rel="stylesheet" href="https://scriptoverture.github.io/blog/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://mazhuang.org/rouge-themes/dist/github.css"><link rel="canonical" href="https://scriptoverture.github.io/blog/2024/09/02/%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85/"><link rel="alternate" type="application/atom+xml" title="overture" href="https://scriptoverture.github.io/blog/feed.xml"><link rel="shortcut icon" href="https://scriptoverture.github.io/blog/favicon.ico"><meta property="og:title" content="什么是闭包?"><meta name="keywords" content="闭包, 作用域, 词法环境"><meta name="og:keywords" content="闭包, 作用域, 词法环境"><meta name="description" content="什么是闭包 (Closures)"><meta name="og:description" content="什么是闭包 (Closures)"><meta property="og:url" content="https://scriptoverture.github.io/blog/2024/09/02/%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85/"><meta property="og:site_name" content="overture"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2024-09-02"> <script src="https://scriptoverture.github.io/blog/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://scriptoverture.github.io/blog/assets/js/main.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-Z6VKGSE98P"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-Z6VKGSE98P'); </script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://scriptoverture.github.io/blog/" title="overture"><span class="octicon octicon-mark-github"></span> overture</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://scriptoverture.github.io/blog/" class="site-header-nav-item" target="" title="首页">首页</a> <a href="https://scriptoverture.github.io/blog/categories/" class="site-header-nav-item" target="" title="分类">分类</a> <a href="https://scriptoverture.github.io/blog/archives/" class="mobile-hidden site-header-nav-item" target="" title="归档">归档</a> <a href="https://scriptoverture.github.io/blog/open-source/" class="mobile-hidden site-header-nav-item" target="" title="开源">开源</a> <a href="https://scriptoverture.github.io/blog/fragments/" class="site-header-nav-item" target="" title="片段">片段</a> <a href="https://scriptoverture.github.io/blog/wiki/" class="site-header-nav-item" target="" title="维基">维基</a> <a href="https://scriptoverture.github.io/blog/links/" class="mobile-hidden site-header-nav-item" target="" title="链接">链接</a> <a href="https://scriptoverture.github.io/blog/about/" class="site-header-nav-item" target="" title="关于">关于</a> <a class="mobile-hidden" href="https://scriptoverture.github.io/blog/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="什么是闭包?"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">什么是闭包?</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2024/09/02 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://scriptoverture.github.io/blog/categories/#JavaScript" title="JavaScript">JavaScript</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 3662 字，约 11 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h3 id="什么是闭包-closures">什么是闭包 (Closures)</h3><p><em>在讨论闭包之前，首先看看<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures">官方介绍</a></em></p><blockquote><p><strong>闭包（closure）是一个函数以及其捆绑的周边环境状态（lexical environment，词法环境）的引用的组合</strong>。换而言之，闭包让开发者可以从内部函数访问外部函数的作用域。在 JavaScript 中，闭包会随着函数的创建而被同时创建。</p></blockquote><p>从定义中可以看到，闭包和词法环境（ <code class="language-plaintext highlighter-rouge">lexical environment</code> ）有很大的关系。 那么什么是词法环境呢？ 这里先卖个关子后面介绍, 我们先从另一个角度——内存模型来切入。</p><h4 id="内存模型与闭包">内存模型与闭包</h4><p><em>在程序运行时，变量的声明、使用和销毁都有一个生命周期。一般来说，当一个变量所在的作用域执行完毕后，内存就会被回收，这个变量也不再可访问。但是，如果存在某种机制可以让变量的生命周期延长，即使超出了它所在作用域的执行，也仍然能存活下来。闭包正是这样的一种机制。</em></p><p>在 <code class="language-plaintext highlighter-rouge">JavaScript</code> 中，全局变量、闭包和异步操作都能延长变量的生命周期。你可能已经注意到，这些操作类似某种形式的内部函数对外部函数的访问。</p><h4 id="词法环境lexical-environment">词法环境（Lexical Environment）</h4><p>先查看 <a href="https://262.ecma-international.org/11.0/#sec-executable-code-and-execution-contexts">ECMA规范</a> 了解 <code class="language-plaintext highlighter-rouge">词法环境</code> 是什么</p><blockquote><p>词法环境是一种规范类型，用于定义标识符s 到基于词法嵌套的特定变量和函数 ECMAScript 代码的结构。<strong>词法环境由环境记录和对外部词法环境的可能 null 引用组成</strong>。通常，词法环境与 ECMAScript 代码的一些特定语法结构，例如函数声明一个Block语句或抓住子句的TryStatement 语句并且每次评估此类代码时都会创建一个新的词法环境。</p></blockquote><p>简单来说：</p><ul><li><code class="language-plaintext highlighter-rouge">词法环境</code> = <code class="language-plaintext highlighter-rouge">环境记录</code> + <code class="language-plaintext highlighter-rouge">外部环境引用</code></li><li><code class="language-plaintext highlighter-rouge">环境记录</code> 可以暂时理解为当前作用域环境下的变量和方法（详细内容将在执行上下文中展开）</li><li><code class="language-plaintext highlighter-rouge">外部环境引用</code> 指向上级词法环境（如果存在）(详细将在作用域链文中展开)</li><li>在代码执行期间，每当 <code class="language-plaintext highlighter-rouge">JavaScript</code> 引擎遇到一个新的代码块、函数或 <code class="language-plaintext highlighter-rouge">catch</code> 子句时，就会创建一个新的词法环境。</li></ul><p>举个栗子:</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">data</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">test</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">name</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><p>在上面的代码中，存在两个作用域：全局作用域和函数 <code class="language-plaintext highlighter-rouge">test</code> 的作用域。</p><ul><li><code class="language-plaintext highlighter-rouge">全局作用域</code>：由于没有上层作用域，所以它的外部词法环境为 null。</li><li><code class="language-plaintext highlighter-rouge">test 函数的词法环境</code>：包含当前作用域下的变量（如 name），以及对上层全局环境的引用</li></ul><p>因此，<code class="language-plaintext highlighter-rouge">test</code> 函数的词法环境由它自己的变量（name）和外部的全局环境（data 等）组成。</p><h4 id="闭包定义解释">闭包定义解释</h4><blockquote><p><strong>闭包（closure）是一个函数以及其捆绑的周边环境状态（lexical environment，词法环境）的引用的组合;</strong></p></blockquote><p><em>闭包绑定了它定义时的词法环境，这就是为什么子函数在离开父函数的作用域后仍然可以访问父函数的变量。</em></p><p>举个栗子说明：</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">t1</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">data</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
  <span class="kd">function</span> <span class="nx">t2</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">t2</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">t_fn1</span> <span class="o">=</span> <span class="nx">t1</span><span class="p">();</span>
<span class="nx">t_fn1</span><span class="p">();</span>
</code></pre></div></div><p>我们可以通过模拟函数调用栈观察这一行为:</p><ol><li><p>首先全局环境入栈</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="p">[</span> <span class="nx">全局词法环境</span> <span class="p">(</span><span class="nx">环境记录</span><span class="p">:</span> <span class="p">{</span> <span class="nx">t1</span><span class="p">,</span> <span class="nx">t_fn1</span> <span class="p">}</span> <span class="o">+</span> <span class="nx">外部词法环境</span><span class="p">:</span> <span class="kc">null</span><span class="p">)</span> <span class="p">]</span>
</code></pre></div></div></li><li><p>调用 <code class="language-plaintext highlighter-rouge">t1()</code>, <code class="language-plaintext highlighter-rouge">t1</code> 环境入栈</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="p">[</span>
   <span class="nx">t1</span> <span class="nx">词法环境</span> <span class="p">(</span><span class="nx">环境记录</span><span class="p">:</span> <span class="p">{</span> <span class="nx">data</span><span class="p">,</span> <span class="nx">fn</span> <span class="p">}</span> <span class="o">+</span> <span class="nx">外部词法环境</span><span class="p">:</span> <span class="nx">全局词法环境</span><span class="p">),</span>
   <span class="nx">全局词法环境</span> <span class="p">(</span><span class="nx">环境记录</span><span class="p">:</span> <span class="p">{</span> <span class="nx">t1</span><span class="p">,</span> <span class="nx">t_fn1</span> <span class="p">}</span> <span class="o">+</span> <span class="nx">外部词法环境</span><span class="p">:</span> <span class="kc">null</span><span class="p">)</span>
 <span class="p">]</span>
</code></pre></div></div></li><li><p>调用 <code class="language-plaintext highlighter-rouge">t_fn1()</code>, <code class="language-plaintext highlighter-rouge">t2</code> 环境入栈</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="p">[</span>
   <span class="nx">t2</span> <span class="nx">词法环境</span> <span class="p">(</span><span class="nx">环境记录</span><span class="p">:</span> <span class="p">{}</span> <span class="o">+</span> <span class="nx">外部词法环境</span><span class="p">:</span> <span class="nx">t1</span> <span class="nx">词法环境</span><span class="p">),</span>
   <span class="nx">t1</span> <span class="nx">词法环境</span> <span class="p">(</span><span class="nx">环境记录</span><span class="p">:</span> <span class="p">{</span> <span class="nx">data</span><span class="p">,</span> <span class="nx">fn</span> <span class="p">}</span> <span class="o">+</span> <span class="nx">外部词法环境</span><span class="p">:</span> <span class="nx">全局词法环境</span><span class="p">),</span>
   <span class="nx">全局词法环境</span> <span class="p">(</span><span class="nx">环境记录</span><span class="p">:</span> <span class="p">{</span> <span class="nx">t1</span><span class="p">,</span> <span class="nx">t_fn1</span> <span class="p">}</span> <span class="o">+</span> <span class="nx">外部词法环境</span><span class="p">:</span> <span class="kc">null</span><span class="p">)</span>
 <span class="p">]</span>
</code></pre></div></div></li></ol><p>可以打开浏览器验证这一行为，如下图</p><p><img src="https://scriptoverture.github.io/blog/images/posts/Snipaste_2024-09-04_19-57-02.png" alt="" /></p><p>从这个示例中，我们可以得出一些结论：</p><ul><li>变量是由环境记录中获取。</li><li>如果某个词法环境被引用，它不会被销毁。<ul><li>那么这一行为就延长了 <code class="language-plaintext highlighter-rouge">t1 词法环境</code> 的生命周期。</li></ul></li></ul><h4 id="疑问">疑问</h4><p>好现在我再抛出几个疑问</p><ol><li><p><code class="language-plaintext highlighter-rouge">t1</code> 函数会形成闭包吗?</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">function</span> <span class="nx">t1</span><span class="p">()</span> <span class="p">{</span>
   <span class="kd">let</span> <span class="nx">data</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
   <span class="kd">function</span> <span class="nx">t2</span><span class="p">()</span> <span class="p">{}</span>
   <span class="k">return</span> <span class="nx">t2</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div></div></li><li><p>如果通过全局变量引用 <code class="language-plaintext highlighter-rouge">t1</code> 的活动对象，<code class="language-plaintext highlighter-rouge">t1</code> 执行完毕后，该对象仍然存活，这会形成闭包吗？</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">let</span> <span class="nx">data</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
 <span class="kd">function</span> <span class="nx">t1</span><span class="p">()</span> <span class="p">{</span>
   <span class="kd">let</span> <span class="nx">record</span> <span class="o">=</span> <span class="p">{};</span>
   <span class="nx">data</span> <span class="o">=</span> <span class="nx">record</span><span class="p">;</span>
 <span class="p">}</span>

 <span class="kd">function</span> <span class="nx">t2</span><span class="p">()</span> <span class="p">{</span>
   <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
 <span class="p">}</span>

 <span class="nx">t1</span><span class="p">();</span>
 <span class="nx">t2</span><span class="p">();</span>
</code></pre></div></div></li><li><p>上述两种方式延长变量生命周期的方式存在区别吗？</p></li></ol><h3 id="闭包的优缺点">闭包的优缺点</h3><p>根据上面的分析，你可能会惊讶的发现: 所有的函数都会包含周边<code class="language-plaintext highlighter-rouge">词法环境</code>。 某种程度上来讲全局作用域下所有函数都是闭包。</p><p>为了方便后续理解这里做一个区分 (<strong>非官方定义</strong>)：</p><ul><li><p><code class="language-plaintext highlighter-rouge">隐式闭包</code> 函数在其内部不使用外部环境中的变量</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">test</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">???</span><span class="dl">"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div></li><li><p><code class="language-plaintext highlighter-rouge">幽灵隐式闭包</code> 函数在其内部不使用外部环境中的变量</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">t1</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">data</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
  <span class="kd">function</span> <span class="nx">t2</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">return</span> <span class="nx">t2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div></li><li><p><code class="language-plaintext highlighter-rouge">显示闭包</code> 函数在其内部使用了外部环境中的变量</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">t1</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">data</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
  <span class="kd">function</span> <span class="nx">t2</span><span class="p">()</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">)}</span>
  <span class="k">return</span> <span class="nx">t2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div></li></ul><p>需注意虽然 <code class="language-plaintext highlighter-rouge">隐式闭包</code> 和 <code class="language-plaintext highlighter-rouge">幽灵隐式闭包</code> 看上去没有使用外部词法环境人畜无害； 但他们的情况完全不一样。</p><ul><li>对于 <code class="language-plaintext highlighter-rouge">test</code> 函数执行完即可被销毁。</li><li>对于 <code class="language-plaintext highlighter-rouge">幽灵隐式闭包 t1</code> 函数执行完并不会销毁，因为 <code class="language-plaintext highlighter-rouge">t2</code> 存在对其 <code class="language-plaintext highlighter-rouge">外部词法环境</code> 引用。<ul><li><code class="language-plaintext highlighter-rouge">t1</code> 只会在 <code class="language-plaintext highlighter-rouge">t2</code> 所有引用它的闭包被销毁之后才会被回收。</li></ul></li></ul><p>（回收这块详细见垃圾回收文）</p><h4 id="闭包的优缺点总结">闭包的优缺点总结</h4><ul><li><strong>缺点</strong> 内存不能及时释放，可能导致内存泄漏</li><li><strong>缺点</strong> 性能开销高，多层嵌套会保留每层词法环境</li><li><strong>优点</strong> 提供数据封装私有化</li><li>…more</li></ul><h4 id="如何使用">如何使用</h4><p>根据上面对闭包原理及其优缺点了解之后, 日常编码中该如果使用闭包，以规避内存泄漏和性能问题</p><ol><li><p>消除不必要的 <code class="language-plaintext highlighter-rouge">幽灵隐式闭包</code>。</p><blockquote><p>在这种情况下，闭包的存在并没有任何意义，反而会导致不必要的内存占用和性能开销。</p></blockquote><p>官方就已经提供了很好的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures#%E6%80%A7%E8%83%BD%E8%80%83%E9%87%8F">示例</a></p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">function</span> <span class="nx">MyObject</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">.</span><span class="nx">toString</span><span class="p">();</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">message</span> <span class="o">=</span> <span class="nx">message</span><span class="p">.</span><span class="nx">toString</span><span class="p">();</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">getName</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
     <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
   <span class="p">};</span>

   <span class="k">this</span><span class="p">.</span><span class="nx">getMessage</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
     <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">message</span><span class="p">;</span>
   <span class="p">};</span>
 <span class="p">}</span>
</code></pre></div></div><p>优化调整:</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">function</span> <span class="nx">MyObject</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">.</span><span class="nx">toString</span><span class="p">();</span>
   <span class="k">this</span><span class="p">.</span><span class="nx">message</span> <span class="o">=</span> <span class="nx">message</span><span class="p">.</span><span class="nx">toString</span><span class="p">();</span>
 <span class="p">}</span>
 <span class="nx">MyObject</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">({</span>
   <span class="nx">getName</span><span class="p">()</span> <span class="p">{</span>
     <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
   <span class="p">},</span>
   <span class="nx">getMessage</span><span class="p">()</span> <span class="p">{</span>
     <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">message</span><span class="p">;</span>
   <span class="p">},</span>
 <span class="p">});</span>
</code></pre></div></div></li><li><p>谨慎使用闭包多层嵌套。</p><blockquote><p>深层次的嵌套闭包会导致每层的词法环境被保留在内存中，尤其在复杂的应用中，容易造成性能开销。避免使用多层嵌套闭包可以减少内存占用并提高性能。</p></blockquote><p><em>如果需要嵌套闭包，确保每一层闭包的存在都是必要的。</em></p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">// 非必要的多层嵌套闭包</span>
 <span class="kd">function</span> <span class="nx">outer</span><span class="p">()</span> <span class="p">{</span>
   <span class="kd">let</span> <span class="nx">outerVar</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">outer</span><span class="dl">"</span><span class="p">;</span>
   <span class="kd">function</span> <span class="nx">middle</span><span class="p">()</span> <span class="p">{</span>
     <span class="kd">let</span> <span class="nx">middleVar</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">middle</span><span class="dl">"</span><span class="p">;</span>
     <span class="kd">function</span> <span class="nx">inner</span><span class="p">()</span> <span class="p">{</span>
       <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">outerVar</span><span class="p">,</span> <span class="nx">middleVar</span><span class="p">);</span>
     <span class="p">}</span>
     <span class="k">return</span> <span class="nx">inner</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="nx">middle</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div></div><p>优化调整:</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">function</span> <span class="nx">outer</span><span class="p">()</span> <span class="p">{</span>
   <span class="kd">let</span> <span class="nx">outerVar</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">outer</span><span class="dl">"</span><span class="p">;</span>
   <span class="kd">let</span> <span class="nx">middleVar</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">middle</span><span class="dl">"</span><span class="p">;</span>
      
   <span class="k">return</span> <span class="p">[</span><span class="nx">outerVar</span><span class="p">,</span> <span class="nx">middleVar</span><span class="p">];</span>
 <span class="p">}</span>

 <span class="kd">function</span> <span class="nx">inner</span><span class="p">(</span><span class="nx">outerVar</span><span class="p">,</span> <span class="nx">middleVar</span><span class="p">)</span> <span class="p">{</span>
   <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">outerVar</span><span class="p">,</span> <span class="nx">middleVar</span><span class="p">);</span>
 <span class="p">}</span>

 <span class="nx">inner</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">outer</span><span class="p">())</span>  
</code></pre></div></div></li><li><p>及时释放不再需要的闭包</p></li><li><p>小心 <code class="language-plaintext highlighter-rouge">this指向</code>， 避免内存泄漏。</p></li></ol><h3 id="总结">总结</h3><p>通过本文，我们了解了：</p><ol><li><p><strong>闭包的定义和工作原理：</strong> 闭包（ <code class="language-plaintext highlighter-rouge">closure</code> ）是一个函数以及其捆绑的周边环境状态（ <code class="language-plaintext highlighter-rouge">lexical environment</code> ，词法环境）的引用的组合; 词法环境是由当前作用域中的变量和对外部环境的引用组成。</p></li><li><p><strong>词法环境的结构和生命周期：</strong> 词法环境由环境记录和对外部词法环境的引用组成。当 <code class="language-plaintext highlighter-rouge">JavaScript</code> 代码块、函数或其他作用域被执行时，会创建新的词法环境。 如果词法环境被引用，他的生命周期会被延长。</p></li><li><p><strong>闭包的缺点：</strong> 由于闭包保留了其词法环境的引用，会导致内存不能及时释放，可能造成内存泄漏和性能问题，特别是在深层嵌套闭包的情况下。</p></li><li><p><strong>如何合理使用闭包：</strong></p><ul><li>避免不必要的闭包。</li><li>谨慎使用多层嵌套的闭包。</li><li>及时释放不再需要的闭包。</li><li>小心 this 的指向，避免内存泄漏。</li></ul></li></ol><p>参考文章：</p><ul><li><a href="https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">维基百科 闭包</a></li><li><a href="https://262.ecma-international.org/11.0/#sec-executable-code-and-execution-contexts">ECMA 词法环境</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures">MDN Closures</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures#%E6%80%A7%E8%83%BD%E8%80%83%E9%87%8F">MDN 性能考量</a></li></ul><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="https://scriptoverture.github.io/blog" target="_blank">scriptoverture</a></li><li>本文链接：<a href="https://scriptoverture.github.io/blog/2024/09/02/%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85/" target="_blank">https://scriptoverture.github.io/blog/2024/09/02/%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"> <script src="https://giscus.app/client.js" data-repo="scriptoverture/blog" data-repo-id="R_kgDOMq9zeA" data-category="Announcements" data-category-id="DIC_kwDOMq9zeM4CiHLc" data-mapping="title" data-strict="1" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous" async> </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://scriptoverture.github.io/blog/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://scriptoverture.github.io/blog/assets/search_data.json?v=1758300993', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://scriptoverture.github.io/blog/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2024 <span title="scriptoverture">scriptoverture</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/https:/blog" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://scriptoverture.github.io/blog/" title="首页" target="">首页</a></li><li> <a href="https://scriptoverture.github.io/blog/categories/" title="分类" target="">分类</a></li><li> <a href="https://scriptoverture.github.io/blog/archives/" title="归档" target="">归档</a></li><li> <a href="https://scriptoverture.github.io/blog/open-source/" title="开源" target="">开源</a></li><li> <a href="https://scriptoverture.github.io/blog/fragments/" title="片段" target="">片段</a></li><li> <a href="https://scriptoverture.github.io/blog/wiki/" title="维基" target="">维基</a></li><li> <a href="https://scriptoverture.github.io/blog/links/" title="链接" target="">链接</a></li><li> <a href="https://scriptoverture.github.io/blog/about/" title="关于" target="">关于</a></li><li><a href="https://scriptoverture.github.io/blog/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://scriptoverture.github.io/blog/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script></body></html>
