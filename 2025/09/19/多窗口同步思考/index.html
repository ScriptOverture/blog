<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>实现多窗口同步的副作用归一化实践 &mdash; overture</title><link rel="stylesheet" href="https://scriptoverture.github.io/blog/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://scriptoverture.github.io/blog/assets/css/components/collection.css"><link rel="stylesheet" href="https://scriptoverture.github.io/blog/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://scriptoverture.github.io/blog/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://scriptoverture.github.io/blog/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://scriptoverture.github.io/blog/assets/css/globals/common.css"><link rel="stylesheet" href="https://scriptoverture.github.io/blog/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://scriptoverture.github.io/blog/assets/css/posts/index.css"><link rel="stylesheet" href="https://scriptoverture.github.io/blog/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://mazhuang.org/rouge-themes/dist/github.css"><link rel="canonical" href="https://scriptoverture.github.io/blog/2025/09/19/%E5%A4%9A%E7%AA%97%E5%8F%A3%E5%90%8C%E6%AD%A5%E6%80%9D%E8%80%83/"><link rel="alternate" type="application/atom+xml" title="overture" href="https://scriptoverture.github.io/blog/feed.xml"><link rel="shortcut icon" href="https://scriptoverture.github.io/blog/favicon.ico"><meta property="og:title" content="实现多窗口同步的副作用归一化实践"><meta name="keywords" content="副作用归一化, 窗口同步, 前端架构, JavaScript, 异步编程, 自动化测试"><meta name="og:keywords" content="副作用归一化, 窗口同步, 前端架构, JavaScript, 异步编程, 自动化测试"><meta name="description" content="多窗口同步方案"><meta name="og:description" content="多窗口同步方案"><meta property="og:url" content="https://scriptoverture.github.io/blog/2025/09/19/%E5%A4%9A%E7%AA%97%E5%8F%A3%E5%90%8C%E6%AD%A5%E6%80%9D%E8%80%83/"><meta property="og:site_name" content="overture"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2025-09-19"> <script src="https://scriptoverture.github.io/blog/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://scriptoverture.github.io/blog/assets/js/main.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-Z6VKGSE98P"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-Z6VKGSE98P'); </script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://scriptoverture.github.io/blog/" title="overture"><span class="octicon octicon-mark-github"></span> overture</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://scriptoverture.github.io/blog/" class="site-header-nav-item" target="" title="首页">首页</a> <a href="https://scriptoverture.github.io/blog/categories/" class="site-header-nav-item" target="" title="分类">分类</a> <a href="https://scriptoverture.github.io/blog/archives/" class="mobile-hidden site-header-nav-item" target="" title="归档">归档</a> <a href="https://scriptoverture.github.io/blog/open-source/" class="mobile-hidden site-header-nav-item" target="" title="开源">开源</a> <a href="https://scriptoverture.github.io/blog/fragments/" class="site-header-nav-item" target="" title="片段">片段</a> <a href="https://scriptoverture.github.io/blog/wiki/" class="site-header-nav-item" target="" title="维基">维基</a> <a href="https://scriptoverture.github.io/blog/links/" class="mobile-hidden site-header-nav-item" target="" title="链接">链接</a> <a href="https://scriptoverture.github.io/blog/about/" class="site-header-nav-item" target="" title="关于">关于</a> <a class="mobile-hidden" href="https://scriptoverture.github.io/blog/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="实现多窗口同步的副作用归一化实"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">实现多窗口同步的副作用归一化实践</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2025/09/19 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://scriptoverture.github.io/blog/categories/#WebDevelopment" title="WebDevelopment">WebDevelopment</a> </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://scriptoverture.github.io/blog/categories/#JavaScript" title="JavaScript">JavaScript</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 8419 字，约 25 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h2 id="多窗口同步方案">多窗口同步方案</h2><h4 id="概念介绍从纯函数思想到副作用归一化">概念介绍：从纯函数思想到副作用归一化</h4><p>将窗口抽象想象为函数调用：<strong>如果能让所有窗口都表现为”纯函数”，就能解决同步问题</strong>。</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 理想状态：窗口 = 纯函数
Window(userActions) =&gt; UIState

// 纯函数特性：相同输入 → 相同输出
Window(actions) === Window(actions) // 总是为 true
</code></pre></div></div><p>如果窗口表现为纯函数，用户输入行为对应存函数入参，传入相同<strong>入参</strong>执行后可以得到完全一致的页面输出，从而实现多个窗口效果同步。</p><p>然后，事实是<strong>副作用</strong>无处不在：</p><ul><li>网络请求：HTTP调用，API调用</li><li>埋点曝光：行为统计，数据上报</li><li>随机数状态：UUID生成，时间戳获取等</li><li>存储操作</li></ul><p>副作用产生的不确定性，导致相同入参调用还是会产生不同结果。 举例来说🌰：</p><div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">uuid</span><span class="p">,</span> <span class="nx">setUuid</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">();</span>
<span class="p">&lt;</span><span class="nt">div</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="nx">handleTest</span><span class="si">}</span><span class="p">&gt;</span>button--<span class="si">{</span><span class="nx">uuid</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>

<span class="kd">function</span> <span class="nx">handleTest</span><span class="p">()</span> <span class="p">{</span>
   <span class="kd">const</span> <span class="nx">newUuid</span> <span class="o">=</span> <span class="nx">getUuid</span><span class="p">();</span>
   <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newUuid</span><span class="p">);</span>
   <span class="nx">setUuid</span><span class="p">(</span><span class="nx">newUuid</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div><p>哪怕俩个窗口都触发调用 <code class="language-plaintext highlighter-rouge">handleTest</code> 方法，界面展示会因为 <code class="language-plaintext highlighter-rouge">Uuid</code> 的随机性出现差异化。</p><h4 id="副作用归一化">副作用归一化</h4><p>什么是副作用归一化？</p><p><strong>副作用归一化 = 让”不确定操作”变成”确定操作”</strong> 简单来说：由一个窗口先执行完整流程期间自动收集对应副作用结果，其他窗口执行相同操作副作用计算从记录中获取副作用结果，而不重新计算结果。</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Leader窗口(发起)：用户操作 → （执行副作用 → 收集结果 → 缓存）[劫持] → 同步
Other窗口(同步)：用户操作 → （劫持副作用 → 从记录获取）[劫持] → 使用结果
</code></pre></div></div><p>副作用归一化难点：</p><ul><li>保障同一个事件在多个窗口调用一致的上下文标识</li><li>怎么保障副作用存储顺序，以及缓存恢复顺序</li><li>异步及异步嵌套场景，怎么保障存储顺序</li><li>异步上下文丢失错误场景，怎么主动恢复</li><li>怎么确保一定有可以消费的副作用缓存记录</li><li>内存管理与清理</li></ul><h4 id="实现方案">实现方案</h4><h5 id="上下文一致性-contextid">上下文一致性 ContextId</h5><p><strong>方式一</strong>：利用 <code class="language-plaintext highlighter-rouge">Babel，SWC</code> 这类编译工具，在编译阶段为每个用户交互操作自动注入唯一标识符，这个过程对开发者完全透明（开发人员不可见）</p><p>事件劫持 + 上下文标识自动绑定:</p><pre><code class="language-typesctipt">// 编写的原始代码
&lt;div onClick={handleClick}&gt;

// 自动转换后的代码（开发者不可见）
&lt;div onClick={syncEvent(handleClick, 'sync-唯一id')} syncKind={'sync-唯一id'}&gt;
通过编译时注入的唯一标识符，确保多个窗口在执行相同用户操作时拥有一致的执行上下文
// 所有窗口中相同的交互元素都拥有相同的syncKind
TabA: &lt;button syncKind="sync-uuid-002" /&gt;
TabB: &lt;button syncKind="sync-uuid-002" /&gt;  
TabC: &lt;button syncKind="sync-uuid-002" /&gt;

// 上下文的一致性标识
</code></pre><p><strong>方式二</strong>：动态生成事件上下文标识，将事件与标识捆绑同步给其他窗口， 也能保障事件执行上下文的一致性。 简单对比： 动态生成对应副作用不方便细颗粒管理</p><ol><li>没法感知事件执行次数</li><li>没法回放调试</li><li>调用链路不方便扩展</li></ol><p>根据静态特征，很方便实现插件机制举例🌰：</p><div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">sendMessageKind</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Component_sync_demo</span><span class="dl">'</span>

<span class="kd">const</span> <span class="nx">Component</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">&lt;</span><span class="nt">div</span> <span class="na">sync-bind</span><span class="p">=</span><span class="si">{</span><span class="nx">sendMessageKind</span><span class="si">}</span><span class="p">&gt;</span>xxxx<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="kd">const</span> <span class="nx">syncPlugins</span> <span class="o">=</span> <span class="p">{</span>
   <span class="p">[</span><span class="nx">sendMessageKind</span><span class="p">]:</span> <span class="p">{</span>
      <span class="c1">// 用户行为执行前 () =&gt; void;</span>
      <span class="c1">// 消息同步前 () =&gt; void;</span>
      <span class="c1">// 消息接受前 () =&gt; void;</span>
      <span class="c1">// 消息接受方执行完毕 () =&gt; void;</span>
      <span class="c1">// ....</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>上例 <code class="language-plaintext highlighter-rouge">sync-bind</code> 可覆盖 <code class="language-plaintext highlighter-rouge">Babel</code> 自动生成的唯一值。 静态方便扩展，方便提供不同阶段钩子，同时有利后续链路回放调试。</p><h5 id="用户行为同步">用户行为同步</h5><h6 id="发送方">发送方</h6><div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">syncEvent</span><span class="p">(</span><span class="nx">eventHandler</span><span class="p">,</span> <span class="nx">syncContextId</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">return</span> <span class="p">(...</span><span class="nx">args</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="c1">// 标识当前操作上下文 -&gt; syncContextId</span>

      <span class="c1">// 事件执行</span>
      <span class="nx">eventHandler</span><span class="p">(...</span><span class="nx">args</span><span class="p">)</span>

      <span class="c1">// 窗口同步</span>
      <span class="nx">syncMesssageInfo</span><span class="p">(</span>
         <span class="nx">syncContextId</span><span class="p">,</span> <span class="c1">// 操作上下文</span>
         <span class="nx">effectRecords</span><span class="p">,</span> <span class="c1">// 事件调用链同步上下文副作用记录</span>
         <span class="nx">eventType</span><span class="p">,</span>     <span class="c1">// 事件类型</span>
         <span class="p">...</span><span class="nx">more</span>
      <span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p><strong>发送方执行流程</strong>：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
用户操作 → 事件劫持 → 上下文声明 → 原始事件执行 → 副作用收集 → 窗口同步
         ←————————————— 插件钩子覆盖整个生命周期 —————————————→
</code></pre></div></div><h6 id="接受方">接受方</h6><div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">receiveMessage</span><span class="p">({</span> <span class="nx">payload</span> <span class="p">})</span> <span class="p">{</span>
   <span class="kd">const</span> <span class="p">{</span>
      <span class="nx">syncContextId</span><span class="p">,</span>
      <span class="nx">effectRecords</span><span class="p">,</span>
      <span class="nx">eventType</span>
   <span class="p">}</span> <span class="o">=</span> <span class="nx">payload</span><span class="p">;</span>

   <span class="c1">// 副作用恢复</span>

   <span class="kd">const</span> <span class="nx">eventDom</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s2">`sync-</span><span class="p">${</span><span class="nx">syncContextId</span><span class="p">}</span><span class="s2">`</span><span class="p">)</span>
   <span class="nx">eventDom</span><span class="p">[</span><span class="nx">eventType</span><span class="p">]?.()</span>
<span class="p">}</span>
</code></pre></div></div><p><strong>接收方执行流程</strong>：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>消息接收 → 副作用上下文恢复 → 目标元素定位 → 原生事件模拟 → 事件劫持处理
</code></pre></div></div><h4 id="副作用收集-️">副作用收集 ️</h4><p><strong>方案思考</strong></p><p>以下面函数举例🌰：</p><div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">handleTest</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
   <span class="kd">const</span> <span class="nx">u1</span> <span class="o">=</span> <span class="nx">getUuid</span><span class="p">();</span> <span class="c1">// &lt;- 随机性，需要记录</span>
   <span class="kd">const</span> <span class="nx">t1</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">();</span><span class="c1">// &lt;- 瞬态，需要记录</span>
   <span class="kd">const</span> <span class="nx">newU1</span> <span class="o">=</span> <span class="s2">`sync_</span><span class="p">${</span><span class="nx">u1</span><span class="p">}</span><span class="s2">_last`</span><span class="p">;</span> <span class="c1">// u1一致newU1一致，自动计算</span>
   <span class="kd">const</span> <span class="nx">u2</span> <span class="o">=</span> <span class="nx">getUuid</span><span class="p">();</span> <span class="c1">// &lt;- 随机性，需要记录</span>
<span class="p">}</span>
</code></pre></div></div><h5 id="按类型分组存储初始方案">按类型分组存储（初始方案）</h5><p>最初尝试为不同类型的副作用分配独立队列：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
   uuid: [u1, u2],
   date: [t1]
}
</code></pre></div></div><p>考虑到异步场景，扩展为同步/异步分离结构：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
   async: {
      uuid: [u1, u2],
      date: [t1]
   },
   sync: {
      uuid: [],
      date: []
   }
}
</code></pre></div></div><h6 id="异步顺序问题">异步顺序问题</h6><p>然而，异步不同于同步这般简单可控，由事件循环调度上下文切换；无法保障顺序一致性：</p><div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
   <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">log1</span><span class="dl">'</span><span class="p">)</span>
<span class="p">},</span> <span class="mi">2</span><span class="p">)</span>
<span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
   <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">log2</span><span class="dl">'</span><span class="p">)</span>
<span class="p">},</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div></div><p>这种不确定性在复杂的异步嵌套场景下更加明显，上述的分类存储方案无法解决顺序问题。</p><h5 id="插槽机制">插槽机制</h5><p>为了解决异步顺序问题，这里引入”插槽”概念，通过“静态分析”确保执行顺序的一致性。</p><p><strong>插槽类型定义</strong>：</p><ul><li>同步插槽：立即执行并赋值</li><li>异步插槽：等待事件循环调度，但插槽位置预先确定</li><li>上下文继承：异步回调执行时，会继承父级插槽上下文，形成嵌套的插槽序列</li></ul><p>这样关注面不再是同步/异步的区别，而是调用顺序的确定性。 <strong>示例分析</strong>🌰：</p><div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">handleTest</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
   <span class="kd">const</span> <span class="nx">u1</span> <span class="o">=</span> <span class="nx">getUuid</span><span class="p">();</span>   <span class="c1">// 0  &lt;-自增标识</span>
   <span class="kd">const</span> <span class="nx">t1</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">();</span>  <span class="c1">// 1</span>
   <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>      <span class="c1">// 2</span>
      <span class="nx">getUuid</span><span class="p">()</span>            <span class="c1">// 2-0</span>
      <span class="nx">getUuid</span><span class="p">()</span>            <span class="c1">// 2-1</span>
   <span class="p">})</span>
   <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>      <span class="c1">// 3</span>
      <span class="nx">getUuid</span><span class="p">()</span>            <span class="c1">// 3-0</span>
   <span class="p">},</span> <span class="mi">1000</span><span class="p">)</span>
   <span class="kd">const</span> <span class="nx">newU1</span> <span class="o">=</span> <span class="s2">`sync_</span><span class="p">${</span><span class="nx">u1</span><span class="p">}</span><span class="s2">_last`</span><span class="p">;</span>
   <span class="kd">const</span> <span class="nx">u2</span> <span class="o">=</span> <span class="nx">getUuid</span><span class="p">();</span> 	<span class="c1">// 4</span>
<span class="p">}</span>
</code></pre></div></div><p><strong>插槽上下文结构</strong>：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// eventContext
eventContext = [
   slot(u1 = getUuid()),
   slot(t1 = Date.now()),
   slot(syncContext_2), // 异步上下文
   slot(syncContext_3), // 异步上下文
   slot(u2 = getUuid())
]


// 异步上下文syncContext2
syncContext2 = [
   slot(getUuid())// 2-0, &lt;-自增标识 延续父插槽标识
   slot(getUuid())// 2-1,
]

// 异步上下文syncContext3
syncContext3 = [
   slot(getUuid())// 3-0,
]
</code></pre></div></div><p>每个插槽生成自增标识，并延续父插槽标识，形成层次化的标识体系。</p><h4 id="副作用同步机制">副作用同步机制</h4><h5 id="分阶段同步">分阶段同步</h5><ul><li>主上下文完成：事件执行完毕，同步上下文中“同步插槽副作用”。</li><li>异步上下文完成：当每个异步上下文执行完毕，自动同步当前上下文副作用。</li></ul><p>以上文“异步上下文 <code class="language-plaintext highlighter-rouge">syncContext2</code> ”同步举例🌰：</p><div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// syncContext2 的父级插槽为</span>
<span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>      <span class="c1">// slotKind =&gt; 2</span>
   <span class="nx">getUuid</span><span class="p">()</span>            <span class="c1">// slotKind =&gt; 2-0</span>
   <span class="nx">getUuid</span><span class="p">()</span>            <span class="c1">// slotKind =&gt; 2-1</span>
<span class="p">})</span>
</code></pre></div></div><p><strong>上下文副作用提取</strong></p><p>利用插槽的自增标识特性（延续父插槽标识）。通过简单标识前置位匹配，可以很方便将当前上下文副作用提取出来：</p><div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nx">EffectStore</span><span class="p">)</span>
<span class="p">.</span><span class="nx">filter</span><span class="p">(([</span><span class="nx">key</span><span class="p">])</span> <span class="o">=&gt;</span> <span class="nx">key</span><span class="p">.</span><span class="nx">starsWith</span><span class="p">(</span><span class="s2">`slotKind =&gt; 2`</span><span class="p">))</span>
<span class="c1">// [[2-0, xx], [2-1, xx]]</span>
</code></pre></div></div><p>存在同步副作用，会自动推送到其他窗口。</p><p><strong>接收方副作用恢复</strong></p><p>接收方事件调用时，同样会收集插槽，每个插槽的副作用结果从记录中根据相同插槽标识获取恢复：</p><div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">handleTest</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
   <span class="kd">const</span> <span class="nx">u1</span> <span class="o">=</span> <span class="nx">getUuid</span><span class="p">();</span>   <span class="c1">// &lt;劫持  根据 slotKind_0 获取记录</span>
   <span class="kd">const</span> <span class="nx">t1</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">();</span>  <span class="c1">// &lt;劫持  根据 slotKind_1 获取记录</span>
   <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>      <span class="c1">// &lt;劫持  根据 slotKind_2 获取记录</span>
      <span class="nx">getUuid</span><span class="p">()</span>            <span class="c1">// &lt;劫持  根据 slotKind_2_0 获取记录</span>
      <span class="nx">getUuid</span><span class="p">()</span>            <span class="c1">// &lt;劫持  根据 slotKind_2_1 获取记录</span>
   <span class="p">})</span>
   <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>      <span class="c1">// &lt;劫持  根据 slotKind_3 获取记录</span>
      <span class="nx">getUuid</span><span class="p">()</span>            <span class="c1">// &lt;劫持  根据 slotKind_3_0 获取记录</span>
   <span class="p">},</span> <span class="mi">1000</span><span class="p">)</span>
   <span class="kd">const</span> <span class="nx">newU1</span> <span class="o">=</span> <span class="s2">`sync_</span><span class="p">${</span><span class="nx">u1</span><span class="p">}</span><span class="s2">_last`</span><span class="p">;</span>
   <span class="kd">const</span> <span class="nx">u2</span> <span class="o">=</span> <span class="nx">getUuid</span><span class="p">();</span> 	<span class="c1">// &lt;劫持  根据 slotKind_4 获取记录</span>
<span class="p">}</span>
</code></pre></div></div><p>这样就可以得到一致的结果</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>发送方handleTest() === 同步方A_handleTest() === 同步方B_handleTest()
</code></pre></div></div><h5 id="await-分段推送">await 分段推送</h5><p><strong>await 上下文切割问题</strong></p><p>根据上文设计，同步代码会在首次执行完毕后立即同步，异步操作会在完成时自动触发同步。但 await 关键字会切割执行链路，导致 await 后续的同步操作无法被正确同步。</p><p>举个例子🌰：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 插槽序列分析
[
   slot(sync_1),    // 同步操作
   slot(await_2),   // 异步等待点
   slot(sync_3),    // await 后的同步操作
   slot(sync_4),    // await 后的同步操作  
   slot(await_5),   // 下一个异步等待点
]
</code></pre></div></div><p>在上述序列中，<code class="language-plaintext highlighter-rouge">sync_3</code> 和 <code class="language-plaintext highlighter-rouge">sync_4</code> 由于位于 <code class="language-plaintext highlighter-rouge">await_2</code> 之后，会在异步恢复时执行，但此时同步上下文已经丢失，导致这些操作无法被正确同步到其他窗口。</p><p><strong>解决方案：分段推送策略</strong></p><p>以 <code class="language-plaintext highlighter-rouge">await</code> 为分割点，将执行链路划分为多个同步段： <strong>切分时机</strong></p><ul><li>首次执行阶段：仅同步 <code class="language-plaintext highlighter-rouge">sync_1</code></li><li>延时同步阶段：每个 <code class="language-plaintext highlighter-rouge">await</code> 操作完成时，不立即同步结果，而是继续执行后续同步操作，直到遇到下一个 <code class="language-plaintext highlighter-rouge">await</code> 或执行结束，然后将整个段的结果一次性同步</li></ul><p><strong>分段示例：</strong></p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 段1：立即同步
[slot(sync_1)] → 立即推送

// 段2：await_2 完成后同步
[slot(await_2), slot(sync_3), slot(sync_4)] → await_2 完成后推送

// 段3：await_5 完成后同步  
[slot(await_5)] → await_5 完成后推送
</code></pre></div></div><p>这种避免了 await 切割导致的上下文丢失问题。</p><p><strong>Promise 消费方式识别</strong></p><p>在插槽设计中，我们只有 <code class="language-plaintext highlighter-rouge">同步插槽</code> 、<code class="language-plaintext highlighter-rouge">异步插槽</code> 和 <code class="language-plaintext highlighter-rouge">异步Promise插槽</code> 的概念。关键问题是： 如何区分 <code class="language-plaintext highlighter-rouge">Promise</code> 是通过同步的 <code class="language-plaintext highlighter-rouge">.then()</code> 消费，还是通过阻塞的 <code class="language-plaintext highlighter-rouge">await</code> 消费？</p><p><strong>识别方案</strong></p><p>每个执行上下文完成时，必然能够获取到所有同步操作的结果。利用这个特性来判断 <code class="language-plaintext highlighter-rouge">Promise</code> 的消费方式：</p><ul><li><code class="language-plaintext highlighter-rouge">await Promise</code> 插槽获得结果后，会记录并继续执行后续代码</li><li>如果某个同步插槽在上下文结束时仍无结果，说明它依赖于 <code class="language-plaintext highlighter-rouge">Promise</code> 的 <code class="language-plaintext highlighter-rouge">await</code> 结果（处于 <code class="language-plaintext highlighter-rouge">await</code> 下方）</li><li>将这些未完成的同步插槽与对应的 <code class="language-plaintext highlighter-rouge">Promise</code> 插槽归为一组</li></ul><p><strong>分段推送逻辑</strong> 当遇到下一个 <code class="language-plaintext highlighter-rouge">Promise</code> 插槽时：</p><ul><li><strong><code class="language-plaintext highlighter-rouge">.then()</code> 场景</strong>：忽略，继续收集后续插槽直到上下文结束。</li><li><strong><code class="language-plaintext highlighter-rouge">await</code> 场景</strong>：识别为当前上下文的最后一个 <code class="language-plaintext highlighter-rouge">Promise</code> 插槽，立即同步当前批次的所有记录</li></ul><p><strong>副作用绑定理念</strong> 其实插槽绑定理念与经常使用的 <code class="language-plaintext highlighter-rouge">React Hooks</code> 底层绑定非常相似</p><ul><li>纯函数不能绑定副作用，<code class="language-plaintext highlighter-rouge">hooks</code> 链挂载组件 <code class="language-plaintext highlighter-rouge">fiber</code> 单元上</li><li>函数组件初次渲染，构建 <code class="language-plaintext highlighter-rouge">hooks</code> 副作用记录 （类似多窗口发送方， 记录副作用）</li><li>函数组件后续渲染，查询 <code class="language-plaintext highlighter-rouge">hooks</code> 副作用记录 (类似多窗口被同步方， 从记录恢复副作用)</li></ul><p>Demo 版本：https://github.com/ScriptOverture/EffectSync</p><p><del>副作用保障上方案：</del> <del>1. 因为该方案，一个事件执行会有多段同步，首次执行几乎不会因窗口刷新阻断（函数调用非常非常快） a. 存在 cpu 密集型阻塞操作另外优化</del> <del>2. 如果首次同步后，异步计算中窗口关闭了，某一个leader窗口获取主动权，更新剩下异步上下文标识（需要调用/被同步），使其调用记录副作用并推动其他窗口 因为每个窗口都是独立的FN, 这个特性导致任何窗口任意时间段都可以被选中为主窗口，甚至可以模糊掉传统leader窗口的概念，也可以是当前窗口执行其他窗口记录。</del></p><h4 id="内存管理与清理">内存管理与清理</h4><p><strong>问题分析</strong></p><p>当前方案存在以下内存管理问题：</p><ul><li>单次执行假设：方案设计基于不同事件只执行一次的假设</li><li>持久化积累：副作用记录在收集后持续持久化，缺乏释放机制</li><li>存储边界模糊：同一事件多次执行、不同事件调用之间没有明确的副作用存储划分</li></ul><p>基于上述问题，采用按执行实例分组的存储结构：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
   contextId: {
   effects: [
      [事件1插槽...],  // 第1次执行的插槽记录
      [事件2插槽...]   // 第2次执行的插槽记录
   ],
   status: 'pending|completed|failed',
   timestamp: Date.now(),
   hasAsync: boolean
   }
}
</code></pre></div></div><p>当用户点击2次相同事件时，会创建类似上述结构，每次执行独立记录，便于精确管理和清理。</p><h5 id="清理策略">清理策略</h5><p><strong>基础清理规则</strong></p><ul><li><strong>同步事件</strong>：执行完毕立即销毁上下文和相关记录</li><li><strong>异步事件</strong>：根据异步操作完成情况进行分段销毁，或等待所有异步操作成功后统一销毁</li></ul><h5 id="异常情况处理">异常情况处理</h5><p>考虑到可能存在永不回调的异步操作，在开发阶段需要设置最大生命周期监控：</p><ul><li>若副作用记录超过最大周期仍未完成，触发异常监控告警</li><li>强制销毁超时的上下文，防止内存泄漏</li></ul><h4 id="容错与恢复机制个别极端">容错与恢复机制（个别极端）</h4><p><strong>同步失败的自我纠正</strong></p><p>在多窗口同步场景中，可能出现极端情况： <code class="language-plaintext highlighter-rouge">TabA</code> 发送通讯到其他窗口，个别窗口因线程阻塞等极端情况导致同步通知丢失，需要感知异常并主动向最新版本的 <code class="language-plaintext highlighter-rouge">Leader</code> 窗口发送恢复请求。</p><p><strong>延迟销毁策略</strong></p><p>为支持容错恢复，副作用插槽的销毁需要采用延迟销毁或缓存恢复机制：</p><ul><li>延迟销毁：在正常清理时间基础上延长一定周期，为异常恢复预留时间窗口</li><li>缓存恢复：将关键副作用记录转移到持久化缓存中，支持异常情况下的状态恢复</li></ul><h4 id="闭包引用分析">闭包引用分析</h4><p>需要同步的副作用都会被劫持一次，每个劫持函数本质上都是一个上下文闭包</p><ul><li><strong>同步场景</strong>：执行完毕后闭包释放，引用自动断开</li><li><strong>异步场景</strong>：闭包持续存在，但所有闭包引用同一个全局实例，内存开销可控</li><li><strong>优化效果</strong>：全局实例共享机制有效减少了内存占用</li></ul><h4 id="逃生舱">逃生舱</h4><p>方案无法全方面兜底覆盖所有场景，并非银弹</p><ul><li><strong>第三方库副作用</strong>：不可预知、封装黑盒（如 <code class="language-plaintext highlighter-rouge">Antd</code> 动画、<code class="language-plaintext highlighter-rouge">lodash</code> <code class="language-plaintext highlighter-rouge">random</code>），只能人工接管。</li><li><strong>ref+原生事件</strong>：如 <code class="language-plaintext highlighter-rouge">DOM</code> 原生事件、直接操作 <code class="language-plaintext highlighter-rouge">ref</code>，无法劫持事件与副作用。</li><li><strong>动画</strong>：浏览器/库实现，帧同步、异步、物理引擎，副作用不可控。</li><li><strong>密集型阻塞操作</strong>：长耗时同步、<code class="language-plaintext highlighter-rouge">Web Worker</code>，大概率超出 <code class="language-plaintext highlighter-rouge">DOM/J</code>S 上下文跟踪能力。</li><li><strong>框架层调度渲染</strong>：调度系统（如 <code class="language-plaintext highlighter-rouge">React、Vue</code> 的调度模式、批处理）和组件更新优先级，触发结果和真实用户操作链路未必一一对应。</li></ul><p>针对上述情况，仍然可以降级为手动同步。插件也支持不同阶段扩展同步参数。 同时<strong>插件机制 + 操作记录</strong>会相对方便链路回放跟踪问题。</p><h5 id="举例案例分析--框架层调度渲染">举例案例分析 —— 框架层调度渲染</h5><p>以 React 为例，考虑如下代码：</p><div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Card</span><span class="p">()</span> <span class="p">{</span>
   <span class="kd">const</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="nx">update</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
   <span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">getUuid</span><span class="p">()</span><span class="c1">// &lt;===不确定副作用</span>
   <span class="p">},</span> <span class="p">[</span><span class="nx">x</span><span class="p">])</span>
   <span class="k">return</span> <span class="p">&lt;</span><span class="nt">div</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">update</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span><span class="si">}</span><span class="p">&gt;</span>click<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="p">}</span>
</code></pre></div></div><ul><li>点击触发 <code class="language-plaintext highlighter-rouge">setTimeout</code>，延迟更新 <code class="language-plaintext highlighter-rouge">x</code>。</li><li>在 <code class="language-plaintext highlighter-rouge">React</code> 的事件优先级调度、批处理; 状态更新可能被合并、延后。</li><li>如果此时另一个高优先级任务先占用调度队列，导致 <code class="language-plaintext highlighter-rouge">Card</code> 的 <code class="language-plaintext highlighter-rouge">x</code> 更新触发变成“和其他任务合并”。</li></ul><p>以上无法感知组件 <code class="language-plaintext highlighter-rouge">Card</code> 更新是 <code class="language-plaintext highlighter-rouge">click+setTimeout</code> 造成的，还是其他 <code class="language-plaintext highlighter-rouge">React</code> 内部机制合并的。 <strong>结论</strong>：副作用方案最多能以“组件为单位”追踪和同步，无法做到“事件精确归因”。</p><p>框架想兼容，与事件链路不同只能是以组件维度为最小副作用跟踪单元 以 <code class="language-plaintext highlighter-rouge">React 18</code> 的 <code class="language-plaintext highlighter-rouge">useId</code> 为例：它可以保证所有窗口下，组件节点的上下文 <code class="language-plaintext highlighter-rouge">ID</code> 一致，多窗口同步副作用时，只需根据组件 <code class="language-plaintext highlighter-rouge">ID</code> 归位，即使不是同一次事件触发也能达成一致。</p><p><strong>副作用同步的“粒度边界”</strong></p><p>只要保证组件 <code class="language-plaintext highlighter-rouge">contextId/上下文一致</code>，多窗口副作用同步就可归一到“组件级自动同步”，不关心事件链。</p><h4 id="存储">存储</h4><ul><li>时效性非常高的项目，考虑 <code class="language-plaintext highlighter-rouge">opfs + wasm</code></li><li>常规项目 <code class="language-plaintext highlighter-rouge">localStorage + indexDB</code> 存储分层即可</li></ul><p>设想会提供自动恢复的 <code class="language-plaintext highlighter-rouge">api</code>, 类似：</p><div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// const [messageList, setMessageList] = useState([])</span>
<span class="c1">// storageKey 为加密随机健</span>
<span class="kd">const</span> <span class="p">{</span> <span class="nx">useSyncState</span><span class="p">,</span> <span class="nx">storageKey</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">createSyncState</span><span class="p">();</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">messageList</span><span class="p">,</span> <span class="nx">setMessageList</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useSyncState</span><span class="p">([])</span>

<span class="c1">// 恢复前的调用，转换函数</span>
<span class="nx">syncRecover</span><span class="p">(</span><span class="nx">storageKey</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{})</span>
</code></pre></div></div><h4 id="窗口恢复">窗口恢复</h4><p>根据上述插槽设计，事件链路不强依赖固定主窗口，每个操作窗口都可以是事件发送方。 根据副作用记录的同步特性，窗口恢复分为两种场景：</p><ol><li>事件执行完毕后窗口关闭<ul><li><strong>同步操作</strong>：副作用记录已完整同步到其他窗口，可直接从记录中恢复</li><li><strong>异步操作</strong>：当某个窗口竞选为新的 <code class="language-plaintext highlighter-rouge">Leader</code> 后，接管异步上下文的执行权，将未完成的异步插槽标识为发起方继续执行</li></ul></li><li>事件执行过程中窗口恢复<ul><li>非阻塞执行链发送概率非常低。</li><li>一旦发生：新竞选的 <code class="language-plaintext highlighter-rouge">Leader</code> 窗口将重新执行完整的事件链路</li></ul></li></ol><p><del>操作链路会有类似事务的操作， 如问答系统： 对于多问一答多问多答，整个一个多问轮次可以被统计为一通操作（事务）恢复时会重新执行这一通操作</del></p><h4 id="隐式收益测试生态的构建">隐式收益：测试生态的构建</h4><p>上述方案，本身会收集用户操作指令，基于改特性。本地环境，当开发者实现某个功能时，会自动捕获该功能链路中的所有用户交互指令。</p><p>指令收集：</p><ol><li>通过智能降噪和语义提取，可以相对精确获得与特定功能相关的完整指令序列</li><li>类似reactquery 界面工具，手动记录操作开始-&gt;结束</li></ol><p>指令包括：</p><ul><li>用户交互操作（点击、输入、滚动等）</li><li>API请求调用及响应</li><li>页面状态变化</li><li>路由跳转记录</li></ul><h5 id="e2e自动化测试">E2E自动化测试</h5><p>将用户指令集直接转换为端到端测试代码（如 <code class="language-plaintext highlighter-rouge">Playwright、Cypress</code> 等）</p><p><strong>基础流程生成</strong> 将收集的指令序列直接转换为测试代码（流程）</p><p><strong>断言生成策略</strong> 每个指令对应一个事件链路，通过分析插槽记录生成关键断言（请求），按顺序将该断言插入到对应用例流程代码块中</p><h5 id="mcp智能测试平台">MCP智能测试平台</h5><p>将指令集转换为 <code class="language-plaintext highlighter-rouge">MCP（Model Context Protocol</code> 所需的标准化输入格式，让AI助手能够：</p><ul><li>理解完整的业务操作流程</li><li>自动执行功能验证测试【结合现有测试用例(前端e2e, 测试自动化测用例)的智能推断验证】</li><li>提供智能化的测试建议和优化方案</li></ul><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="https://scriptoverture.github.io/blog" target="_blank">scriptoverture</a></li><li>本文链接：<a href="https://scriptoverture.github.io/blog/2025/09/19/%E5%A4%9A%E7%AA%97%E5%8F%A3%E5%90%8C%E6%AD%A5%E6%80%9D%E8%80%83/" target="_blank">https://scriptoverture.github.io/blog/2025/09/19/%E5%A4%9A%E7%AA%97%E5%8F%A3%E5%90%8C%E6%AD%A5%E6%80%9D%E8%80%83/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"> <script src="https://giscus.app/client.js" data-repo="scriptoverture/blog" data-repo-id="R_kgDOMq9zeA" data-category="Announcements" data-category-id="DIC_kwDOMq9zeM4CiHLc" data-mapping="title" data-strict="1" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous" async> </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://scriptoverture.github.io/blog/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://scriptoverture.github.io/blog/assets/search_data.json?v=1758300993', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://scriptoverture.github.io/blog/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2024 <span title="scriptoverture">scriptoverture</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/https:/blog" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://scriptoverture.github.io/blog/" title="首页" target="">首页</a></li><li> <a href="https://scriptoverture.github.io/blog/categories/" title="分类" target="">分类</a></li><li> <a href="https://scriptoverture.github.io/blog/archives/" title="归档" target="">归档</a></li><li> <a href="https://scriptoverture.github.io/blog/open-source/" title="开源" target="">开源</a></li><li> <a href="https://scriptoverture.github.io/blog/fragments/" title="片段" target="">片段</a></li><li> <a href="https://scriptoverture.github.io/blog/wiki/" title="维基" target="">维基</a></li><li> <a href="https://scriptoverture.github.io/blog/links/" title="链接" target="">链接</a></li><li> <a href="https://scriptoverture.github.io/blog/about/" title="关于" target="">关于</a></li><li><a href="https://scriptoverture.github.io/blog/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://scriptoverture.github.io/blog/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script></body></html>
