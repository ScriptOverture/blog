<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>如何高效比较类型结构？从 TS 的类型系统到结构 Trie 优化 &mdash; overture</title><link rel="stylesheet" href="https://scriptoverture.github.io/blog/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://scriptoverture.github.io/blog/assets/css/components/collection.css"><link rel="stylesheet" href="https://scriptoverture.github.io/blog/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://scriptoverture.github.io/blog/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://scriptoverture.github.io/blog/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://scriptoverture.github.io/blog/assets/css/globals/common.css"><link rel="stylesheet" href="https://scriptoverture.github.io/blog/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://scriptoverture.github.io/blog/assets/css/posts/index.css"><link rel="stylesheet" href="https://scriptoverture.github.io/blog/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://mazhuang.org/rouge-themes/dist/github.css"><link rel="canonical" href="https://scriptoverture.github.io/blog/2025/06/16/%E6%80%9D%E8%80%83%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83-%E4%BB%8E-TypeScript-%E5%88%B0%E7%BB%93%E6%9E%84-Trie-%E7%9A%84%E4%BC%98%E5%8C%96%E8%B7%AF%E5%BE%84/"><link rel="alternate" type="application/atom+xml" title="overture" href="https://scriptoverture.github.io/blog/feed.xml"><link rel="shortcut icon" href="https://scriptoverture.github.io/blog/favicon.ico"><meta property="og:title" content="如何高效比较类型结构？从 TS 的类型系统到结构 Trie 优化"><meta name="keywords" content="JavaScript, ts, TypeScript, V8"><meta name="og:keywords" content="JavaScript, ts, TypeScript, V8"><meta name="description" content="如何高效比较类型结构？从 TS 的类型系统到结构 Trie 优化"><meta name="og:description" content="如何高效比较类型结构？从 TS 的类型系统到结构 Trie 优化"><meta property="og:url" content="https://scriptoverture.github.io/blog/2025/06/16/%E6%80%9D%E8%80%83%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83-%E4%BB%8E-TypeScript-%E5%88%B0%E7%BB%93%E6%9E%84-Trie-%E7%9A%84%E4%BC%98%E5%8C%96%E8%B7%AF%E5%BE%84/"><meta property="og:site_name" content="overture"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2025-06-16"> <script src="https://scriptoverture.github.io/blog/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://scriptoverture.github.io/blog/assets/js/main.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-Z6VKGSE98P"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-Z6VKGSE98P'); </script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://scriptoverture.github.io/blog/" title="overture"><span class="octicon octicon-mark-github"></span> overture</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://scriptoverture.github.io/blog/" class="site-header-nav-item" target="" title="首页">首页</a> <a href="https://scriptoverture.github.io/blog/categories/" class="site-header-nav-item" target="" title="分类">分类</a> <a href="https://scriptoverture.github.io/blog/archives/" class="mobile-hidden site-header-nav-item" target="" title="归档">归档</a> <a href="https://scriptoverture.github.io/blog/open-source/" class="mobile-hidden site-header-nav-item" target="" title="开源">开源</a> <a href="https://scriptoverture.github.io/blog/fragments/" class="site-header-nav-item" target="" title="片段">片段</a> <a href="https://scriptoverture.github.io/blog/wiki/" class="site-header-nav-item" target="" title="维基">维基</a> <a href="https://scriptoverture.github.io/blog/links/" class="mobile-hidden site-header-nav-item" target="" title="链接">链接</a> <a href="https://scriptoverture.github.io/blog/about/" class="site-header-nav-item" target="" title="关于">关于</a> <a class="mobile-hidden" href="https://scriptoverture.github.io/blog/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="如何高效比较类型结构？从 TS"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">如何高效比较类型结构？从 TS 的类型系统到结构 Trie 优化</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2025/06/16 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://scriptoverture.github.io/blog/categories/#JavaScript" title="JavaScript">JavaScript</a> </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://scriptoverture.github.io/blog/categories/#TypeScript" title="TypeScript">TypeScript</a> </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://scriptoverture.github.io/blog/categories/#V8" title="V8">V8</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 9679 字，约 28 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h1 id="如何高效比较类型结构从-ts-的类型系统到结构-trie-优化">如何高效比较类型结构？从 TS 的类型系统到结构 Trie 优化</h1><p>先问大家一个问题，给定俩个对象该怎么“快速”比较其是否等价？<br /> 转字符串比较吗？如果参数顺序不一致呢 遍历吗？可以 但如果嵌套层级过深呢? 好似俩颗树结构比较 深度优先遍历？可以？ 如果项目中仅仅是一处比较，暂时这么写当然没有问题，倘若存在很多很多很多组对象呢，届时就达不到快速的基准了。</p><p>可能会纳闷，为什么要问这个问题，这个跟主题 <code class="language-plaintext highlighter-rouge">ts</code> 类型有什么关联<br /> 举个很常见的示例，函数不同情况返回不同参数，猜猜他的返回类型会是什么？</p><div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">demo</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">xxx</span><span class="dl">'</span><span class="p">,</span>
            <span class="na">age</span><span class="p">:</span> <span class="mi">1</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="na">age</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">wwww</span><span class="dl">"</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">DemoReturn</span> <span class="o">=</span> <span class="nx">ReturnType</span><span class="o">&lt;</span><span class="k">typeof</span> <span class="nx">demo</span><span class="o">&gt;</span>
<span class="c1">// 输入：</span>
<span class="c1">// 1 | {</span>
<span class="c1">//     name: string;</span>
<span class="c1">//     age: number;</span>
<span class="c1">// }</span>
</code></pre></div></div><p>通过获取函数返回类型，观察其结果类型，你会惊讶的发现，其结果并不是如下所示</p><div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">DemoReturn</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> 
    <span class="na">age</span><span class="p">:</span> <span class="kr">number</span>
<span class="p">}</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">|</span> <span class="p">{</span>
    <span class="na">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span>
    <span class="na">name</span><span class="p">:</span> <span class="kr">string</span>
<span class="p">}</span>
</code></pre></div></div><p>这正是因为 <code class="language-plaintext highlighter-rouge">ts</code> 内部联合类型进行了比较并删除了相同类型</p><blockquote><p>todo:</p><ul><li>显示联合类型不会自动展开计算结果譬如 <code class="language-plaintext highlighter-rouge">TypeA | TypeB</code></li><li>而隐式联合类型会进行联合运算，譬如函数返回类型</li></ul></blockquote><p>那么回归开头的问题，既然 <code class="language-plaintext highlighter-rouge">ts</code> 内部也有对象类型比较， 他是否解决了上面抛出了一系列问题，又是否用到了什么黑魔法， 一起来揭开他神秘的面纱</p><h3 id="ts-类型比较的现状">Ts 类型比较的现状</h3><ul><li><code class="language-plaintext highlighter-rouge">ts</code> 会为所有基础类型维护全局 <code class="language-plaintext highlighter-rouge">map</code> 存储，相同字面量指向同一<code class="language-plaintext highlighter-rouge">Type</code> 引用</li><li><code class="language-plaintext highlighter-rouge">ts</code> 会遍历联合类型节点，为其互相比较</li><li>如果是对象类型比较，还需要额外遍历对象判断类型兼容<ul><li>如果遍历对象的某项类型也是对象，还需要额外深度遍历</li></ul></li><li>然后为联合类型缓存比较结果 id</li></ul><div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">removeSubtypes</span><span class="p">(</span><span class="nx">types</span><span class="p">:</span> <span class="nx">Type</span><span class="p">[],</span> <span class="nx">hasObjectTypes</span><span class="p">:</span> <span class="nx">boolean</span><span class="p">):</span> <span class="nx">Type</span><span class="p">[]</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>
        <span class="c1">// [] and [T] immediately reduce to [] and [T] respectively</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">types</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">types</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kd">const</span> <span class="nx">id</span> <span class="o">=</span> <span class="nx">getTypeListId</span><span class="p">(</span><span class="nx">types</span><span class="p">);</span>
        <span class="kd">const</span> <span class="nx">match</span> <span class="o">=</span> <span class="nx">subtypeReductionCache</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">id</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">match</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">match</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kd">const</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">types</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
        <span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">len</span><span class="p">;</span>
        <span class="kd">let</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">i</span><span class="o">--</span><span class="p">;</span>
            <span class="kd">const</span> <span class="nx">source</span> <span class="o">=</span> <span class="nx">types</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">hasEmptyObject</span> <span class="o">||</span> <span class="nx">source</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">TypeFlags</span><span class="p">.</span><span class="nx">StructuredOrInstantiable</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">target</span> <span class="k">of</span> <span class="nx">types</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="nx">source</span> <span class="o">!==</span> <span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
                        <span class="c1">// 判断类型是否相同兼容</span>
                        <span class="k">if</span> <span class="p">(</span>
                            <span class="nx">isTypeRelatedTo</span><span class="p">(</span><span class="nx">source</span><span class="p">,</span> <span class="nx">target</span><span class="p">,</span> <span class="nx">strictSubtypeRelation</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span>
                                <span class="o">!</span><span class="p">(</span><span class="nx">getObjectFlags</span><span class="p">(</span><span class="nx">getTargetType</span><span class="p">(</span><span class="nx">source</span><span class="p">))</span> <span class="o">&amp;</span> <span class="nx">ObjectFlags</span><span class="p">.</span><span class="nx">Class</span><span class="p">)</span> <span class="o">||</span>
                                <span class="o">!</span><span class="p">(</span><span class="nx">getObjectFlags</span><span class="p">(</span><span class="nx">getTargetType</span><span class="p">(</span><span class="nx">target</span><span class="p">))</span> <span class="o">&amp;</span> <span class="nx">ObjectFlags</span><span class="p">.</span><span class="nx">Class</span><span class="p">)</span> <span class="o">||</span>
                                <span class="nx">isTypeDerivedFrom</span><span class="p">(</span><span class="nx">source</span><span class="p">,</span> <span class="nx">target</span><span class="p">)</span>
                            <span class="p">)</span>
                        <span class="p">)</span> <span class="p">{</span>
                            <span class="nx">orderedRemoveItemAt</span><span class="p">(</span><span class="nx">types</span><span class="p">,</span> <span class="nx">i</span><span class="p">);</span>
                            <span class="k">break</span><span class="p">;</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nx">subtypeReductionCache</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">types</span><span class="p">);</span>
        <span class="k">return</span> <span class="nx">types</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">removeSubtypes</code> 会俩俩比较类型，相同类型结构会被删除</p><blockquote><p>假如存在多个联合类型，类型比较会存在指数级复杂度</p><p>而 <code class="language-plaintext highlighter-rouge">isTypeRelatedTo</code> 内部调用链 <code class="language-plaintext highlighter-rouge">-&gt; checkTypeRelatedTo -&gt; isRelatedTo</code></p></blockquote><p><code class="language-plaintext highlighter-rouge">isRelatedTo</code> 是 <code class="language-plaintext highlighter-rouge">TypeScript</code> 类型系统的核心函数，用于判断两个类型之间的关系</p><div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Compare two types and return
 * * Ternary.True if they are related with no assumptions,
 * * Ternary.Maybe if they are related with assumptions of other relationships, or
 * * Ternary.False if they are not related.
 */</span>
<span class="kd">function</span> <span class="nx">isRelatedTo</span><span class="p">(</span><span class="nx">originalSource</span><span class="p">:</span> <span class="nx">Type</span><span class="p">,</span> <span class="nx">originalTarget</span><span class="p">:</span> <span class="nx">Type</span><span class="p">,</span> <span class="nx">recursionFlags</span><span class="p">:</span> <span class="nx">RecursionFlags</span> <span class="o">=</span> <span class="nx">RecursionFlags</span><span class="p">.</span><span class="nx">Both</span><span class="p">,</span> <span class="nx">reportErrors</span> <span class="o">=</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">headMessage</span><span class="p">?:</span> <span class="nx">DiagnosticMessage</span><span class="p">,</span> <span class="nx">intersectionState</span> <span class="o">=</span> <span class="nx">IntersectionState</span><span class="p">.</span><span class="nx">None</span><span class="p">):</span> <span class="nx">Ternary</span> <span class="p">{</span>
  <span class="c1">// 同一类型引用</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">originalSource</span> <span class="o">===</span> <span class="nx">originalTarget</span><span class="p">)</span> <span class="k">return</span> <span class="nx">Ternary</span><span class="p">.</span><span class="nx">True</span><span class="p">;</span>
  <span class="c1">// origin 对象类型， target 为基础类型</span>
  <span class="c1">// 源类型是对象类型（如 { x: number } 或 Date）</span>
  <span class="c1">// 目标类型是原始类型（如 string, number, boolean）</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">originalSource</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">TypeFlags</span><span class="p">.</span><span class="nb">Object</span> <span class="o">&amp;&amp;</span> <span class="nx">originalTarget</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">TypeFlags</span><span class="p">.</span><span class="nx">Primitive</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">Ternary</span><span class="p">.</span><span class="nx">False</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// target 和 source 都是结构对象</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">source</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">TypeFlags</span><span class="p">.</span><span class="nx">StructuredOrInstantiable</span> <span class="o">||</span> <span class="nx">target</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">TypeFlags</span><span class="p">.</span><span class="nx">StructuredOrInstantiable</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">isPerformingExcessPropertyChecks</span> <span class="o">=</span> <span class="o">!</span><span class="p">(</span><span class="nx">intersectionState</span> <span class="o">&amp;</span> <span class="nx">IntersectionState</span><span class="p">.</span><span class="nx">Target</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">isObjectLiteralType</span><span class="p">(</span><span class="nx">source</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">getObjectFlags</span><span class="p">(</span><span class="nx">source</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nx">ObjectFlags</span><span class="p">.</span><span class="nx">FreshLiteral</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">isPerformingExcessPropertyChecks</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 判断 target 上是否有 source 的多余属性</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">hasExcessProperties</span><span class="p">(</span><span class="nx">source</span> <span class="k">as</span> <span class="nx">FreshObjectLiteralType</span><span class="p">,</span> <span class="nx">target</span><span class="p">,</span> <span class="nx">reportErrors</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">Ternary</span><span class="p">.</span><span class="nx">False</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 是否有公共属性</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">isPerformingCommonPropertyChecks</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">hasCommonProperties</span><span class="p">(</span><span class="nx">source</span><span class="p">,</span> <span class="nx">target</span><span class="p">,</span> <span class="nx">isComparingJsxAttributes</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">Ternary</span><span class="p">.</span><span class="nx">False</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">const</span> <span class="nx">skipCaching</span> <span class="o">=</span> <span class="nx">source</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">TypeFlags</span><span class="p">.</span><span class="nx">Union</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">source</span> <span class="k">as</span> <span class="nx">UnionType</span><span class="p">).</span><span class="nx">types</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="nx">target</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">TypeFlags</span><span class="p">.</span><span class="nx">Union</span><span class="p">)</span> <span class="o">||</span>
            <span class="nx">target</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">TypeFlags</span><span class="p">.</span><span class="nx">Union</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">target</span> <span class="k">as</span> <span class="nx">UnionType</span><span class="p">).</span><span class="nx">types</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="nx">source</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">TypeFlags</span><span class="p">.</span><span class="nx">StructuredOrInstantiable</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">skipCaching</span> <span class="p">?</span>
            <span class="nx">unionOrIntersectionRelatedTo</span><span class="p">(</span><span class="nx">source</span><span class="p">,</span> <span class="nx">target</span><span class="p">,</span> <span class="nx">reportErrors</span><span class="p">,</span> <span class="nx">intersectionState</span><span class="p">)</span> <span class="p">:</span>
            <span class="nx">recursiveTypeRelatedTo</span><span class="p">(</span><span class="nx">source</span><span class="p">,</span> <span class="nx">target</span><span class="p">,</span> <span class="nx">reportErrors</span><span class="p">,</span> <span class="nx">intersectionState</span><span class="p">,</span> <span class="nx">recursionFlags</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">Ternary</span><span class="p">.</span><span class="nx">False</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">recursiveTypeRelatedTo</code> 内部调用链 <code class="language-plaintext highlighter-rouge">-&gt; structuredTypeRelatedTo -&gt; structuredTypeRelatedToWorker -&gt; propertiesRelatedTo</code> 关键代码如下：</p><blockquote><p>这段代码是 <code class="language-plaintext highlighter-rouge">TypeScript</code> 类型系统中对象类型属性比较的核心部分，主要处理两个对象类型之间属性级别的兼容性检查：</p><div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 遍历源类型的所有属性</span>
<span class="c1">// 检查源属性是否存在于目标类型中</span>
 <span class="k">if</span> <span class="p">(</span><span class="nx">isObjectLiteralType</span><span class="p">(</span><span class="nx">target</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">sourceProp</span> <span class="k">of</span> <span class="nx">excludeProperties</span><span class="p">(</span><span class="nx">getPropertiesOfType</span><span class="p">(</span><span class="nx">source</span><span class="p">),</span> <span class="nx">excludedProperties</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">getPropertyOfObjectType</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">sourceProp</span><span class="p">.</span><span class="nx">escapedName</span><span class="p">))</span> <span class="p">{</span>
                <span class="kd">const</span> <span class="nx">sourceType</span> <span class="o">=</span> <span class="nx">getTypeOfSymbol</span><span class="p">(</span><span class="nx">sourceProp</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="nx">sourceType</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">TypeFlags</span><span class="p">.</span><span class="nx">Undefined</span><span class="p">))</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="nx">Ternary</span><span class="p">.</span><span class="nx">False</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 类型比较兼容检查</span>
    <span class="kd">const</span> <span class="nx">properties</span> <span class="o">=</span> <span class="nx">getPropertiesOfType</span><span class="p">(</span><span class="nx">target</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">numericNamesOnly</span> <span class="o">=</span> <span class="nx">isTupleType</span><span class="p">(</span><span class="nx">source</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">isTupleType</span><span class="p">(</span><span class="nx">target</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">targetProp</span> <span class="k">of</span> <span class="nx">excludeProperties</span><span class="p">(</span><span class="nx">properties</span><span class="p">,</span> <span class="nx">excludedProperties</span><span class="p">))</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">targetProp</span><span class="p">.</span><span class="nx">escapedName</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="nx">targetProp</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">SymbolFlags</span><span class="p">.</span><span class="nx">Prototype</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="nx">numericNamesOnly</span> <span class="o">||</span> <span class="nx">isNumericLiteralName</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="o">||</span> <span class="nx">name</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">length</span><span class="dl">"</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="nx">optionalsOnly</span> <span class="o">||</span> <span class="nx">targetProp</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">SymbolFlags</span><span class="p">.</span><span class="nx">Optional</span><span class="p">))</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">sourceProp</span> <span class="o">=</span> <span class="nx">getPropertyOfType</span><span class="p">(</span><span class="nx">source</span><span class="p">,</span> <span class="nx">name</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">sourceProp</span> <span class="o">&amp;&amp;</span> <span class="nx">sourceProp</span> <span class="o">!==</span> <span class="nx">targetProp</span><span class="p">)</span> <span class="p">{</span>
                <span class="kd">const</span> <span class="nx">related</span> <span class="o">=</span> <span class="nx">propertyRelatedTo</span><span class="p">(</span><span class="nx">source</span><span class="p">,</span> <span class="nx">target</span><span class="p">,</span> <span class="nx">sourceProp</span><span class="p">,</span> <span class="nx">targetProp</span><span class="p">,</span> <span class="nx">getNonMissingTypeOfSymbol</span><span class="p">,</span> <span class="nx">reportErrors</span><span class="p">,</span> <span class="nx">intersectionState</span><span class="p">,</span> <span class="nx">relation</span> <span class="o">===</span> <span class="nx">comparableRelation</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">related</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="nx">Ternary</span><span class="p">.</span><span class="nx">False</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="nx">result</span> <span class="o">&amp;=</span> <span class="nx">related</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><p>而 <code class="language-plaintext highlighter-rouge">propertyRelatedTo</code> 内部会调用 <code class="language-plaintext highlighter-rouge">isRelatedTo</code>， 形成深度有限遍历</p></blockquote><p>有些敏锐的小伙伴可能发现了 <code class="language-plaintext highlighter-rouge">ts</code> 这一套比较逻辑的痛点</p><ul><li>深度遍历比较，等同遍历整棵树，时间复杂度 O(n²)，尤其在嵌套复杂结构中开销巨大</li><li>斌且没有复用的概念，相似结构仍需重复比较<ul><li>无法利用已处理结构进行快速匹配与缓存。 比如下面示例<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">O_1</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="na">age</span><span class="p">:</span> <span class="kr">number</span> <span class="p">}</span>
<span class="kd">type</span> <span class="nx">O_2</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="na">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="na">other</span><span class="p">:</span> <span class="kr">any</span> <span class="p">}</span>
</code></pre></div></div><p>当 <code class="language-plaintext highlighter-rouge">O_1</code> 解析完成，<code class="language-plaintext highlighter-rouge">O_2</code> 无法复用 <code class="language-plaintext highlighter-rouge">O_1</code> 的结果，重新解析无效开销</p></li></ul></li></ul><p>最初设想是：位标识快速比较<br /> 我希望每个对象类型有一个唯一标识，通过判断标识可以快速比较类型</p><ul><li>将对象每个参数拼接 typeKind, 通过hash函数生成一组二进制</li><li><table><tbody><tr><td>结构中所有属性hash_id聚会成一个标识位（ flag</td><td>= hash_id）</td></tr></tbody></table></li><li>那么当存在联合类型比较，一方遍历对象参数生成 flag 中<ul><li>flag_1 &amp; hash_id 就能感知，当前参数是否被比较类型包含</li></ul></li></ul><p>然鹅问题</p><ul><li>位编码只能包含有限参数信息，字段过多易冲突</li><li>哈希映射不可逆，不支持嵌套结构</li><li>无法表达子结构复用与结构相似性</li></ul><h3 id="我的方案结构字段映射--前缀-trie">我的方案：结构字段映射 + 前缀 Trie</h3><p>为了解决上面的问题，我最终采取一种基于前置树的比较机制。通过将对象类型结构抽象，使得对象类型的比较从递归演变为路径匹配，以实现复用以及更好的性能</p><p>关键步骤：</p><ul><li>字段唯一 ID 映射（<code class="language-plaintext highlighter-rouge">fieldMap</code>）<ul><li>所有字段名在全局映射为递增 fieldId：如 name → 1, age → 2，避免了字符串比较</li><li>该映射确保结构中字段排序稳定，利于结构规范化</li></ul></li><li>结构字段规范化 + 排序<ul><li>对象结构按 fieldId 排序，形成结构[fieldId, typeKind]签名</li><li>排序后的结构作为 Trie 的路径，用于复用判断</li></ul></li><li>结构 Trie 构建与比较<ul><li>每条结构路径构成 Trie 的一条分支，末端节点打上唯一结构标识 flagId</li><li>同结构对象拥有相同 flagId，快速判断是否等价</li></ul></li></ul><p>展开来说：<br /> 示例一：字段顺序不同的相同结构</p><div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">O1</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="na">age</span><span class="p">:</span> <span class="kr">number</span> <span class="p">}</span>
<span class="kd">type</span> <span class="nx">O2</span> <span class="o">=</span> <span class="p">{</span> <span class="na">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="na">name</span><span class="p">:</span> <span class="kr">string</span> <span class="p">}</span>
</code></pre></div></div><ol><li>初次解析 O1，构建 fieldMap：<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">fieldMap</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">age</span><span class="p">:</span> <span class="mi">2</span> <span class="p">}</span>
</code></pre></div></div></li><li>排序组装结构签名<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[name{ fieldId_1, type_kind }, age{ fieldId_2, type_kind }]
</code></pre></div></div></li><li>构建 Trie： ```less root └── name:string (1) └── age:number (2) → flagId = 2</li></ol><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>4. 解析 O2 时：  
字段排序后仍为 `[name{ fieldId_1, type_kind }, age{ fieldId_2, type_kind }]`，Trie 路径匹配成功，得到相同 flagId = 2
结构等价

示例二：结构嵌套的复用复识别
```typescript
type O      = { name: string }
type O1     = { name: string, obj: { name: string } }
type O2     = { obj: O, name: string }
type O3     = { age: number, obj: O, name: string }
</code></pre></div></div><p>字段映射fieldMap：</p><div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">fieldMap</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">obj</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="na">age</span><span class="p">:</span> <span class="mi">3</span> <span class="p">}</span>
</code></pre></div></div><p>结构构建与复用如下：</p><table><thead><tr><th>类型</th><th>结构签名（fieldId 排序）</th><th>子结构复用</th><th>对应 flagId</th></tr></thead><tbody><tr><td>O</td><td><code class="language-plaintext highlighter-rouge">[name{ fieldId_1, type_kind }]</code></td><td>无</td><td>1</td></tr><tr><td>O1</td><td><code class="language-plaintext highlighter-rouge">[name{ fieldId_1, type_kind }, obj { fieldId_2, obj_flagId }]</code></td><td>obj 复用</td><td>2</td></tr><tr><td>O2</td><td><code class="language-plaintext highlighter-rouge">[name{ fieldId_1, type_kind }, obj { fieldId_2, obj_flagId }]</code></td><td>obj 复用</td><td>2</td></tr><tr><td>O3</td><td><code class="language-plaintext highlighter-rouge">[name{ fieldId_1, type_kind }, obj { fieldId_2, obj_flagId }, age { fieldId_3, type_kind }]</code></td><td>obj 复用</td><td>3</td></tr></tbody></table><p>最终 Trie 树形如下：</p><pre><code class="language-less">root
└── name:string (1)
    └── obj:{flag=1} (2)
        └── age:number (3) → flagId = 3
</code></pre><p>其中类型标识是在解析到字面量对象词法分析的阶段生成，因此后续不会有额外遍历开销</p><p>这样联合类型判断就可以转换为</p><div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Demo</span> <span class="o">=</span> <span class="nx">O1</span> <span class="o">|</span> <span class="nx">O2</span> <span class="o">|</span> <span class="nx">O3</span><span class="p">;</span>
<span class="c1">//  [flag_2, flag_2, flag_3]</span>
<span class="c1">// 简单去重就能就能得到结果 -&gt; O1 | O3</span>
</code></pre></div></div><p>交叉类型判断</p><div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Test</span> <span class="o">=</span> <span class="nx">O3</span> <span class="o">&amp;</span> <span class="nx">O2</span> <span class="o">&amp;</span> <span class="nx">O1</span><span class="p">;</span>
</code></pre></div></div><p>其实有了前置树后的设计也会好操作很多</p><ol><li>对于字面量对象结构，交叉类型判断可简化为路径包含关系判断。</li><li>对于复杂类型（泛型，条件类型等），可在类型调用归一化后，匹配前置树，再进行比较。</li></ol><p>具体步骤：</p><ul><li>根据 flagId 去重</li><li>根据 flagId 排序，从大到小， 反向查找路径；</li><li>路径回收，若查询到共享子路径（匹配flagId），表示为结构包含关系 抽象来说就是类型对应路径的覆盖集合</li></ul><hr /><p>优势对比：</p><table><thead><tr><th>传统递归结构比较（如 TS 实现）</th><th>Trie 结构对比方案</th></tr></thead><tbody><tr><td>深度递归比较，开销高</td><td>路径匹配，时间复杂度近似 <code class="language-plaintext highlighter-rouge">O(n)</code></td></tr><tr><td>无结构复用</td><td>子结构按路径自动复用</td></tr><tr><td>对象等价需逐字段判断</td><td>结构拥有唯一 <code class="language-plaintext highlighter-rouge">flagId</code>，直接对比</td></tr><tr><td>无嵌套优化能力</td><td>嵌套结构自动哈希压缩</td></tr><tr><td>不适合动态结构缓存</td><td>支持缓存、去重、路径剪枝</td></tr></tbody></table><h3 id="隐藏类">隐藏类</h3><p>因为前置树方案与 <code class="language-plaintext highlighter-rouge">V8</code> 引擎中（<code class="language-plaintext highlighter-rouge">Hidden Class</code>）隐藏类机制高度相似，也顺手提上一嘴吧</p><p>总所周知哈，<code class="language-plaintext highlighter-rouge">javascript</code> 是动态类型语言因此非常的灵活，与静态类型语言不同，<code class="language-plaintext highlighter-rouge">js</code> 对象可以动态修改比如下面 <code class="language-plaintext highlighter-rouge">age</code> 属性， 这使得无法确认其静态结构，与其相关的内存布局。</p><div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">mingrui</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">address</span><span class="p">:</span> <span class="dl">'</span><span class="s1">xxxx</span><span class="dl">'</span>
<span class="p">}</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">25</span><span class="dl">"</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">record</span><span class="p">:</span> <span class="p">{}</span>
<span class="p">}</span>
</code></pre></div></div><p>为了更方便理解，想象一下自己经营「物品托管所」，而你作为店铺老板，为了方便管理物品，自然的会准备本小本子 记录有哪些物品以及对应存放位置。<br /> 最初的 <code class="language-plaintext highlighter-rouge">obj</code> 看起来是这样的：</p><div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">mingrui</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">address</span><span class="p">:</span> <span class="dl">'</span><span class="s1">xxxx</span><span class="dl">'</span>
<span class="p">}</span>
</code></pre></div></div><p>此时它的「存储表（store_table）」为</p><div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">store_table</span> <span class="p">{</span>
    <span class="nl">name</span><span class="p">:</span> <span class="nx">ptr</span><span class="p">(</span><span class="dl">'</span><span class="s1">存储位置</span><span class="dl">'</span><span class="p">)</span>
    <span class="nx">age</span><span class="p">:</span> <span class="nx">ptr</span><span class="p">(</span><span class="dl">'</span><span class="s1">存储位置</span><span class="dl">'</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div><p>这时有人需要更新存储 age = { xx: ‘xx’ }, 对象结构发生变化，原来的“托管所”存储位置不再适用， 为了不失去这个客户，你打算忽悠身边朋友也来做物品托管，让其店铺代存，此时物品编号映射表为</p><div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">store_table</span> <span class="p">{</span>
    <span class="nl">name</span><span class="p">:</span> <span class="nx">ptr</span><span class="p">(</span><span class="dl">'</span><span class="s1">存储位置</span><span class="dl">'</span><span class="p">)</span>
    <span class="nx">age</span><span class="p">:</span> <span class="nx">storeA_table</span>
<span class="p">}</span>

<span class="nx">storeA_table</span> <span class="p">{</span>
  <span class="nl">xx</span><span class="p">:</span> <span class="nx">ptr</span><span class="p">(</span><span class="dl">'</span><span class="s1">存储位置</span><span class="dl">'</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div><p>这时如果客户需要获取存储物品 <code class="language-plaintext highlighter-rouge">age</code> 则需要多一层，联系其他店铺获取。<br /> 最开始这种层级式的托管是可以接受的，但随着结构变更越来越频繁，你托管关联的「物品托管所」也越来越多，就会出现问题了：</p><blockquote><p><strong>多层查找、多级托管，极大增加了查找开销。</strong></p></blockquote><p>通过上面你可能敏锐的发现，如果事先就知道需要存储哪些物品，物品直接关联的位置也就没有这些开销了(静态化<br /> 那么怎么让动态存储趋于静态化呢？</p><p>隐藏类的本质：模拟静态结构 核心作用：</p><ul><li>记录属性偏移量：为每个属性分配固定的内存偏移地址</li><li>结构共享复用：相同结果共享同一个隐藏类实例，复用属性偏移地址</li></ul><p>传统hash表 假设访问 obj.age.xx, 对应流程</p><div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">value</span> <span class="o">=</span> <span class="nx">hash_table</span><span class="p">[</span><span class="dl">'</span><span class="s1">age</span><span class="dl">'</span><span class="p">].</span><span class="nx">hash_table</span><span class="p">[</span><span class="dl">'</span><span class="s1">xx</span><span class="dl">'</span><span class="p">]</span>
</code></pre></div></div><p>因为不感知属性在 <code class="language-plaintext highlighter-rouge">hash</code> 表中的具体位置，每次获取都需要：</p><ul><li>计算hash -&gt; 定位桶 -&gt; 处理冲突</li></ul><p>隐藏类流程</p><div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{}</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">propertieA</span> <span class="o">=</span> <span class="mi">1</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">propertieB</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div></div><div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">struct</span> <span class="nx">obj</span> <span class="p">{</span>
    <span class="nx">hiddenClass</span> <span class="o">-&gt;</span> <span class="nx">hiddenClass_A</span> <span class="c1">// 隐藏类指针</span>
    <span class="nx">properties</span>  <span class="o">-&gt;</span> <span class="nx">ptr</span>
<span class="p">}</span>

<span class="nx">hiddenClass_A</span> <span class="p">{</span>
  <span class="nl">propertieA</span><span class="p">:</span> <span class="nx">offect</span> <span class="mi">0</span> <span class="c1">// 偏移量</span>
<span class="p">}</span>
<span class="nx">hiddenClass_A</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">propertieB</span><span class="p">)</span>
<span class="nx">hiddenClass_B</span> <span class="p">{</span>
  <span class="nl">propertieB</span><span class="p">:</span> <span class="nx">offect</span> <span class="mi">1</span> <span class="c1">// 偏移量</span>
<span class="p">}</span>
<span class="c1">// hiddenClass_A -&gt; hiddenClass_B</span>
<span class="c1">// 更新 struct_obj hiddenClass 指针为hiddenClass_B</span>
</code></pre></div></div><p><img src="https://v8.dev/_img/fast-properties/adding-properties.png" alt="xx" /> 那么其属性访问流程：</p><ul><li>通过获取 obj 隐藏类指针地址以及 属性偏移位置 propertieB 为 1</li><li>属性值的地址 = 对象结构指针地址 + 属性值偏移位置</li><li>获取值</li></ul><p>有三种不同的命名属性类型：对象内、快速和慢速/字典。</p><table><thead><tr><th>属性类型</th><th>存储方式</th><th>访问速度</th><th>适用场景</th></tr></thead><tbody><tr><td>对象内属性</td><td>内联在对象内存块中</td><td>极快（单次加法）</td><td>结构稳定时</td></tr><tr><td>快速属性</td><td>属性存储区 + 隐藏类描述符</td><td>快（需查找隐藏类）</td><td>结构轻微变化时</td></tr><tr><td>慢速属性</td><td>独立哈希表</td><td>慢（哈希计算 + 冲突处理）</td><td>结构频繁变化时</td></tr></tbody></table><p>所以每当对象创建，申请内存上都会预留一些空间，而隐藏类事先计算改好了属性偏移量就可以消费对应内存， 当空间不够用时，就会创建hash表退化为慢速属性</p><p>衍生问题</p><ol><li>预编译阶段，此法环境创建的VO对象是否有隐藏类的机制？</li><li>闭包对象是否也具备隐藏类优化？<h4 id="动机">动机？</h4><p>可能有人会好奇：“写代码写到研究类型结构比较，图啥？你卷你*呢”<br /> 其实这一切都源自我在做的一个项目 —— 类型逆向推导。本质是根据字面量的结构与其具体消费值，自动还原其在 TypeScript 中的最精确类型。 （其中联合推断碰到类型比较的问题，当时还好奇ts会不会有什么黑魔法借鉴来着）</p></li></ol><p>举个栗子<br /> 例如下面函数，通过分析字面量以及if判断，既可以推导 props.type 是 number 和 string 的联合类型 同样的可以推导obj, 而props.obj 与obj同一引用，因此可以得到完整的props：</p><div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">demo</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">{</span> <span class="kd">type</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">props</span>
    <span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nx">props</span><span class="p">.</span><span class="nx">obj</span>
    <span class="k">if</span> <span class="p">(</span><span class="kd">type</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="p">(</span><span class="kd">type</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">xx</span><span class="dl">"</span><span class="p">)</span> <span class="p">{}</span>
    <span class="nx">obj</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="nx">obj</span>
<span class="p">}</span>

<span class="c1">// 推断结果：</span>
<span class="kd">type</span> <span class="nx">Props</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">type</span><span class="p">:</span> <span class="kr">number</span> <span class="o">|</span> <span class="kr">string</span><span class="p">,</span>
    <span class="na">obj</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">a</span><span class="p">:</span> <span class="kr">number</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>亦或者是这种典型的条件返回函数，根据条件分支，反推出函数的重载类型：</p><div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">demo</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="kd">type</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="kd">type</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">x</span><span class="dl">"</span><span class="p">)</span> <span class="k">return</span> <span class="dl">'</span><span class="s1">string</span><span class="dl">'</span>
    <span class="k">return</span> <span class="p">[</span><span class="dl">'</span><span class="s1">xxx</span><span class="dl">'</span><span class="p">]</span>
<span class="p">}</span>

<span class="c1">// 推断结果</span>
<span class="kd">function</span> <span class="nx">demo</span><span class="p">(</span><span class="nx">props</span><span class="p">:</span> <span class="nx">unknown</span><span class="p">):</span> <span class="kr">string</span><span class="p">[];</span>
<span class="kd">function</span> <span class="nx">demo</span><span class="p">(</span><span class="nx">props</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="kr">string</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">demo</span><span class="p">(</span><span class="nx">props</span><span class="p">:</span> <span class="nx">object</span><span class="p">):</span> <span class="kr">number</span><span class="p">;</span>

<span class="nx">demo</span><span class="p">(</span><span class="dl">"</span><span class="s2">x</span><span class="dl">"</span><span class="p">)</span> <span class="c1">// -&gt; string</span>
<span class="nx">demo</span><span class="p">({})</span>  <span class="c1">// -&gt; number</span>
<span class="nx">demo</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>   <span class="c1">// -&gt; string[]</span>
</code></pre></div></div><p>当然真实项目远不止这些简单的场景：</p><ul><li>跨模块，跨多层作用域</li><li>泛型，条件兼容</li><li>显示标注类型与推断类型兼容</li><li>等等</li></ul><p>那么为什么想做这玩意？<br /> 最开始仅仅是因为为项目修复 <code class="language-plaintext highlighter-rouge">ts</code> 警告时，修复过程过于机械化，便想着为其注入灵魂让其自动推导</p><p>仅仅推导函数类型是不够了，其中不乏有一些设想：</p><ol><li>我觉得可以让推导配合 <code class="language-plaintext highlighter-rouge">ts</code> 做到绝对的静态，所见即所得<ul><li>无法推导的动态数据用 <code class="language-plaintext highlighter-rouge">ts</code> 标注比如（接口，文件获取，JSON转换等</li><li>通过标识类型推导其他类型</li></ul></li><li>有了具体类型，可以搭配自动化生成对应单侧<ul><li>然鹅总所周知,<code class="language-plaintext highlighter-rouge">ts</code> 并不存在运行态，无法做到运行时校验，市面上虽然有相关的库, 都有有一些缺点：<ul><li>需要入侵项目</li><li>增加额外的运行开销</li></ul></li><li>既然有单侧和 <code class="language-plaintext highlighter-rouge">e2e</code> 何不假想，本地运行态校验，而不影响预发线上环境呢<ul><li>类型推导过模块后会生成缓存文件类似.umi</li><li>开发一款插件，代理模块资源，匹配上缓存文件，走代理调用外层包一层类型推断</li><li>类型推断根据缓存文件以及运行数据断言</li><li>类型断言完全不影响开发心智，无需额外增加代码，也不影响其他环境</li></ul></li></ul></li><li>因为推断过程可以获取到足够多的信息，是可以感知，哪些函数不合理<ul><li>比如修改源数据</li><li>组件内创建传函数等</li><li>但这一块设想因为 ai吃掉了很大一部分，倒希望利用解析到足够多的信息怎么加入他们</li></ul></li></ol><p>进度情况</p><p>参考文章：</p><ul><li><a href="https://zh.wikipedia.org/zh-hans/Trie">前置树Trie</a></li><li><a href="https://v8.dev/docs/hidden-classes">V8 中的隐藏类</a></li><li><a href="https://v8.dev/blog/fast-properties">V8 中的快速属性</a></li><li><a href="https://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html">内联缓存</a></li><li><a href="https://github.com/ScriptOverture/InferType">类型推断</a></li></ul><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="https://scriptoverture.github.io/blog" target="_blank">scriptoverture</a></li><li>本文链接：<a href="https://scriptoverture.github.io/blog/2025/06/16/%E6%80%9D%E8%80%83%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83-%E4%BB%8E-TypeScript-%E5%88%B0%E7%BB%93%E6%9E%84-Trie-%E7%9A%84%E4%BC%98%E5%8C%96%E8%B7%AF%E5%BE%84/" target="_blank">https://scriptoverture.github.io/blog/2025/06/16/%E6%80%9D%E8%80%83%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83-%E4%BB%8E-TypeScript-%E5%88%B0%E7%BB%93%E6%9E%84-Trie-%E7%9A%84%E4%BC%98%E5%8C%96%E8%B7%AF%E5%BE%84/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"> <script src="https://giscus.app/client.js" data-repo="scriptoverture/blog" data-repo-id="R_kgDOMq9zeA" data-category="Announcements" data-category-id="DIC_kwDOMq9zeM4CiHLc" data-mapping="title" data-strict="1" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous" async> </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://scriptoverture.github.io/blog/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://scriptoverture.github.io/blog/assets/search_data.json?v=1758293612', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://scriptoverture.github.io/blog/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2024 <span title="scriptoverture">scriptoverture</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/https:/blog" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://scriptoverture.github.io/blog/" title="首页" target="">首页</a></li><li> <a href="https://scriptoverture.github.io/blog/categories/" title="分类" target="">分类</a></li><li> <a href="https://scriptoverture.github.io/blog/archives/" title="归档" target="">归档</a></li><li> <a href="https://scriptoverture.github.io/blog/open-source/" title="开源" target="">开源</a></li><li> <a href="https://scriptoverture.github.io/blog/fragments/" title="片段" target="">片段</a></li><li> <a href="https://scriptoverture.github.io/blog/wiki/" title="维基" target="">维基</a></li><li> <a href="https://scriptoverture.github.io/blog/links/" title="链接" target="">链接</a></li><li> <a href="https://scriptoverture.github.io/blog/about/" title="关于" target="">关于</a></li><li><a href="https://scriptoverture.github.io/blog/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://scriptoverture.github.io/blog/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script></body></html>
